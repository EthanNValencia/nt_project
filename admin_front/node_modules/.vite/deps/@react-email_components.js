import {
  CDATA,
  Comment,
  Directive,
  Doctype,
  ElementType,
  Root,
  Script,
  Style,
  Tag,
  Text,
  esm_exports,
  isTag,
  o,
  require_cjs,
  require_pretty
} from "./chunk-EIE4NH5D.js";
import {
  require_server_browser
} from "./chunk-UBXT43YC.js";
import {
  require_jsx_runtime
} from "./chunk-UFCMWVQY.js";
import {
  require_react
} from "./chunk-RDZYK52F.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/domelementtype/lib/index.js
var require_lib = __commonJS({
  "node_modules/domelementtype/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
    var ElementType2;
    (function(ElementType3) {
      ElementType3["Root"] = "root";
      ElementType3["Text"] = "text";
      ElementType3["Directive"] = "directive";
      ElementType3["Comment"] = "comment";
      ElementType3["Script"] = "script";
      ElementType3["Style"] = "style";
      ElementType3["Tag"] = "tag";
      ElementType3["CDATA"] = "cdata";
      ElementType3["Doctype"] = "doctype";
    })(ElementType2 = exports.ElementType || (exports.ElementType = {}));
    function isTag3(elem) {
      return elem.type === ElementType2.Tag || elem.type === ElementType2.Script || elem.type === ElementType2.Style;
    }
    exports.isTag = isTag3;
    exports.Root = ElementType2.Root;
    exports.Text = ElementType2.Text;
    exports.Directive = ElementType2.Directive;
    exports.Comment = ElementType2.Comment;
    exports.Script = ElementType2.Script;
    exports.Style = ElementType2.Style;
    exports.Tag = ElementType2.Tag;
    exports.CDATA = ElementType2.CDATA;
    exports.Doctype = ElementType2.Doctype;
  }
});

// node_modules/html-react-parser/node_modules/domhandler/lib/node.js
var require_node = __commonJS({
  "node_modules/html-react-parser/node_modules/domhandler/lib/node.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
    var domelementtype_1 = require_lib();
    var Node2 = (
      /** @class */
      function() {
        function Node3() {
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node3.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.parent;
          },
          set: function(parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.prev;
          },
          set: function(prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.next;
          },
          set: function(next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true
        });
        Node3.prototype.cloneNode = function(recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode2(this, recursive);
        };
        return Node3;
      }()
    );
    exports.Node = Node2;
    var DataNode2 = (
      /** @class */
      function(_super) {
        __extends(DataNode3, _super);
        function DataNode3(data) {
          var _this = _super.call(this) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode3.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.data;
          },
          set: function(data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true
        });
        return DataNode3;
      }(Node2)
    );
    exports.DataNode = DataNode2;
    var Text5 = (
      /** @class */
      function(_super) {
        __extends(Text6, _super);
        function Text6() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Text;
          return _this;
        }
        Object.defineProperty(Text6.prototype, "nodeType", {
          get: function() {
            return 3;
          },
          enumerable: false,
          configurable: true
        });
        return Text6;
      }(DataNode2)
    );
    exports.Text = Text5;
    var Comment4 = (
      /** @class */
      function(_super) {
        __extends(Comment5, _super);
        function Comment5() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Comment;
          return _this;
        }
        Object.defineProperty(Comment5.prototype, "nodeType", {
          get: function() {
            return 8;
          },
          enumerable: false,
          configurable: true
        });
        return Comment5;
      }(DataNode2)
    );
    exports.Comment = Comment4;
    var ProcessingInstruction3 = (
      /** @class */
      function(_super) {
        __extends(ProcessingInstruction4, _super);
        function ProcessingInstruction4(name, data) {
          var _this = _super.call(this, data) || this;
          _this.name = name;
          _this.type = domelementtype_1.ElementType.Directive;
          return _this;
        }
        Object.defineProperty(ProcessingInstruction4.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        return ProcessingInstruction4;
      }(DataNode2)
    );
    exports.ProcessingInstruction = ProcessingInstruction3;
    var NodeWithChildren2 = (
      /** @class */
      function(_super) {
        __extends(NodeWithChildren3, _super);
        function NodeWithChildren3(children) {
          var _this = _super.call(this) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren3.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function() {
            var _a3;
            return (_a3 = this.children[0]) !== null && _a3 !== void 0 ? _a3 : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren3.prototype, "lastChild", {
          /** Last child of the node. */
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren3.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.children;
          },
          set: function(children) {
            this.children = children;
          },
          enumerable: false,
          configurable: true
        });
        return NodeWithChildren3;
      }(Node2)
    );
    exports.NodeWithChildren = NodeWithChildren2;
    var CDATA3 = (
      /** @class */
      function(_super) {
        __extends(CDATA4, _super);
        function CDATA4() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.CDATA;
          return _this;
        }
        Object.defineProperty(CDATA4.prototype, "nodeType", {
          get: function() {
            return 4;
          },
          enumerable: false,
          configurable: true
        });
        return CDATA4;
      }(NodeWithChildren2)
    );
    exports.CDATA = CDATA3;
    var Document2 = (
      /** @class */
      function(_super) {
        __extends(Document3, _super);
        function Document3() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Root;
          return _this;
        }
        Object.defineProperty(Document3.prototype, "nodeType", {
          get: function() {
            return 9;
          },
          enumerable: false,
          configurable: true
        });
        return Document3;
      }(NodeWithChildren2)
    );
    exports.Document = Document2;
    var Element3 = (
      /** @class */
      function(_super) {
        __extends(Element4, _super);
        function Element4(name, attribs, children, type) {
          if (children === void 0) {
            children = [];
          }
          if (type === void 0) {
            type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, children) || this;
          _this.name = name;
          _this.attribs = attribs;
          _this.type = type;
          return _this;
        }
        Object.defineProperty(Element4.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element4.prototype, "tagName", {
          // DOM Level 1 aliases
          /**
           * Same as {@link name}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.name;
          },
          set: function(name) {
            this.name = name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element4.prototype, "attributes", {
          get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name) {
              var _a3, _b;
              return {
                name,
                value: _this.attribs[name],
                namespace: (_a3 = _this["x-attribsNamespace"]) === null || _a3 === void 0 ? void 0 : _a3[name],
                prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
              };
            });
          },
          enumerable: false,
          configurable: true
        });
        return Element4;
      }(NodeWithChildren2)
    );
    exports.Element = Element3;
    function isTag3(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports.isTag = isTag3;
    function isCDATA2(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports.isCDATA = isCDATA2;
    function isText2(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports.isText = isText2;
    function isComment2(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports.isComment = isComment2;
    function isDirective2(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports.isDirective = isDirective2;
    function isDocument2(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports.isDocument = isDocument2;
    function hasChildren2(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports.hasChildren = hasChildren2;
    function cloneNode2(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result;
      if (isText2(node)) {
        result = new Text5(node.data);
      } else if (isComment2(node)) {
        result = new Comment4(node.data);
      } else if (isTag3(node)) {
        var children = recursive ? cloneChildren2(node.children) : [];
        var clone_1 = new Element3(node.name, __assign({}, node.attribs), children);
        children.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
      } else if (isCDATA2(node)) {
        var children = recursive ? cloneChildren2(node.children) : [];
        var clone_2 = new CDATA3(children);
        children.forEach(function(child) {
          return child.parent = clone_2;
        });
        result = clone_2;
      } else if (isDocument2(node)) {
        var children = recursive ? cloneChildren2(node.children) : [];
        var clone_3 = new Document2(children);
        children.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
      } else if (isDirective2(node)) {
        var instruction = new ProcessingInstruction3(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
    }
    exports.cloneNode = cloneNode2;
    function cloneChildren2(childs) {
      var children = childs.map(function(child) {
        return cloneNode2(child, true);
      });
      for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
      }
      return children;
    }
  }
});

// node_modules/html-react-parser/node_modules/domhandler/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/html-react-parser/node_modules/domhandler/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DomHandler = void 0;
    var domelementtype_1 = require_lib();
    var node_js_1 = require_node();
    __exportStar(require_node(), exports);
    var defaultOpts2 = {
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler2 = (
      /** @class */
      function() {
        function DomHandler3(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts2;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts2;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler3.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler3.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler3.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler3.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler3.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler3.prototype.onopentag = function(name, attribs) {
          var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element = new node_js_1.Element(name, attribs, void 0, type);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler3.prototype.ontext = function(data) {
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler3.prototype.oncomment = function(data) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_js_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler3.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler3.prototype.oncdatastart = function() {
          var text = new node_js_1.Text("");
          var node = new node_js_1.CDATA([text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
        };
        DomHandler3.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler3.prototype.onprocessinginstruction = function(name, data) {
          var node = new node_js_1.ProcessingInstruction(name, data);
          this.addNode(node);
        };
        DomHandler3.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler3.prototype.addNode = function(node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler3;
      }()
    );
    exports.DomHandler = DomHandler2;
    exports.default = DomHandler2;
  }
});

// node_modules/html-dom-parser/lib/client/domparser.js
var require_domparser = __commonJS({
  "node_modules/html-dom-parser/lib/client/domparser.js"(exports, module) {
    var HTML = "html";
    var HEAD = "head";
    var BODY = "body";
    var FIRST_TAG_REGEX = /<([a-zA-Z]+[0-9]?)/;
    var HEAD_TAG_REGEX = /<head[^]*>/i;
    var BODY_TAG_REGEX = /<body[^]*>/i;
    var parseFromDocument = function() {
      throw new Error(
        "This browser does not support `document.implementation.createHTMLDocument`"
      );
    };
    var parseFromString = function() {
      throw new Error(
        "This browser does not support `DOMParser.prototype.parseFromString`"
      );
    };
    var DOMParser = typeof window === "object" && window.DOMParser;
    if (typeof DOMParser === "function") {
      domParser = new DOMParser();
      mimeType = "text/html";
      parseFromString = function(html, tagName) {
        if (tagName) {
          html = "<" + tagName + ">" + html + "</" + tagName + ">";
        }
        return domParser.parseFromString(html, mimeType);
      };
      parseFromDocument = parseFromString;
    }
    var domParser;
    var mimeType;
    if (typeof document === "object" && document.implementation) {
      doc = document.implementation.createHTMLDocument();
      parseFromDocument = function(html, tagName) {
        if (tagName) {
          var element = doc.documentElement.querySelector(tagName);
          element.innerHTML = html;
          return doc;
        }
        doc.documentElement.innerHTML = html;
        return doc;
      };
    }
    var doc;
    var template = typeof document === "object" ? document.createElement("template") : {};
    var parseFromTemplate;
    if (template.content) {
      parseFromTemplate = function(html) {
        template.innerHTML = html;
        return template.content.childNodes;
      };
    }
    function domparser(html) {
      var firstTagName;
      var match = html.match(FIRST_TAG_REGEX);
      if (match && match[1]) {
        firstTagName = match[1].toLowerCase();
      }
      var doc2;
      var element;
      var elements;
      switch (firstTagName) {
        case HTML:
          doc2 = parseFromString(html);
          if (!HEAD_TAG_REGEX.test(html)) {
            element = doc2.querySelector(HEAD);
            if (element) {
              element.parentNode.removeChild(element);
            }
          }
          if (!BODY_TAG_REGEX.test(html)) {
            element = doc2.querySelector(BODY);
            if (element) {
              element.parentNode.removeChild(element);
            }
          }
          return doc2.querySelectorAll(HTML);
        case HEAD:
        case BODY:
          doc2 = parseFromDocument(html);
          elements = doc2.querySelectorAll(firstTagName);
          if (BODY_TAG_REGEX.test(html) && HEAD_TAG_REGEX.test(html)) {
            return elements[0].parentNode.childNodes;
          }
          return elements;
        default:
          if (parseFromTemplate) {
            return parseFromTemplate(html);
          }
          element = parseFromDocument(html, BODY).querySelector(BODY);
          return element.childNodes;
      }
    }
    module.exports = domparser;
  }
});

// node_modules/html-dom-parser/node_modules/domhandler/lib/node.js
var require_node2 = __commonJS({
  "node_modules/html-dom-parser/node_modules/domhandler/lib/node.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
    var domelementtype_1 = require_lib();
    var Node2 = (
      /** @class */
      function() {
        function Node3() {
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node3.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.parent;
          },
          set: function(parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.prev;
          },
          set: function(prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.next;
          },
          set: function(next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true
        });
        Node3.prototype.cloneNode = function(recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode2(this, recursive);
        };
        return Node3;
      }()
    );
    exports.Node = Node2;
    var DataNode2 = (
      /** @class */
      function(_super) {
        __extends(DataNode3, _super);
        function DataNode3(data) {
          var _this = _super.call(this) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode3.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.data;
          },
          set: function(data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true
        });
        return DataNode3;
      }(Node2)
    );
    exports.DataNode = DataNode2;
    var Text5 = (
      /** @class */
      function(_super) {
        __extends(Text6, _super);
        function Text6() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Text;
          return _this;
        }
        Object.defineProperty(Text6.prototype, "nodeType", {
          get: function() {
            return 3;
          },
          enumerable: false,
          configurable: true
        });
        return Text6;
      }(DataNode2)
    );
    exports.Text = Text5;
    var Comment4 = (
      /** @class */
      function(_super) {
        __extends(Comment5, _super);
        function Comment5() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Comment;
          return _this;
        }
        Object.defineProperty(Comment5.prototype, "nodeType", {
          get: function() {
            return 8;
          },
          enumerable: false,
          configurable: true
        });
        return Comment5;
      }(DataNode2)
    );
    exports.Comment = Comment4;
    var ProcessingInstruction3 = (
      /** @class */
      function(_super) {
        __extends(ProcessingInstruction4, _super);
        function ProcessingInstruction4(name, data) {
          var _this = _super.call(this, data) || this;
          _this.name = name;
          _this.type = domelementtype_1.ElementType.Directive;
          return _this;
        }
        Object.defineProperty(ProcessingInstruction4.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        return ProcessingInstruction4;
      }(DataNode2)
    );
    exports.ProcessingInstruction = ProcessingInstruction3;
    var NodeWithChildren2 = (
      /** @class */
      function(_super) {
        __extends(NodeWithChildren3, _super);
        function NodeWithChildren3(children) {
          var _this = _super.call(this) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren3.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function() {
            var _a3;
            return (_a3 = this.children[0]) !== null && _a3 !== void 0 ? _a3 : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren3.prototype, "lastChild", {
          /** Last child of the node. */
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren3.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.children;
          },
          set: function(children) {
            this.children = children;
          },
          enumerable: false,
          configurable: true
        });
        return NodeWithChildren3;
      }(Node2)
    );
    exports.NodeWithChildren = NodeWithChildren2;
    var CDATA3 = (
      /** @class */
      function(_super) {
        __extends(CDATA4, _super);
        function CDATA4() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.CDATA;
          return _this;
        }
        Object.defineProperty(CDATA4.prototype, "nodeType", {
          get: function() {
            return 4;
          },
          enumerable: false,
          configurable: true
        });
        return CDATA4;
      }(NodeWithChildren2)
    );
    exports.CDATA = CDATA3;
    var Document2 = (
      /** @class */
      function(_super) {
        __extends(Document3, _super);
        function Document3() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Root;
          return _this;
        }
        Object.defineProperty(Document3.prototype, "nodeType", {
          get: function() {
            return 9;
          },
          enumerable: false,
          configurable: true
        });
        return Document3;
      }(NodeWithChildren2)
    );
    exports.Document = Document2;
    var Element3 = (
      /** @class */
      function(_super) {
        __extends(Element4, _super);
        function Element4(name, attribs, children, type) {
          if (children === void 0) {
            children = [];
          }
          if (type === void 0) {
            type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, children) || this;
          _this.name = name;
          _this.attribs = attribs;
          _this.type = type;
          return _this;
        }
        Object.defineProperty(Element4.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element4.prototype, "tagName", {
          // DOM Level 1 aliases
          /**
           * Same as {@link name}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.name;
          },
          set: function(name) {
            this.name = name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element4.prototype, "attributes", {
          get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name) {
              var _a3, _b;
              return {
                name,
                value: _this.attribs[name],
                namespace: (_a3 = _this["x-attribsNamespace"]) === null || _a3 === void 0 ? void 0 : _a3[name],
                prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
              };
            });
          },
          enumerable: false,
          configurable: true
        });
        return Element4;
      }(NodeWithChildren2)
    );
    exports.Element = Element3;
    function isTag3(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports.isTag = isTag3;
    function isCDATA2(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports.isCDATA = isCDATA2;
    function isText2(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports.isText = isText2;
    function isComment2(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports.isComment = isComment2;
    function isDirective2(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports.isDirective = isDirective2;
    function isDocument2(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports.isDocument = isDocument2;
    function hasChildren2(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports.hasChildren = hasChildren2;
    function cloneNode2(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result;
      if (isText2(node)) {
        result = new Text5(node.data);
      } else if (isComment2(node)) {
        result = new Comment4(node.data);
      } else if (isTag3(node)) {
        var children = recursive ? cloneChildren2(node.children) : [];
        var clone_1 = new Element3(node.name, __assign({}, node.attribs), children);
        children.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
      } else if (isCDATA2(node)) {
        var children = recursive ? cloneChildren2(node.children) : [];
        var clone_2 = new CDATA3(children);
        children.forEach(function(child) {
          return child.parent = clone_2;
        });
        result = clone_2;
      } else if (isDocument2(node)) {
        var children = recursive ? cloneChildren2(node.children) : [];
        var clone_3 = new Document2(children);
        children.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
      } else if (isDirective2(node)) {
        var instruction = new ProcessingInstruction3(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
    }
    exports.cloneNode = cloneNode2;
    function cloneChildren2(childs) {
      var children = childs.map(function(child) {
        return cloneNode2(child, true);
      });
      for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
      }
      return children;
    }
  }
});

// node_modules/html-dom-parser/node_modules/domhandler/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/html-dom-parser/node_modules/domhandler/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DomHandler = void 0;
    var domelementtype_1 = require_lib();
    var node_js_1 = require_node2();
    __exportStar(require_node2(), exports);
    var defaultOpts2 = {
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler2 = (
      /** @class */
      function() {
        function DomHandler3(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts2;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts2;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler3.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler3.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler3.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler3.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler3.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler3.prototype.onopentag = function(name, attribs) {
          var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element = new node_js_1.Element(name, attribs, void 0, type);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler3.prototype.ontext = function(data) {
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler3.prototype.oncomment = function(data) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_js_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler3.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler3.prototype.oncdatastart = function() {
          var text = new node_js_1.Text("");
          var node = new node_js_1.CDATA([text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
        };
        DomHandler3.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler3.prototype.onprocessinginstruction = function(name, data) {
          var node = new node_js_1.ProcessingInstruction(name, data);
          this.addNode(node);
        };
        DomHandler3.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler3.prototype.addNode = function(node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler3;
      }()
    );
    exports.DomHandler = DomHandler2;
    exports.default = DomHandler2;
  }
});

// node_modules/html-dom-parser/lib/client/constants.js
var require_constants = __commonJS({
  "node_modules/html-dom-parser/lib/client/constants.js"(exports) {
    exports.CASE_SENSITIVE_TAG_NAMES = [
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussainBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "linearGradient",
      "radialGradient",
      "textPath"
    ];
  }
});

// node_modules/html-dom-parser/lib/client/utilities.js
var require_utilities = __commonJS({
  "node_modules/html-dom-parser/lib/client/utilities.js"(exports) {
    var domhandler = require_lib3();
    var constants = require_constants();
    var CASE_SENSITIVE_TAG_NAMES = constants.CASE_SENSITIVE_TAG_NAMES;
    var Comment4 = domhandler.Comment;
    var Element3 = domhandler.Element;
    var ProcessingInstruction3 = domhandler.ProcessingInstruction;
    var Text5 = domhandler.Text;
    var caseSensitiveTagNamesMap = {};
    var tagName;
    for (i = 0, len = CASE_SENSITIVE_TAG_NAMES.length; i < len; i++) {
      tagName = CASE_SENSITIVE_TAG_NAMES[i];
      caseSensitiveTagNamesMap[tagName.toLowerCase()] = tagName;
    }
    var i;
    var len;
    function getCaseSensitiveTagName(tagName2) {
      return caseSensitiveTagNamesMap[tagName2];
    }
    function formatAttributes2(attributes) {
      var result = {};
      var attribute;
      for (var i2 = 0, len2 = attributes.length; i2 < len2; i2++) {
        attribute = attributes[i2];
        result[attribute.name] = attribute.value;
      }
      return result;
    }
    function formatTagName(tagName2) {
      tagName2 = tagName2.toLowerCase();
      var caseSensitiveTagName = getCaseSensitiveTagName(tagName2);
      if (caseSensitiveTagName) {
        return caseSensitiveTagName;
      }
      return tagName2;
    }
    function formatDOM(nodes, parent, directive) {
      parent = parent || null;
      var result = [];
      for (var index = 0, len2 = nodes.length; index < len2; index++) {
        var node = nodes[index];
        var current;
        switch (node.nodeType) {
          case 1:
            current = new Element3(
              formatTagName(node.nodeName),
              formatAttributes2(node.attributes)
            );
            current.children = formatDOM(node.childNodes, current);
            break;
          case 3:
            current = new Text5(node.nodeValue);
            break;
          case 8:
            current = new Comment4(node.nodeValue);
            break;
          default:
            continue;
        }
        var prev = result[index - 1] || null;
        if (prev) {
          prev.next = current;
        }
        current.parent = parent;
        current.prev = prev;
        current.next = null;
        result.push(current);
      }
      if (directive) {
        current = new ProcessingInstruction3(
          directive.substring(0, directive.indexOf(" ")).toLowerCase(),
          directive
        );
        current.next = result[0] || null;
        current.parent = parent;
        result.unshift(current);
        if (result[1]) {
          result[1].prev = result[0];
        }
      }
      return result;
    }
    exports.formatAttributes = formatAttributes2;
    exports.formatDOM = formatDOM;
  }
});

// node_modules/html-dom-parser/lib/client/html-to-dom.js
var require_html_to_dom = __commonJS({
  "node_modules/html-dom-parser/lib/client/html-to-dom.js"(exports, module) {
    var domparser = require_domparser();
    var utilities = require_utilities();
    var formatDOM = utilities.formatDOM;
    var DIRECTIVE_REGEX = /<(![a-zA-Z\s]+)>/;
    function HTMLDOMParser(html) {
      if (typeof html !== "string") {
        throw new TypeError("First argument must be a string");
      }
      if (html === "") {
        return [];
      }
      var match = html.match(DIRECTIVE_REGEX);
      var directive;
      if (match && match[1]) {
        directive = match[1];
      }
      return formatDOM(domparser(html), null, directive);
    }
    module.exports = HTMLDOMParser;
  }
});

// node_modules/react-property/lib/possibleStandardNamesOptimized.js
var require_possibleStandardNamesOptimized = __commonJS({
  "node_modules/react-property/lib/possibleStandardNamesOptimized.js"(exports) {
    var SAME = 0;
    exports.SAME = SAME;
    var CAMELCASE = 1;
    exports.CAMELCASE = CAMELCASE;
    exports.possibleStandardNames = {
      accept: 0,
      acceptCharset: 1,
      "accept-charset": "acceptCharset",
      accessKey: 1,
      action: 0,
      allowFullScreen: 1,
      alt: 0,
      as: 0,
      async: 0,
      autoCapitalize: 1,
      autoComplete: 1,
      autoCorrect: 1,
      autoFocus: 1,
      autoPlay: 1,
      autoSave: 1,
      capture: 0,
      cellPadding: 1,
      cellSpacing: 1,
      challenge: 0,
      charSet: 1,
      checked: 0,
      children: 0,
      cite: 0,
      class: "className",
      classID: 1,
      className: 1,
      cols: 0,
      colSpan: 1,
      content: 0,
      contentEditable: 1,
      contextMenu: 1,
      controls: 0,
      controlsList: 1,
      coords: 0,
      crossOrigin: 1,
      dangerouslySetInnerHTML: 1,
      data: 0,
      dateTime: 1,
      default: 0,
      defaultChecked: 1,
      defaultValue: 1,
      defer: 0,
      dir: 0,
      disabled: 0,
      disablePictureInPicture: 1,
      disableRemotePlayback: 1,
      download: 0,
      draggable: 0,
      encType: 1,
      enterKeyHint: 1,
      for: "htmlFor",
      form: 0,
      formMethod: 1,
      formAction: 1,
      formEncType: 1,
      formNoValidate: 1,
      formTarget: 1,
      frameBorder: 1,
      headers: 0,
      height: 0,
      hidden: 0,
      high: 0,
      href: 0,
      hrefLang: 1,
      htmlFor: 1,
      httpEquiv: 1,
      "http-equiv": "httpEquiv",
      icon: 0,
      id: 0,
      innerHTML: 1,
      inputMode: 1,
      integrity: 0,
      is: 0,
      itemID: 1,
      itemProp: 1,
      itemRef: 1,
      itemScope: 1,
      itemType: 1,
      keyParams: 1,
      keyType: 1,
      kind: 0,
      label: 0,
      lang: 0,
      list: 0,
      loop: 0,
      low: 0,
      manifest: 0,
      marginWidth: 1,
      marginHeight: 1,
      max: 0,
      maxLength: 1,
      media: 0,
      mediaGroup: 1,
      method: 0,
      min: 0,
      minLength: 1,
      multiple: 0,
      muted: 0,
      name: 0,
      noModule: 1,
      nonce: 0,
      noValidate: 1,
      open: 0,
      optimum: 0,
      pattern: 0,
      placeholder: 0,
      playsInline: 1,
      poster: 0,
      preload: 0,
      profile: 0,
      radioGroup: 1,
      readOnly: 1,
      referrerPolicy: 1,
      rel: 0,
      required: 0,
      reversed: 0,
      role: 0,
      rows: 0,
      rowSpan: 1,
      sandbox: 0,
      scope: 0,
      scoped: 0,
      scrolling: 0,
      seamless: 0,
      selected: 0,
      shape: 0,
      size: 0,
      sizes: 0,
      span: 0,
      spellCheck: 1,
      src: 0,
      srcDoc: 1,
      srcLang: 1,
      srcSet: 1,
      start: 0,
      step: 0,
      style: 0,
      summary: 0,
      tabIndex: 1,
      target: 0,
      title: 0,
      type: 0,
      useMap: 1,
      value: 0,
      width: 0,
      wmode: 0,
      wrap: 0,
      about: 0,
      accentHeight: 1,
      "accent-height": "accentHeight",
      accumulate: 0,
      additive: 0,
      alignmentBaseline: 1,
      "alignment-baseline": "alignmentBaseline",
      allowReorder: 1,
      alphabetic: 0,
      amplitude: 0,
      arabicForm: 1,
      "arabic-form": "arabicForm",
      ascent: 0,
      attributeName: 1,
      attributeType: 1,
      autoReverse: 1,
      azimuth: 0,
      baseFrequency: 1,
      baselineShift: 1,
      "baseline-shift": "baselineShift",
      baseProfile: 1,
      bbox: 0,
      begin: 0,
      bias: 0,
      by: 0,
      calcMode: 1,
      capHeight: 1,
      "cap-height": "capHeight",
      clip: 0,
      clipPath: 1,
      "clip-path": "clipPath",
      clipPathUnits: 1,
      clipRule: 1,
      "clip-rule": "clipRule",
      color: 0,
      colorInterpolation: 1,
      "color-interpolation": "colorInterpolation",
      colorInterpolationFilters: 1,
      "color-interpolation-filters": "colorInterpolationFilters",
      colorProfile: 1,
      "color-profile": "colorProfile",
      colorRendering: 1,
      "color-rendering": "colorRendering",
      contentScriptType: 1,
      contentStyleType: 1,
      cursor: 0,
      cx: 0,
      cy: 0,
      d: 0,
      datatype: 0,
      decelerate: 0,
      descent: 0,
      diffuseConstant: 1,
      direction: 0,
      display: 0,
      divisor: 0,
      dominantBaseline: 1,
      "dominant-baseline": "dominantBaseline",
      dur: 0,
      dx: 0,
      dy: 0,
      edgeMode: 1,
      elevation: 0,
      enableBackground: 1,
      "enable-background": "enableBackground",
      end: 0,
      exponent: 0,
      externalResourcesRequired: 1,
      fill: 0,
      fillOpacity: 1,
      "fill-opacity": "fillOpacity",
      fillRule: 1,
      "fill-rule": "fillRule",
      filter: 0,
      filterRes: 1,
      filterUnits: 1,
      floodOpacity: 1,
      "flood-opacity": "floodOpacity",
      floodColor: 1,
      "flood-color": "floodColor",
      focusable: 0,
      fontFamily: 1,
      "font-family": "fontFamily",
      fontSize: 1,
      "font-size": "fontSize",
      fontSizeAdjust: 1,
      "font-size-adjust": "fontSizeAdjust",
      fontStretch: 1,
      "font-stretch": "fontStretch",
      fontStyle: 1,
      "font-style": "fontStyle",
      fontVariant: 1,
      "font-variant": "fontVariant",
      fontWeight: 1,
      "font-weight": "fontWeight",
      format: 0,
      from: 0,
      fx: 0,
      fy: 0,
      g1: 0,
      g2: 0,
      glyphName: 1,
      "glyph-name": "glyphName",
      glyphOrientationHorizontal: 1,
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphOrientationVertical: 1,
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphRef: 1,
      gradientTransform: 1,
      gradientUnits: 1,
      hanging: 0,
      horizAdvX: 1,
      "horiz-adv-x": "horizAdvX",
      horizOriginX: 1,
      "horiz-origin-x": "horizOriginX",
      ideographic: 0,
      imageRendering: 1,
      "image-rendering": "imageRendering",
      in2: 0,
      in: 0,
      inlist: 0,
      intercept: 0,
      k1: 0,
      k2: 0,
      k3: 0,
      k4: 0,
      k: 0,
      kernelMatrix: 1,
      kernelUnitLength: 1,
      kerning: 0,
      keyPoints: 1,
      keySplines: 1,
      keyTimes: 1,
      lengthAdjust: 1,
      letterSpacing: 1,
      "letter-spacing": "letterSpacing",
      lightingColor: 1,
      "lighting-color": "lightingColor",
      limitingConeAngle: 1,
      local: 0,
      markerEnd: 1,
      "marker-end": "markerEnd",
      markerHeight: 1,
      markerMid: 1,
      "marker-mid": "markerMid",
      markerStart: 1,
      "marker-start": "markerStart",
      markerUnits: 1,
      markerWidth: 1,
      mask: 0,
      maskContentUnits: 1,
      maskUnits: 1,
      mathematical: 0,
      mode: 0,
      numOctaves: 1,
      offset: 0,
      opacity: 0,
      operator: 0,
      order: 0,
      orient: 0,
      orientation: 0,
      origin: 0,
      overflow: 0,
      overlinePosition: 1,
      "overline-position": "overlinePosition",
      overlineThickness: 1,
      "overline-thickness": "overlineThickness",
      paintOrder: 1,
      "paint-order": "paintOrder",
      panose1: 0,
      "panose-1": "panose1",
      pathLength: 1,
      patternContentUnits: 1,
      patternTransform: 1,
      patternUnits: 1,
      pointerEvents: 1,
      "pointer-events": "pointerEvents",
      points: 0,
      pointsAtX: 1,
      pointsAtY: 1,
      pointsAtZ: 1,
      prefix: 0,
      preserveAlpha: 1,
      preserveAspectRatio: 1,
      primitiveUnits: 1,
      property: 0,
      r: 0,
      radius: 0,
      refX: 1,
      refY: 1,
      renderingIntent: 1,
      "rendering-intent": "renderingIntent",
      repeatCount: 1,
      repeatDur: 1,
      requiredExtensions: 1,
      requiredFeatures: 1,
      resource: 0,
      restart: 0,
      result: 0,
      results: 0,
      rotate: 0,
      rx: 0,
      ry: 0,
      scale: 0,
      security: 0,
      seed: 0,
      shapeRendering: 1,
      "shape-rendering": "shapeRendering",
      slope: 0,
      spacing: 0,
      specularConstant: 1,
      specularExponent: 1,
      speed: 0,
      spreadMethod: 1,
      startOffset: 1,
      stdDeviation: 1,
      stemh: 0,
      stemv: 0,
      stitchTiles: 1,
      stopColor: 1,
      "stop-color": "stopColor",
      stopOpacity: 1,
      "stop-opacity": "stopOpacity",
      strikethroughPosition: 1,
      "strikethrough-position": "strikethroughPosition",
      strikethroughThickness: 1,
      "strikethrough-thickness": "strikethroughThickness",
      string: 0,
      stroke: 0,
      strokeDasharray: 1,
      "stroke-dasharray": "strokeDasharray",
      strokeDashoffset: 1,
      "stroke-dashoffset": "strokeDashoffset",
      strokeLinecap: 1,
      "stroke-linecap": "strokeLinecap",
      strokeLinejoin: 1,
      "stroke-linejoin": "strokeLinejoin",
      strokeMiterlimit: 1,
      "stroke-miterlimit": "strokeMiterlimit",
      strokeWidth: 1,
      "stroke-width": "strokeWidth",
      strokeOpacity: 1,
      "stroke-opacity": "strokeOpacity",
      suppressContentEditableWarning: 1,
      suppressHydrationWarning: 1,
      surfaceScale: 1,
      systemLanguage: 1,
      tableValues: 1,
      targetX: 1,
      targetY: 1,
      textAnchor: 1,
      "text-anchor": "textAnchor",
      textDecoration: 1,
      "text-decoration": "textDecoration",
      textLength: 1,
      textRendering: 1,
      "text-rendering": "textRendering",
      to: 0,
      transform: 0,
      typeof: 0,
      u1: 0,
      u2: 0,
      underlinePosition: 1,
      "underline-position": "underlinePosition",
      underlineThickness: 1,
      "underline-thickness": "underlineThickness",
      unicode: 0,
      unicodeBidi: 1,
      "unicode-bidi": "unicodeBidi",
      unicodeRange: 1,
      "unicode-range": "unicodeRange",
      unitsPerEm: 1,
      "units-per-em": "unitsPerEm",
      unselectable: 0,
      vAlphabetic: 1,
      "v-alphabetic": "vAlphabetic",
      values: 0,
      vectorEffect: 1,
      "vector-effect": "vectorEffect",
      version: 0,
      vertAdvY: 1,
      "vert-adv-y": "vertAdvY",
      vertOriginX: 1,
      "vert-origin-x": "vertOriginX",
      vertOriginY: 1,
      "vert-origin-y": "vertOriginY",
      vHanging: 1,
      "v-hanging": "vHanging",
      vIdeographic: 1,
      "v-ideographic": "vIdeographic",
      viewBox: 1,
      viewTarget: 1,
      visibility: 0,
      vMathematical: 1,
      "v-mathematical": "vMathematical",
      vocab: 0,
      widths: 0,
      wordSpacing: 1,
      "word-spacing": "wordSpacing",
      writingMode: 1,
      "writing-mode": "writingMode",
      x1: 0,
      x2: 0,
      x: 0,
      xChannelSelector: 1,
      xHeight: 1,
      "x-height": "xHeight",
      xlinkActuate: 1,
      "xlink:actuate": "xlinkActuate",
      xlinkArcrole: 1,
      "xlink:arcrole": "xlinkArcrole",
      xlinkHref: 1,
      "xlink:href": "xlinkHref",
      xlinkRole: 1,
      "xlink:role": "xlinkRole",
      xlinkShow: 1,
      "xlink:show": "xlinkShow",
      xlinkTitle: 1,
      "xlink:title": "xlinkTitle",
      xlinkType: 1,
      "xlink:type": "xlinkType",
      xmlBase: 1,
      "xml:base": "xmlBase",
      xmlLang: 1,
      "xml:lang": "xmlLang",
      xmlns: 0,
      "xml:space": "xmlSpace",
      xmlnsXlink: 1,
      "xmlns:xlink": "xmlnsXlink",
      xmlSpace: 1,
      y1: 0,
      y2: 0,
      y: 0,
      yChannelSelector: 1,
      z: 0,
      zoomAndPan: 1
    };
  }
});

// node_modules/react-property/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/react-property/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i2 == null)
        return;
      var _arr = [];
      var _n2 = true;
      var _d = false;
      var _s2, _e2;
      try {
        for (_i2 = _i2.call(arr); !(_n2 = (_s2 = _i2.next()).done); _n2 = true) {
          _arr.push(_s2.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e2 = err;
      } finally {
        try {
          if (!_n2 && _i2["return"] != null)
            _i2["return"]();
        } finally {
          if (_d)
            throw _e2;
        }
      }
      return _arr;
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n = Object.prototype.toString.call(o2).slice(8, -1);
      if (n === "Object" && o2.constructor)
        n = o2.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o2);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var RESERVED = 0;
    var STRING = 1;
    var BOOLEANISH_STRING = 2;
    var BOOLEAN = 3;
    var OVERLOADED_BOOLEAN = 4;
    var NUMERIC = 5;
    var POSITIVE_NUMERIC = 6;
    function getPropertyInfo(name) {
      return properties.hasOwnProperty(name) ? properties[name] : null;
    }
    function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
      this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
      this.attributeName = attributeName;
      this.attributeNamespace = attributeNamespace;
      this.mustUseProperty = mustUseProperty;
      this.propertyName = name;
      this.type = type;
      this.sanitizeURL = sanitizeURL;
      this.removeEmptyString = removeEmptyString;
    }
    var properties = {};
    var reservedProps = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    reservedProps.forEach(function(name) {
      properties[name] = new PropertyInfoRecord(
        name,
        RESERVED,
        false,
        // mustUseProperty
        name,
        // attributeName
        null,
        // attributeNamespace
        false,
        // sanitizeURL
        false
      );
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), name = _ref2[0], attributeName = _ref2[1];
      properties[name] = new PropertyInfoRecord(
        name,
        STRING,
        false,
        // mustUseProperty
        attributeName,
        // attributeName
        null,
        // attributeNamespace
        false,
        // sanitizeURL
        false
      );
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
      properties[name] = new PropertyInfoRecord(
        name,
        BOOLEANISH_STRING,
        false,
        // mustUseProperty
        name.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        false,
        // sanitizeURL
        false
      );
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
      properties[name] = new PropertyInfoRecord(
        name,
        BOOLEANISH_STRING,
        false,
        // mustUseProperty
        name,
        // attributeName
        null,
        // attributeNamespace
        false,
        // sanitizeURL
        false
      );
    });
    [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(name) {
      properties[name] = new PropertyInfoRecord(
        name,
        BOOLEAN,
        false,
        // mustUseProperty
        name.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        false,
        // sanitizeURL
        false
      );
    });
    [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(name) {
      properties[name] = new PropertyInfoRecord(
        name,
        BOOLEAN,
        true,
        // mustUseProperty
        name,
        // attributeName
        null,
        // attributeNamespace
        false,
        // sanitizeURL
        false
      );
    });
    [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(name) {
      properties[name] = new PropertyInfoRecord(
        name,
        OVERLOADED_BOOLEAN,
        false,
        // mustUseProperty
        name,
        // attributeName
        null,
        // attributeNamespace
        false,
        // sanitizeURL
        false
      );
    });
    [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(name) {
      properties[name] = new PropertyInfoRecord(
        name,
        POSITIVE_NUMERIC,
        false,
        // mustUseProperty
        name,
        // attributeName
        null,
        // attributeNamespace
        false,
        // sanitizeURL
        false
      );
    });
    ["rowSpan", "start"].forEach(function(name) {
      properties[name] = new PropertyInfoRecord(
        name,
        NUMERIC,
        false,
        // mustUseProperty
        name.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        false,
        // sanitizeURL
        false
      );
    });
    var CAMELIZE = /[\-\:]([a-z])/g;
    var capitalize = function capitalize2(token2) {
      return token2[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(attributeName) {
      var name = attributeName.replace(CAMELIZE, capitalize);
      properties[name] = new PropertyInfoRecord(
        name,
        STRING,
        false,
        // mustUseProperty
        attributeName,
        null,
        // attributeNamespace
        false,
        // sanitizeURL
        false
      );
    });
    [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(attributeName) {
      var name = attributeName.replace(CAMELIZE, capitalize);
      properties[name] = new PropertyInfoRecord(
        name,
        STRING,
        false,
        // mustUseProperty
        attributeName,
        "http://www.w3.org/1999/xlink",
        false,
        // sanitizeURL
        false
      );
    });
    [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(attributeName) {
      var name = attributeName.replace(CAMELIZE, capitalize);
      properties[name] = new PropertyInfoRecord(
        name,
        STRING,
        false,
        // mustUseProperty
        attributeName,
        "http://www.w3.org/XML/1998/namespace",
        false,
        // sanitizeURL
        false
      );
    });
    ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
      properties[attributeName] = new PropertyInfoRecord(
        attributeName,
        STRING,
        false,
        // mustUseProperty
        attributeName.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        false,
        // sanitizeURL
        false
      );
    });
    var xlinkHref = "xlinkHref";
    properties[xlinkHref] = new PropertyInfoRecord(
      "xlinkHref",
      STRING,
      false,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      true,
      // sanitizeURL
      false
    );
    ["src", "href", "action", "formAction"].forEach(function(attributeName) {
      properties[attributeName] = new PropertyInfoRecord(
        attributeName,
        STRING,
        false,
        // mustUseProperty
        attributeName.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        true,
        // sanitizeURL
        true
      );
    });
    var _require = require_possibleStandardNamesOptimized();
    var CAMELCASE = _require.CAMELCASE;
    var SAME = _require.SAME;
    var possibleStandardNamesOptimized = _require.possibleStandardNames;
    var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var isCustomAttribute = RegExp.prototype.test.bind(
      // eslint-disable-next-line no-misleading-character-class
      new RegExp("^(data|aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$")
    );
    var possibleStandardNames = Object.keys(possibleStandardNamesOptimized).reduce(function(accumulator, standardName) {
      var propName = possibleStandardNamesOptimized[standardName];
      if (propName === SAME) {
        accumulator[standardName] = standardName;
      } else if (propName === CAMELCASE) {
        accumulator[standardName.toLowerCase()] = standardName;
      } else {
        accumulator[standardName] = propName;
      }
      return accumulator;
    }, {});
    exports.BOOLEAN = BOOLEAN;
    exports.BOOLEANISH_STRING = BOOLEANISH_STRING;
    exports.NUMERIC = NUMERIC;
    exports.OVERLOADED_BOOLEAN = OVERLOADED_BOOLEAN;
    exports.POSITIVE_NUMERIC = POSITIVE_NUMERIC;
    exports.RESERVED = RESERVED;
    exports.STRING = STRING;
    exports.getPropertyInfo = getPropertyInfo;
    exports.isCustomAttribute = isCustomAttribute;
    exports.possibleStandardNames = possibleStandardNames;
  }
});

// node_modules/inline-style-parser/index.js
var require_inline_style_parser = __commonJS({
  "node_modules/inline-style-parser/index.js"(exports, module) {
    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
    var NEWLINE_REGEX = /\n/g;
    var WHITESPACE_REGEX = /^\s*/;
    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
    var COLON_REGEX = /^:\s*/;
    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
    var SEMICOLON_REGEX = /^[;\s]*/;
    var TRIM_REGEX = /^\s+|\s+$/g;
    var NEWLINE = "\n";
    var FORWARD_SLASH = "/";
    var ASTERISK = "*";
    var EMPTY_STRING = "";
    var TYPE_COMMENT = "comment";
    var TYPE_DECLARATION = "declaration";
    module.exports = function(style, options) {
      if (typeof style !== "string") {
        throw new TypeError("First argument must be a string");
      }
      if (!style)
        return [];
      options = options || {};
      var lineno = 1;
      var column = 1;
      function updatePosition(str) {
        var lines = str.match(NEWLINE_REGEX);
        if (lines)
          lineno += lines.length;
        var i = str.lastIndexOf(NEWLINE);
        column = ~i ? str.length - i : column + str.length;
      }
      function position() {
        var start = { line: lineno, column };
        return function(node) {
          node.position = new Position(start);
          whitespace();
          return node;
        };
      }
      function Position(start) {
        this.start = start;
        this.end = { line: lineno, column };
        this.source = options.source;
      }
      Position.prototype.content = style;
      var errorsList = [];
      function error(msg) {
        var err = new Error(
          options.source + ":" + lineno + ":" + column + ": " + msg
        );
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = style;
        if (options.silent) {
          errorsList.push(err);
        } else {
          throw err;
        }
      }
      function match(re2) {
        var m = re2.exec(style);
        if (!m)
          return;
        var str = m[0];
        updatePosition(str);
        style = style.slice(str.length);
        return m;
      }
      function whitespace() {
        match(WHITESPACE_REGEX);
      }
      function comments(rules) {
        var c;
        rules = rules || [];
        while (c = comment()) {
          if (c !== false) {
            rules.push(c);
          }
        }
        return rules;
      }
      function comment() {
        var pos = position();
        if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1))
          return;
        var i = 2;
        while (EMPTY_STRING != style.charAt(i) && (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))) {
          ++i;
        }
        i += 2;
        if (EMPTY_STRING === style.charAt(i - 1)) {
          return error("End of comment missing");
        }
        var str = style.slice(2, i - 2);
        column += 2;
        updatePosition(str);
        style = style.slice(i);
        column += 2;
        return pos({
          type: TYPE_COMMENT,
          comment: str
        });
      }
      function declaration() {
        var pos = position();
        var prop = match(PROPERTY_REGEX);
        if (!prop)
          return;
        comment();
        if (!match(COLON_REGEX))
          return error("property missing ':'");
        var val = match(VALUE_REGEX);
        var ret = pos({
          type: TYPE_DECLARATION,
          property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
          value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
        });
        match(SEMICOLON_REGEX);
        return ret;
      }
      function declarations() {
        var decls = [];
        comments(decls);
        var decl;
        while (decl = declaration()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
        return decls;
      }
      whitespace();
      return declarations();
    };
    function trim(str) {
      return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
    }
  }
});

// node_modules/style-to-object/index.js
var require_style_to_object = __commonJS({
  "node_modules/style-to-object/index.js"(exports, module) {
    var parse = require_inline_style_parser();
    function StyleToObject(style, iterator) {
      var output = null;
      if (!style || typeof style !== "string") {
        return output;
      }
      var declaration;
      var declarations = parse(style);
      var hasIterator = typeof iterator === "function";
      var property;
      var value;
      for (var i = 0, len = declarations.length; i < len; i++) {
        declaration = declarations[i];
        property = declaration.property;
        value = declaration.value;
        if (hasIterator) {
          iterator(property, value, declaration);
        } else if (value) {
          output || (output = {});
          output[property] = value;
        }
      }
      return output;
    }
    module.exports = StyleToObject;
    module.exports.default = StyleToObject;
  }
});

// node_modules/style-to-js/cjs/utilities.js
var require_utilities2 = __commonJS({
  "node_modules/style-to-js/cjs/utilities.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.camelCase = void 0;
    var CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9-]+$/;
    var HYPHEN_REGEX = /-([a-z])/g;
    var NO_HYPHEN_REGEX = /^[^-]+$/;
    var VENDOR_PREFIX_REGEX = /^-(webkit|moz|ms|o|khtml)-/;
    var MS_VENDOR_PREFIX_REGEX = /^-(ms)-/;
    var skipCamelCase = function(property) {
      return !property || NO_HYPHEN_REGEX.test(property) || CUSTOM_PROPERTY_REGEX.test(property);
    };
    var capitalize = function(match, character) {
      return character.toUpperCase();
    };
    var trimHyphen = function(match, prefix) {
      return "".concat(prefix, "-");
    };
    var camelCase = function(property, options) {
      if (options === void 0) {
        options = {};
      }
      if (skipCamelCase(property)) {
        return property;
      }
      property = property.toLowerCase();
      if (options.reactCompat) {
        property = property.replace(MS_VENDOR_PREFIX_REGEX, trimHyphen);
      } else {
        property = property.replace(VENDOR_PREFIX_REGEX, trimHyphen);
      }
      return property.replace(HYPHEN_REGEX, capitalize);
    };
    exports.camelCase = camelCase;
  }
});

// node_modules/style-to-js/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/style-to-js/cjs/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    var style_to_object_1 = __importDefault(require_style_to_object());
    var utilities_1 = require_utilities2();
    function StyleToJS(style, options) {
      var output = {};
      if (!style || typeof style !== "string") {
        return output;
      }
      (0, style_to_object_1["default"])(style, function(property, value) {
        if (property && value) {
          output[(0, utilities_1.camelCase)(property, options)] = value;
        }
      });
      return output;
    }
    exports["default"] = StyleToJS;
  }
});

// node_modules/html-react-parser/lib/utilities.js
var require_utilities3 = __commonJS({
  "node_modules/html-react-parser/lib/utilities.js"(exports, module) {
    var React15 = require_react();
    var styleToJS = require_cjs2().default;
    function invertObject(obj, override) {
      if (!obj || typeof obj !== "object") {
        throw new TypeError("First argument must be an object");
      }
      var key;
      var value;
      var isOverridePresent = typeof override === "function";
      var overrides = {};
      var result = {};
      for (key in obj) {
        value = obj[key];
        if (isOverridePresent) {
          overrides = override(key, value);
          if (overrides && overrides.length === 2) {
            result[overrides[0]] = overrides[1];
            continue;
          }
        }
        if (typeof value === "string") {
          result[value] = key;
        }
      }
      return result;
    }
    function isCustomComponent(tagName, props) {
      if (tagName.indexOf("-") === -1) {
        return props && typeof props.is === "string";
      }
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var styleToJSOptions = { reactCompat: true };
    function setStyleProp(style, props) {
      if (style === null || style === void 0) {
        return;
      }
      try {
        props.style = styleToJS(style, styleToJSOptions);
      } catch (err) {
        props.style = {};
      }
    }
    var PRESERVE_CUSTOM_ATTRIBUTES = React15.version.split(".")[0] >= 16;
    var elementsWithNoTextChildren = /* @__PURE__ */ new Set([
      "tr",
      "tbody",
      "thead",
      "tfoot",
      "colgroup",
      "table",
      "head",
      "html",
      "frameset"
    ]);
    function canTextBeChildOfNode(node) {
      return !elementsWithNoTextChildren.has(node.name);
    }
    module.exports = {
      PRESERVE_CUSTOM_ATTRIBUTES,
      invertObject,
      isCustomComponent,
      setStyleProp,
      canTextBeChildOfNode,
      elementsWithNoTextChildren
    };
  }
});

// node_modules/html-react-parser/lib/attributes-to-props.js
var require_attributes_to_props = __commonJS({
  "node_modules/html-react-parser/lib/attributes-to-props.js"(exports, module) {
    var reactProperty = require_lib4();
    var utilities = require_utilities3();
    module.exports = function attributesToProps2(attributes, nodeName) {
      attributes = attributes || {};
      var valueOnlyInputs = {
        reset: true,
        submit: true
      };
      var attributeName;
      var attributeNameLowerCased;
      var attributeValue;
      var propName;
      var propertyInfo;
      var props = {};
      var inputIsValueOnly = attributes.type && valueOnlyInputs[attributes.type];
      for (attributeName in attributes) {
        attributeValue = attributes[attributeName];
        if (reactProperty.isCustomAttribute(attributeName)) {
          props[attributeName] = attributeValue;
          continue;
        }
        attributeNameLowerCased = attributeName.toLowerCase();
        propName = getPropName(attributeNameLowerCased);
        if (propName) {
          propertyInfo = reactProperty.getPropertyInfo(propName);
          if ((propName === "checked" || propName === "value") && nodeName !== "option" && !inputIsValueOnly) {
            propName = getPropName("default" + attributeNameLowerCased);
          }
          props[propName] = attributeValue;
          switch (propertyInfo && propertyInfo.type) {
            case reactProperty.BOOLEAN:
              props[propName] = true;
              break;
            case reactProperty.OVERLOADED_BOOLEAN:
              if (attributeValue === "") {
                props[propName] = true;
              }
              break;
          }
          continue;
        }
        if (utilities.PRESERVE_CUSTOM_ATTRIBUTES) {
          props[attributeName] = attributeValue;
        }
      }
      utilities.setStyleProp(attributes.style, props);
      return props;
    };
    function getPropName(attributeName) {
      return reactProperty.possibleStandardNames[attributeName];
    }
  }
});

// node_modules/html-react-parser/lib/dom-to-react.js
var require_dom_to_react = __commonJS({
  "node_modules/html-react-parser/lib/dom-to-react.js"(exports, module) {
    var React15 = require_react();
    var attributesToProps2 = require_attributes_to_props();
    var utilities = require_utilities3();
    var setStyleProp = utilities.setStyleProp;
    var canTextBeChildOfNode = utilities.canTextBeChildOfNode;
    function domToReact2(nodes, options) {
      options = options || {};
      var library = options.library || React15;
      var cloneElement = library.cloneElement;
      var createElement = library.createElement;
      var isValidElement2 = library.isValidElement;
      var result = [];
      var node;
      var isWhitespace2;
      var hasReplace = typeof options.replace === "function";
      var replaceElement2;
      var props;
      var children;
      var trim = options.trim;
      for (var i = 0, len = nodes.length; i < len; i++) {
        node = nodes[i];
        if (hasReplace) {
          replaceElement2 = options.replace(node);
          if (isValidElement2(replaceElement2)) {
            if (len > 1) {
              replaceElement2 = cloneElement(replaceElement2, {
                key: replaceElement2.key || i
              });
            }
            result.push(replaceElement2);
            continue;
          }
        }
        if (node.type === "text") {
          isWhitespace2 = !node.data.trim().length;
          if (isWhitespace2 && node.parent && !canTextBeChildOfNode(node.parent)) {
            continue;
          }
          if (trim && isWhitespace2) {
            continue;
          }
          result.push(node.data);
          continue;
        }
        props = node.attribs;
        if (skipAttributesToProps(node)) {
          setStyleProp(props.style, props);
        } else if (props) {
          props = attributesToProps2(props, node.name);
        }
        children = null;
        switch (node.type) {
          case "script":
          case "style":
            if (node.children[0]) {
              props.dangerouslySetInnerHTML = {
                __html: node.children[0].data
              };
            }
            break;
          case "tag":
            if (node.name === "textarea" && node.children[0]) {
              props.defaultValue = node.children[0].data;
            } else if (node.children && node.children.length) {
              children = domToReact2(node.children, options);
            }
            break;
          default:
            continue;
        }
        if (len > 1) {
          props.key = i;
        }
        result.push(createElement(node.name, props, children));
      }
      return result.length === 1 ? result[0] : result;
    }
    function skipAttributesToProps(node) {
      return utilities.PRESERVE_CUSTOM_ATTRIBUTES && node.type === "tag" && utilities.isCustomComponent(node.name, node.attribs);
    }
    module.exports = domToReact2;
  }
});

// node_modules/html-react-parser/index.js
var require_html_react_parser = __commonJS({
  "node_modules/html-react-parser/index.js"(exports, module) {
    var domhandler = require_lib2();
    var htmlToDOM2 = require_html_to_dom();
    var attributesToProps2 = require_attributes_to_props();
    var domToReact2 = require_dom_to_react();
    htmlToDOM2 = /* istanbul ignore next */
    typeof htmlToDOM2.default === "function" ? htmlToDOM2.default : htmlToDOM2;
    var domParserOptions = { lowerCaseAttributeNames: false };
    function HTMLReactParser2(html, options) {
      if (typeof html !== "string") {
        throw new TypeError("First argument must be a string");
      }
      if (html === "") {
        return [];
      }
      options = options || {};
      return domToReact2(
        htmlToDOM2(html, options.htmlparser2 || domParserOptions),
        options
      );
    }
    HTMLReactParser2.domToReact = domToReact2;
    HTMLReactParser2.htmlToDOM = htmlToDOM2;
    HTMLReactParser2.attributesToProps = attributesToProps2;
    HTMLReactParser2.Comment = domhandler.Comment;
    HTMLReactParser2.Element = domhandler.Element;
    HTMLReactParser2.ProcessingInstruction = domhandler.ProcessingInstruction;
    HTMLReactParser2.Text = domhandler.Text;
    module.exports = HTMLReactParser2;
    HTMLReactParser2.default = HTMLReactParser2;
  }
});

// node_modules/@react-email/body/dist/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var Body = ({
  children,
  style,
  ...props
}) => {
  const styleDefault = {
    wordSpacing: "normal",
    ...style
  };
  return (0, import_jsx_runtime.jsx)("body", { ...props, "data-id": "__react-email-body", style, children });
};
Body.displayName = "Body";

// node_modules/@react-email/button/dist/index.mjs
var React = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var pxToPt = (px2) => isNaN(Number(px2)) ? null : parseInt(px2, 10) * 3 / 4;
var Button = React.forwardRef(
  ({ children, style, pX, pY, target = "_blank", ...props }, forwardedRef) => {
    const y = (pY || 0) * 2;
    const textRaise = pxToPt(y.toString());
    return (0, import_jsx_runtime2.jsxs)(
      "a",
      {
        ...props,
        ref: forwardedRef,
        "data-id": "react-email-button",
        target,
        style: buttonStyle({ ...style, pX, pY }),
        children: [
          (0, import_jsx_runtime2.jsx)(
            "span",
            {
              dangerouslySetInnerHTML: {
                __html: `<!--[if mso]><i style="letter-spacing: ${pX}px;mso-font-width:-100%;mso-text-raise:${textRaise}" hidden>&nbsp;</i><![endif]-->`
              }
            }
          ),
          (0, import_jsx_runtime2.jsx)("span", { style: buttonTextStyle(pY), children }),
          (0, import_jsx_runtime2.jsx)(
            "span",
            {
              dangerouslySetInnerHTML: {
                __html: `<!--[if mso]><i style="letter-spacing: ${pX}px;mso-font-width:-100%" hidden>&nbsp;</i><![endif]-->`
              }
            }
          )
        ]
      }
    );
  }
);
Button.displayName = "Button";
var buttonStyle = (style) => {
  const { pY, pX, ...rest } = style || {};
  return {
    ...rest,
    lineHeight: "100%",
    textDecoration: "none",
    display: "inline-block",
    maxWidth: "100%",
    padding: `${pY}px ${pX}px`
  };
};
var buttonTextStyle = (pY) => {
  const paddingY = pY || 0;
  return {
    maxWidth: "100%",
    display: "inline-block",
    lineHeight: "120%",
    msoPaddingAlt: "0px",
    msoTextRaise: pxToPt(paddingY.toString())
  };
};

// node_modules/@react-email/column/dist/index.mjs
var React2 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var Column = React2.forwardRef(
  ({ children, style, ...props }, forwardedRef) => {
    return (0, import_jsx_runtime3.jsx)(
      "td",
      {
        ...props,
        ref: forwardedRef,
        "data-id": "__react-email-column",
        style,
        children
      }
    );
  }
);

// node_modules/@react-email/container/dist/index.mjs
var React3 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var Container = React3.forwardRef(({ children, style, ...props }, forwardedRef) => {
  return (0, import_jsx_runtime4.jsx)(
    "table",
    {
      align: "center",
      width: "100%",
      ...props,
      ref: forwardedRef,
      "data-id": "__react-email-container",
      role: "presentation",
      cellSpacing: "0",
      cellPadding: "0",
      border: 0,
      style: { maxWidth: "37.5em", ...style },
      children: (0, import_jsx_runtime4.jsx)("tbody", { children: (0, import_jsx_runtime4.jsx)("tr", { style: { width: "100%" }, children: (0, import_jsx_runtime4.jsx)("td", { children }) }) })
    }
  );
});
Container.displayName = "Container";

// node_modules/@react-email/font/dist/index.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var Font = ({
  fontFamily,
  fallbackFontFamily,
  webFont,
  fontStyle = "normal",
  fontWeight = 400
}) => {
  const src = webFont ? `src: url(${webFont.url}) format('${webFont.format}');` : "";
  const style = `
    @font-face {
      font-family: '${fontFamily}';
      font-style: ${fontStyle};
      font-weight: ${fontWeight};
      mso-font-alt: '${Array.isArray(fallbackFontFamily) ? fallbackFontFamily[0] : fallbackFontFamily}';
      ${src}
    }

    * {
      font-family: '${fontFamily}', ${Array.isArray(fallbackFontFamily) ? fallbackFontFamily.join(", ") : fallbackFontFamily};
    }
  `;
  return (0, import_jsx_runtime5.jsx)("style", { children: style });
};
Font.displayName = "Font";

// node_modules/@react-email/head/dist/index.mjs
var React4 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var Head = React4.forwardRef(
  ({ children, ...props }, forwardedRef) => (0, import_jsx_runtime6.jsxs)("head", { ...props, ref: forwardedRef, "data-id": "__react-email-head", children: [
    (0, import_jsx_runtime6.jsx)("meta", { httpEquiv: "Content-Type", content: "text/html; charset=UTF-8" }),
    children
  ] })
);
Head.displayName = "Head";

// node_modules/@radix-ui/react-slot/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/@radix-ui/react-slot/dist/index.module.js
var import_react2 = __toESM(require_react());

// node_modules/@radix-ui/react-compose-refs/dist/index.module.js
var import_react = __toESM(require_react());
function $6ed0406888f73fc4$var$setRef(ref, value) {
  if (typeof ref === "function")
    ref(value);
  else if (ref !== null && ref !== void 0)
    ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef(ref, node)
  );
}

// node_modules/@radix-ui/react-slot/dist/index.module.js
var $5e63c961fc1ce211$export$8c6ed5c666ac1360 = (0, import_react2.forwardRef)((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = import_react2.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (import_react2.Children.count(newElement) > 1)
          return import_react2.Children.only(null);
        return (0, import_react2.isValidElement)(newElement) ? newElement.props.children : null;
      } else
        return child;
    });
    return (0, import_react2.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
      ref: forwardedRef
    }), (0, import_react2.isValidElement)(newElement) ? (0, import_react2.cloneElement)(newElement, void 0, newChildren) : null);
  }
  return (0, import_react2.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
var $5e63c961fc1ce211$var$SlotClone = (0, import_react2.forwardRef)((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if ((0, import_react2.isValidElement)(children))
    return (0, import_react2.cloneElement)(children, {
      ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
      ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref)
    });
  return import_react2.Children.count(children) > 1 ? import_react2.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
var $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
  return (0, import_react2.createElement)(import_react2.Fragment, null, children);
};
function $5e63c961fc1ce211$var$isSlottable(child) {
  return (0, import_react2.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
}
function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler)
      overrideProps[propName] = (...args) => {
        childPropValue === null || childPropValue === void 0 || childPropValue(...args);
        slotPropValue === null || slotPropValue === void 0 || slotPropValue(...args);
      };
    else if (propName === "style")
      overrideProps[propName] = {
        ...slotPropValue,
        ...childPropValue
      };
    else if (propName === "className")
      overrideProps[propName] = [
        slotPropValue,
        childPropValue
      ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}

// node_modules/@react-email/heading/dist/index.mjs
var React5 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var withMargin = (props) => [
  withSpace(props.m, ["margin"]),
  withSpace(props.mx, ["marginLeft", "marginRight"]),
  withSpace(props.my, ["marginTop", "marginBottom"]),
  withSpace(props.mt, ["marginTop"]),
  withSpace(props.mr, ["marginRight"]),
  withSpace(props.mb, ["marginBottom"]),
  withSpace(props.ml, ["marginLeft"])
].filter((s) => Object.keys(s).length)[0];
var withSpace = (value, properties) => {
  return properties.reduce((styles, property) => {
    if (value) {
      return { ...styles, [property]: `${value}px` };
    }
    return styles;
  }, {});
};
var Heading = React5.forwardRef(
  ({ as: Tag2 = "h1", children, style, m, mx: mx2, my, mt: mt2, mr, mb, ml, ...props }, forwardedRef) => {
    return (0, import_jsx_runtime7.jsx)(
      $5e63c961fc1ce211$export$8c6ed5c666ac1360,
      {
        ...props,
        ref: forwardedRef,
        "data-id": "react-email-heading",
        style: { ...withMargin({ m, mx: mx2, my, mt: mt2, mr, mb, ml }), ...style },
        children: (0, import_jsx_runtime7.jsx)(Tag2, { children })
      }
    );
  }
);
Heading.displayName = "Heading";

// node_modules/@react-email/hr/dist/index.mjs
var React6 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var Hr = React6.forwardRef(
  ({ style, ...props }, forwardedRef) => (0, import_jsx_runtime8.jsx)(
    "hr",
    {
      ...props,
      ref: forwardedRef,
      "data-id": "react-email-hr",
      style: {
        width: "100%",
        border: "none",
        borderTop: "1px solid #eaeaea",
        ...style
      }
    }
  )
);
Hr.displayName = "Hr";

// node_modules/@react-email/html/dist/index.mjs
var React7 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var Html = React7.forwardRef(
  ({ children, lang = "en", ...props }, forwardedRef) => (0, import_jsx_runtime9.jsx)("html", { ref: forwardedRef, lang, ...props, children })
);
Html.displayName = "Html";

// node_modules/@react-email/img/dist/index.mjs
var React8 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var Img = React8.forwardRef(
  ({ alt, src, width, height, style, ...props }, forwardedRef) => (0, import_jsx_runtime10.jsx)(
    "img",
    {
      ...props,
      ref: forwardedRef,
      "data-id": "react-email-img",
      alt,
      src,
      width,
      height,
      style: {
        display: "block",
        outline: "none",
        border: "none",
        textDecoration: "none",
        ...style
      }
    }
  )
);
Img.displayName = "Img";

// node_modules/@react-email/link/dist/index.mjs
var React9 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var Link = React9.forwardRef(
  ({ target = "_blank", style, ...props }, forwardedRef) => (0, import_jsx_runtime11.jsx)(
    "a",
    {
      ...props,
      ref: forwardedRef,
      "data-id": "react-email-link",
      target,
      style: {
        color: "#067df7",
        textDecoration: "none",
        ...style
      }
    }
  )
);
Link.displayName = "Link";

// node_modules/@react-email/preview/dist/index.mjs
var React10 = __toESM(require_react(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var PREVIEW_MAX_LENGTH = 150;
var Preview = React10.forwardRef(
  ({ children = "", ...props }, forwardedRef) => {
    let text = Array.isArray(children) ? children.join("") : children;
    text = text.substr(0, PREVIEW_MAX_LENGTH);
    return (0, import_jsx_runtime12.jsxs)(
      "div",
      {
        ref: forwardedRef,
        id: "__react-email-preview",
        style: {
          display: "none",
          overflow: "hidden",
          lineHeight: "1px",
          opacity: 0,
          maxHeight: 0,
          maxWidth: 0
        },
        ...props,
        children: [
          text,
          renderWhiteSpace(text)
        ]
      }
    );
  }
);
var renderWhiteSpace = (text) => {
  if (text.length >= PREVIEW_MAX_LENGTH) {
    return null;
  }
  const whiteSpaceCodes = "\uFEFF";
  return (0, import_jsx_runtime12.jsx)("div", { children: whiteSpaceCodes.repeat(PREVIEW_MAX_LENGTH - text.length) });
};
Preview.displayName = "Preview";

// node_modules/@react-email/components/node_modules/@react-email/render/dist/index.mjs
var ReactDomServer = __toESM(require_server_browser(), 1);

// node_modules/@react-email/components/node_modules/domhandler/lib/esm/node.js
var Node = class {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
};
var DataNode = class extends Node {
  /**
   * @param data The content of the data node
   */
  constructor(data) {
    super();
    this.data = data;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data) {
    this.data = data;
  }
};
var Text2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
};
var Comment2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
};
var ProcessingInstruction = class extends DataNode {
  constructor(name, data) {
    super(data);
    this.name = name;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
};
var NodeWithChildren = class extends Node {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(children) {
    super();
    this.children = children;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var _a3;
    return (_a3 = this.children[0]) !== null && _a3 !== void 0 ? _a3 : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(children) {
    this.children = children;
  }
};
var CDATA2 = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
};
var Document = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
};
var Element = class extends NodeWithChildren {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(name, attribs, children = [], type = name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag) {
    super(children);
    this.name = name;
    this.attribs = attribs;
    this.type = type;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(name) {
    this.name = name;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name) => {
      var _a3, _b;
      return {
        name,
        value: this.attribs[name],
        namespace: (_a3 = this["x-attribsNamespace"]) === null || _a3 === void 0 ? void 0 : _a3[name],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
      };
    });
  }
};
function isTag2(node) {
  return isTag(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}
function cloneNode(node, recursive = false) {
  let result;
  if (isText(node)) {
    result = new Text2(node.data);
  } else if (isComment(node)) {
    result = new Comment2(node.data);
  } else if (isTag2(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Element(node.name, { ...node.attribs }, children);
    children.forEach((child) => child.parent = clone);
    if (node.namespace != null) {
      clone.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result = clone;
  } else if (isCDATA(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new CDATA2(children);
    children.forEach((child) => child.parent = clone);
    result = clone;
  } else if (isDocument(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Document(children);
    children.forEach((child) => child.parent = clone);
    if (node["x-mode"]) {
      clone["x-mode"] = node["x-mode"];
    }
    result = clone;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}

// node_modules/@react-email/components/node_modules/domhandler/lib/esm/index.js
var defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
var DomHandler = class {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = void 0;
    }
    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options !== null && options !== void 0 ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error) {
    this.handleCallback(error);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name, attribs) {
    const type = this.options.xmlMode ? ElementType.Tag : void 0;
    const element = new Element(name, attribs, void 0, type);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node = new Text2(data);
      this.addNode(node);
      this.lastNode = node;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node = new Comment2(data);
    this.addNode(node);
    this.lastNode = node;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text = new Text2("");
    const node = new CDATA2([text]);
    this.addNode(node);
    text.parent = node;
    this.lastNode = text;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name, data) {
    const node = new ProcessingInstruction(name, data);
    this.addNode(node);
  }
  handleCallback(error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  }
  addNode(node) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }
    parent.children.push(node);
    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }
    node.parent = parent;
    this.lastNode = null;
  }
};

// node_modules/@react-email/components/node_modules/peberminta/lib/core.mjs
function token(onToken, onEnd) {
  return (data, i) => {
    let position = i;
    let value = void 0;
    if (i < data.tokens.length) {
      value = onToken(data.tokens[i], data, i);
      if (value !== void 0) {
        position++;
      }
    } else {
      onEnd == null ? void 0 : onEnd(data, i);
    }
    return value === void 0 ? { matched: false } : {
      matched: true,
      position,
      value
    };
  };
}
function mapInner(r, f) {
  return r.matched ? {
    matched: true,
    position: r.position,
    value: f(r.value, r.position)
  } : r;
}
function mapOuter(r, f) {
  return r.matched ? f(r) : r;
}
function map(p, mapper) {
  return (data, i) => mapInner(p(data, i), (v, j) => mapper(v, data, i, j));
}
function option(p, def) {
  return (data, i) => {
    const r = p(data, i);
    return r.matched ? r : {
      matched: true,
      position: i,
      value: def
    };
  };
}
function choice(...ps) {
  return (data, i) => {
    for (const p of ps) {
      const result = p(data, i);
      if (result.matched) {
        return result;
      }
    }
    return { matched: false };
  };
}
function otherwise(pa2, pb) {
  return (data, i) => {
    const r1 = pa2(data, i);
    return r1.matched ? r1 : pb(data, i);
  };
}
function takeWhile(p, test) {
  return (data, i) => {
    const values = [];
    let success = true;
    do {
      const r = p(data, i);
      if (r.matched && test(r.value, values.length + 1, data, i, r.position)) {
        values.push(r.value);
        i = r.position;
      } else {
        success = false;
      }
    } while (success);
    return {
      matched: true,
      position: i,
      value: values
    };
  };
}
function many(p) {
  return takeWhile(p, () => true);
}
function many1(p) {
  return ab(p, many(p), (head, tail) => [head, ...tail]);
}
function ab(pa2, pb, join) {
  return (data, i) => mapOuter(pa2(data, i), (ma2) => mapInner(pb(data, ma2.position), (vb, j) => join(ma2.value, vb, data, i, j)));
}
function left(pa2, pb) {
  return ab(pa2, pb, (va2) => va2);
}
function right(pa2, pb) {
  return ab(pa2, pb, (va2, vb) => vb);
}
function abc(pa2, pb, pc2, join) {
  return (data, i) => mapOuter(pa2(data, i), (ma2) => mapOuter(pb(data, ma2.position), (mb) => mapInner(pc2(data, mb.position), (vc2, j) => join(ma2.value, mb.value, vc2, data, i, j))));
}
function middle(pa2, pb, pc2) {
  return abc(pa2, pb, pc2, (ra2, rb) => rb);
}
function all(...ps) {
  return (data, i) => {
    const result = [];
    let position = i;
    for (const p of ps) {
      const r1 = p(data, position);
      if (r1.matched) {
        result.push(r1.value);
        position = r1.position;
      } else {
        return { matched: false };
      }
    }
    return {
      matched: true,
      position,
      value: result
    };
  };
}
function flatten(...ps) {
  return flatten1(all(...ps));
}
function flatten1(p) {
  return map(p, (vs2) => vs2.flatMap((v) => v));
}
function chainReduce(acc, f) {
  return (data, i) => {
    let loop = true;
    let acc1 = acc;
    let pos = i;
    do {
      const r = f(acc1, data, pos)(data, pos);
      if (r.matched) {
        acc1 = r.value;
        pos = r.position;
      } else {
        loop = false;
      }
    } while (loop);
    return {
      matched: true,
      position: pos,
      value: acc1
    };
  };
}
function reduceLeft(acc, p, reducer) {
  return chainReduce(acc, (acc2) => map(p, (v, data, i, j) => reducer(acc2, v, data, i, j)));
}
function leftAssoc2(pLeft, pOper, pRight) {
  return chain(pLeft, (v02) => reduceLeft(v02, ab(pOper, pRight, (f, y) => [f, y]), (acc, [f, y]) => f(acc, y)));
}
function chain(p, f) {
  return (data, i) => mapOuter(p(data, i), (m1) => f(m1.value, data, i, m1.position)(data, m1.position));
}

// node_modules/@react-email/components/node_modules/parseley/lib/parseley.mjs
var ast = Object.freeze({
  __proto__: null
});
var lex = o([
  { name: "ws", regex: /[ \t\r\n\f]+/ },
  { name: "idn", regex: /[a-zA-Z_-][a-zA-Z0-9_-]*/ },
  { name: "#id", regex: /#[a-zA-Z0-9_-]+/ },
  { name: "str1", regex: /'(?:\\['\\]|[^\n'\\])*'/ },
  { name: "str2", regex: /"(?:\\["\\]|[^\n"\\])*"/ },
  { name: "*" },
  { name: "." },
  { name: "," },
  { name: "[" },
  { name: "]" },
  { name: "=" },
  { name: ">" },
  { name: "|" },
  { name: "+" },
  { name: "~" },
  { name: "^" },
  { name: "$" }
]);
function sumSpec([a02, a1, a2], [b02, b1, b2]) {
  return [a02 + b02, a1 + b1, a2 + b2];
}
function sumAllSpec(ss) {
  return ss.reduce(sumSpec, [0, 0, 0]);
}
function literal(name) {
  return token((t) => t.name === name ? true : void 0);
}
var whitespace_ = token((t) => t.name === "ws" ? null : void 0);
var optionalWhitespace_ = option(whitespace_, null);
function optionallySpaced(parser) {
  return middle(optionalWhitespace_, parser, optionalWhitespace_);
}
var identifier_ = token((t) => t.name === "idn" ? t.text : void 0);
var hashId_ = token((t) => t.name === "#id" ? t.text.slice(1) : void 0);
var string_ = token((t) => t.name.startsWith("str") ? t.text.slice(1, -1) : void 0);
var namespace_ = left(option(identifier_, ""), literal("|"));
var qualifiedName_ = otherwise(ab(namespace_, identifier_, (ns, name) => ({ name, namespace: ns })), map(identifier_, (name) => ({ name, namespace: null })));
var uniSelector_ = otherwise(ab(namespace_, literal("*"), (ns) => ({ type: "universal", namespace: ns, specificity: [0, 0, 0] })), map(literal("*"), () => ({ type: "universal", namespace: null, specificity: [0, 0, 0] })));
var tagSelector_ = map(qualifiedName_, ({ name, namespace }) => ({
  type: "tag",
  name,
  namespace,
  specificity: [0, 0, 1]
}));
var classSelector_ = ab(literal("."), identifier_, (fullstop, name) => ({
  type: "class",
  name,
  specificity: [0, 1, 0]
}));
var idSelector_ = map(hashId_, (name) => ({
  type: "id",
  name,
  specificity: [1, 0, 0]
}));
var attrModifier_ = token((t) => {
  if (t.name === "idn") {
    if (t.text === "i" || t.text === "I") {
      return "i";
    }
    if (t.text === "s" || t.text === "S") {
      return "s";
    }
  }
  return void 0;
});
var attrValue_ = otherwise(ab(string_, option(right(optionalWhitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })), ab(identifier_, option(right(whitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })));
var attrMatcher_ = choice(map(literal("="), () => "="), ab(literal("~"), literal("="), () => "~="), ab(literal("|"), literal("="), () => "|="), ab(literal("^"), literal("="), () => "^="), ab(literal("$"), literal("="), () => "$="), ab(literal("*"), literal("="), () => "*="));
var attrPresenceSelector_ = abc(literal("["), optionallySpaced(qualifiedName_), literal("]"), (lbr, { name, namespace }) => ({
  type: "attrPresence",
  name,
  namespace,
  specificity: [0, 1, 0]
}));
var attrValueSelector_ = middle(literal("["), abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name, namespace }, matcher, { value, modifier }) => ({
  type: "attrValue",
  name,
  namespace,
  matcher,
  value,
  modifier,
  specificity: [0, 1, 0]
})), literal("]"));
var attrSelector_ = otherwise(attrPresenceSelector_, attrValueSelector_);
var typeSelector_ = otherwise(uniSelector_, tagSelector_);
var subclassSelector_ = choice(idSelector_, classSelector_, attrSelector_);
var compoundSelector_ = map(otherwise(flatten(typeSelector_, many(subclassSelector_)), many1(subclassSelector_)), (ss) => {
  return {
    type: "compound",
    list: ss,
    specificity: sumAllSpec(ss.map((s) => s.specificity))
  };
});
var combinator_ = choice(map(literal(">"), () => ">"), map(literal("+"), () => "+"), map(literal("~"), () => "~"), ab(literal("|"), literal("|"), () => "||"));
var combinatorSeparator_ = otherwise(optionallySpaced(combinator_), map(whitespace_, () => " "));
var complexSelector_ = leftAssoc2(compoundSelector_, map(combinatorSeparator_, (c) => (left2, right2) => ({
  type: "compound",
  list: [...right2.list, { type: "combinator", combinator: c, left: left2, specificity: left2.specificity }],
  specificity: sumSpec(left2.specificity, right2.specificity)
})), compoundSelector_);
var listSelector_ = leftAssoc2(map(complexSelector_, (s) => ({ type: "list", list: [s] })), map(optionallySpaced(literal(",")), () => (acc, next) => ({ type: "list", list: [...acc.list, next] })), complexSelector_);
function parse_(parser, str) {
  const lexerResult = lex(str);
  if (!lexerResult.complete) {
    throw new Error(`The input "${str}" was only partially tokenized, stopped at offset ${lexerResult.offset}!
` + prettyPrintPosition(str, lexerResult.offset));
  }
  const result = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: void 0 }, 0);
  if (!result.matched) {
    throw new Error(`No match for "${str}" input!`);
  }
  if (result.position < lexerResult.tokens.length) {
    const token2 = lexerResult.tokens[result.position];
    throw new Error(`The input "${str}" was only partially parsed, stopped at offset ${token2.offset}!
` + prettyPrintPosition(str, token2.offset, token2.len));
  }
  return result.value;
}
function prettyPrintPosition(str, offset, len = 1) {
  return `${str.replace(/(\t)|(\r)|(\n)/g, (m, t, r) => t ? "" : r ? "" : "")}
${"".padEnd(offset)}${"^".repeat(len)}`;
}
function parse1(str) {
  return parse_(complexSelector_, str);
}
function serialize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "universal":
      return _serNs(selector.namespace) + "*";
    case "tag":
      return _serNs(selector.namespace) + selector.name;
    case "class":
      return "." + selector.name;
    case "id":
      return "#" + selector.name;
    case "attrPresence":
      return `[${_serNs(selector.namespace)}${selector.name}]`;
    case "attrValue":
      return `[${_serNs(selector.namespace)}${selector.name}${selector.matcher}${_serStr(selector.value)}${selector.modifier ? selector.modifier : ""}]`;
    case "combinator":
      return serialize(selector.left) + selector.combinator;
    case "compound":
      return selector.list.reduce((acc, node) => {
        if (node.type === "combinator") {
          return serialize(node) + acc;
        } else {
          return acc + serialize(node);
        }
      }, "");
    case "list":
      return selector.list.map(serialize).join(",");
  }
}
function _serNs(ns) {
  return ns || ns === "" ? ns + "|" : "";
}
function _serStr(str) {
  if (str.indexOf('"') === -1) {
    return `"${str}"`;
  } else if (str.indexOf("'") === -1) {
    return `'${str}'`;
  } else {
    return `"${str.replace('"', '\\"')}"`;
  }
}
function normalize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "compound": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));
      break;
    }
    case "combinator": {
      normalize(selector.left);
      break;
    }
    case "list": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b) => serialize(a) < serialize(b) ? -1 : 1);
      break;
    }
  }
  return selector;
}
function _getSelectorPriority(selector) {
  switch (selector.type) {
    case "universal":
      return [1];
    case "tag":
      return [1];
    case "id":
      return [2];
    case "class":
      return [3, selector.name];
    case "attrPresence":
      return [4, serialize(selector)];
    case "attrValue":
      return [5, serialize(selector)];
    case "combinator":
      return [15, serialize(selector)];
  }
}
function compareSpecificity(a, b) {
  return _compareArrays(a, b);
}
function _compareArrays(a, b) {
  if (!Array.isArray(a) || !Array.isArray(b)) {
    throw new Error("Arguments must be arrays.");
  }
  const shorter = a.length < b.length ? a.length : b.length;
  for (let i = 0; i < shorter; i++) {
    if (a[i] === b[i]) {
      continue;
    }
    return a[i] < b[i] ? -1 : 1;
  }
  return a.length - b.length;
}

// node_modules/@react-email/components/node_modules/selderee/lib/selderee.mjs
var Ast = Object.freeze({
  __proto__: null
});
var Types = Object.freeze({
  __proto__: null
});
var treeify = (nodes) => "\n" + treeifyArray(nodes, thinLines);
var thinLines = [["", " "], ["", "  "]];
var heavyLines = [["", " "], ["", "  "]];
var doubleLines = [["", " "], ["", "  "]];
function treeifyArray(nodes, tpl = heavyLines) {
  return prefixItems(tpl, nodes.map((n) => treeifyNode(n)));
}
function treeifyNode(node) {
  switch (node.type) {
    case "terminal": {
      const vctr = node.valueContainer;
      return ` #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;
    }
    case "tagName":
      return ` Tag name
${treeifyArray(node.variants, doubleLines)}`;
    case "attrValue":
      return ` Attr value: ${node.name}
${treeifyArray(node.matchers, doubleLines)}`;
    case "attrPresence":
      return ` Attr presence: ${node.name}
${treeifyArray(node.cont)}`;
    case "pushElement":
      return ` Push element: ${node.combinator}
${treeifyArray(node.cont, thinLines)}`;
    case "popElement":
      return ` Pop element
${treeifyArray(node.cont, thinLines)}`;
    case "variant":
      return ` = ${node.value}
${treeifyArray(node.cont)}`;
    case "matcher":
      return ` ${node.matcher} "${node.value}"${node.modifier || ""}
${treeifyArray(node.cont)}`;
  }
}
function prefixItems(tpl, items) {
  return items.map((item, i, { length }) => prefixItem(tpl, item, i === length - 1)).join("\n");
}
function prefixItem(tpl, item, tail = true) {
  const tpl1 = tpl[tail ? 1 : 0];
  return tpl1[0] + item.split("\n").join("\n" + tpl1[1]);
}
var TreeifyBuilder = Object.freeze({
  __proto__: null,
  treeify
});
var DecisionTree = class {
  constructor(input) {
    this.branches = weave(toAstTerminalPairs(input));
  }
  build(builder) {
    return builder(this.branches);
  }
};
function toAstTerminalPairs(array) {
  const len = array.length;
  const results = new Array(len);
  for (let i = 0; i < len; i++) {
    const [selectorString, val] = array[i];
    const ast2 = preprocess(parse1(selectorString));
    results[i] = {
      ast: ast2,
      terminal: {
        type: "terminal",
        valueContainer: { index: i, value: val, specificity: ast2.specificity }
      }
    };
  }
  return results;
}
function preprocess(ast2) {
  reduceSelectorVariants(ast2);
  normalize(ast2);
  return ast2;
}
function reduceSelectorVariants(ast2) {
  const newList = [];
  ast2.list.forEach((sel) => {
    switch (sel.type) {
      case "class":
        newList.push({
          matcher: "~=",
          modifier: null,
          name: "class",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "id":
        newList.push({
          matcher: "=",
          modifier: null,
          name: "id",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "combinator":
        reduceSelectorVariants(sel.left);
        newList.push(sel);
        break;
      case "universal":
        break;
      default:
        newList.push(sel);
        break;
    }
  });
  ast2.list = newList;
}
function weave(items) {
  const branches = [];
  while (items.length) {
    const topKind = findTopKey(items, (sel) => true, getSelectorKind);
    const { matches, nonmatches, empty } = breakByKind(items, topKind);
    items = nonmatches;
    if (matches.length) {
      branches.push(branchOfKind(topKind, matches));
    }
    if (empty.length) {
      branches.push(...terminate(empty));
    }
  }
  return branches;
}
function terminate(items) {
  const results = [];
  for (const item of items) {
    const terminal = item.terminal;
    if (terminal.type === "terminal") {
      results.push(terminal);
    } else {
      const { matches, rest } = partition(terminal.cont, (node) => node.type === "terminal");
      matches.forEach((node) => results.push(node));
      if (rest.length) {
        terminal.cont = rest;
        results.push(terminal);
      }
    }
  }
  return results;
}
function breakByKind(items, selectedKind) {
  const matches = [];
  const nonmatches = [];
  const empty = [];
  for (const item of items) {
    const simpsels = item.ast.list;
    if (simpsels.length) {
      const isMatch = simpsels.some((node) => getSelectorKind(node) === selectedKind);
      (isMatch ? matches : nonmatches).push(item);
    } else {
      empty.push(item);
    }
  }
  return { matches, nonmatches, empty };
}
function getSelectorKind(sel) {
  switch (sel.type) {
    case "attrPresence":
      return `attrPresence ${sel.name}`;
    case "attrValue":
      return `attrValue ${sel.name}`;
    case "combinator":
      return `combinator ${sel.combinator}`;
    default:
      return sel.type;
  }
}
function branchOfKind(kind, items) {
  if (kind === "tag") {
    return tagNameBranch(items);
  }
  if (kind.startsWith("attrValue ")) {
    return attrValueBranch(kind.substring(10), items);
  }
  if (kind.startsWith("attrPresence ")) {
    return attrPresenceBranch(kind.substring(13), items);
  }
  if (kind === "combinator >") {
    return combinatorBranch(">", items);
  }
  if (kind === "combinator +") {
    return combinatorBranch("+", items);
  }
  throw new Error(`Unsupported selector kind: ${kind}`);
}
function tagNameBranch(items) {
  const groups = spliceAndGroup(items, (x) => x.type === "tag", (x) => x.name);
  const variants = Object.entries(groups).map(([name, group]) => ({
    type: "variant",
    value: name,
    cont: weave(group.items)
  }));
  return {
    type: "tagName",
    variants
  };
}
function attrPresenceBranch(name, items) {
  for (const item of items) {
    spliceSimpleSelector(item, (x) => x.type === "attrPresence" && x.name === name);
  }
  return {
    type: "attrPresence",
    name,
    cont: weave(items)
  };
}
function attrValueBranch(name, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "attrValue" && x.name === name, (x) => `${x.matcher} ${x.modifier || ""} ${x.value}`);
  const matchers = [];
  for (const group of Object.values(groups)) {
    const sel = group.oneSimpleSelector;
    const predicate = getAttrPredicate(sel);
    const continuation = weave(group.items);
    matchers.push({
      type: "matcher",
      matcher: sel.matcher,
      modifier: sel.modifier,
      value: sel.value,
      predicate,
      cont: continuation
    });
  }
  return {
    type: "attrValue",
    name,
    matchers
  };
}
function getAttrPredicate(sel) {
  if (sel.modifier === "i") {
    const expected = sel.value.toLowerCase();
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual.toLowerCase();
      case "~=":
        return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.toLowerCase().startsWith(expected);
      case "$=":
        return (actual) => actual.toLowerCase().endsWith(expected);
      case "*=":
        return (actual) => actual.toLowerCase().includes(expected);
      case "|=":
        return (actual) => {
          const lower = actual.toLowerCase();
          return expected === lower || lower.startsWith(expected) && lower[expected.length] === "-";
        };
    }
  } else {
    const expected = sel.value;
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual;
      case "~=":
        return (actual) => actual.split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.startsWith(expected);
      case "$=":
        return (actual) => actual.endsWith(expected);
      case "*=":
        return (actual) => actual.includes(expected);
      case "|=":
        return (actual) => expected === actual || actual.startsWith(expected) && actual[expected.length] === "-";
    }
  }
}
function combinatorBranch(combinator, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "combinator" && x.combinator === combinator, (x) => serialize(x.left));
  const leftItems = [];
  for (const group of Object.values(groups)) {
    const rightCont = weave(group.items);
    const leftAst = group.oneSimpleSelector.left;
    leftItems.push({
      ast: leftAst,
      terminal: { type: "popElement", cont: rightCont }
    });
  }
  return {
    type: "pushElement",
    combinator,
    cont: weave(leftItems)
  };
}
function spliceAndGroup(items, predicate, keyCallback) {
  const groups = {};
  while (items.length) {
    const bestKey = findTopKey(items, predicate, keyCallback);
    const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
    const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
    const { matches, rest } = partition1(items, hasBestKeyPredicate);
    let oneSimpleSelector = null;
    for (const item of matches) {
      const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
      if (!oneSimpleSelector) {
        oneSimpleSelector = splicedNode;
      }
    }
    if (oneSimpleSelector == null) {
      throw new Error("No simple selector is found.");
    }
    groups[bestKey] = { oneSimpleSelector, items: matches };
    items = rest;
  }
  return groups;
}
function spliceSimpleSelector(item, predicate) {
  const simpsels = item.ast.list;
  const matches = new Array(simpsels.length);
  let firstIndex = -1;
  for (let i = simpsels.length; i-- > 0; ) {
    if (predicate(simpsels[i])) {
      matches[i] = true;
      firstIndex = i;
    }
  }
  if (firstIndex == -1) {
    throw new Error(`Couldn't find the required simple selector.`);
  }
  const result = simpsels[firstIndex];
  item.ast.list = simpsels.filter((sel, i) => !matches[i]);
  return result;
}
function findTopKey(items, predicate, keyCallback) {
  const candidates = {};
  for (const item of items) {
    const candidates1 = {};
    for (const node of item.ast.list.filter(predicate)) {
      candidates1[keyCallback(node)] = true;
    }
    for (const key of Object.keys(candidates1)) {
      if (candidates[key]) {
        candidates[key]++;
      } else {
        candidates[key] = 1;
      }
    }
  }
  let topKind = "";
  let topCounter = 0;
  for (const entry of Object.entries(candidates)) {
    if (entry[1] > topCounter) {
      topKind = entry[0];
      topCounter = entry[1];
    }
  }
  return topKind;
}
function partition(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest.push(x);
    }
  }
  return { matches, rest };
}
function partition1(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest.push(x);
    }
  }
  return { matches, rest };
}
var Picker = class {
  constructor(f) {
    this.f = f;
  }
  pickAll(el) {
    return this.f(el);
  }
  pick1(el, preferFirst = false) {
    const results = this.f(el);
    const len = results.length;
    if (len === 0) {
      return null;
    }
    if (len === 1) {
      return results[0].value;
    }
    const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;
    let result = results[0];
    for (let i = 1; i < len; i++) {
      const next = results[i];
      if (comparator(result, next)) {
        result = next;
      }
    }
    return result.value;
  }
};
function comparatorPreferFirst(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index < acc.index;
}
function comparatorPreferLast(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index > acc.index;
}

// node_modules/@react-email/components/node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.mjs
function hp2Builder(nodes) {
  return new Picker(handleArray(nodes));
}
function handleArray(nodes) {
  const matchers = nodes.map(handleNode);
  return (el, ...tail) => matchers.flatMap((m) => m(el, ...tail));
}
function handleNode(node) {
  switch (node.type) {
    case "terminal": {
      const result = [node.valueContainer];
      return (el, ...tail) => result;
    }
    case "tagName":
      return handleTagName(node);
    case "attrValue":
      return handleAttrValueName(node);
    case "attrPresence":
      return handleAttrPresenceName(node);
    case "pushElement":
      return handlePushElementNode(node);
    case "popElement":
      return handlePopElementNode(node);
  }
}
function handleTagName(node) {
  const variants = {};
  for (const variant of node.variants) {
    variants[variant.value] = handleArray(variant.cont);
  }
  return (el, ...tail) => {
    const continuation = variants[el.name];
    return continuation ? continuation(el, ...tail) : [];
  };
}
function handleAttrPresenceName(node) {
  const attrName = node.name;
  const continuation = handleArray(node.cont);
  return (el, ...tail) => Object.prototype.hasOwnProperty.call(el.attribs, attrName) ? continuation(el, ...tail) : [];
}
function handleAttrValueName(node) {
  const callbacks = [];
  for (const matcher of node.matchers) {
    const predicate = matcher.predicate;
    const continuation = handleArray(matcher.cont);
    callbacks.push((attr, el, ...tail) => predicate(attr) ? continuation(el, ...tail) : []);
  }
  const attrName = node.name;
  return (el, ...tail) => {
    const attr = el.attribs[attrName];
    return attr || attr === "" ? callbacks.flatMap((cb) => cb(attr, el, ...tail)) : [];
  };
}
function handlePushElementNode(node) {
  const continuation = handleArray(node.cont);
  const leftElementGetter = node.combinator === "+" ? getPrecedingElement : getParentElement;
  return (el, ...tail) => {
    const next = leftElementGetter(el);
    if (next === null) {
      return [];
    }
    return continuation(next, el, ...tail);
  };
}
var getPrecedingElement = (el) => {
  const prev = el.prev;
  if (prev === null) {
    return null;
  }
  return isTag2(prev) ? prev : getPrecedingElement(prev);
};
var getParentElement = (el) => {
  const parent = el.parent;
  return parent && isTag2(parent) ? parent : null;
};
function handlePopElementNode(node) {
  const continuation = handleArray(node.cont);
  return (el, next, ...tail) => continuation(next, ...tail);
}

// node_modules/@react-email/components/node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((c) => c.charCodeAt(0))
);

// node_modules/@react-email/components/node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((c) => c.charCodeAt(0))
);

// node_modules/@react-email/components/node_modules/entities/lib/esm/decode_codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a3;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a3 = decodeMap.get(codePoint)) !== null && _a3 !== void 0 ? _a3 : codePoint;
}

// node_modules/@react-email/components/node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes3) {
  CharCodes3[CharCodes3["NUM"] = 35] = "NUM";
  CharCodes3[CharCodes3["SEMI"] = 59] = "SEMI";
  CharCodes3[CharCodes3["EQUALS"] = 61] = "EQUALS";
  CharCodes3[CharCodes3["ZERO"] = 48] = "ZERO";
  CharCodes3[CharCodes3["NINE"] = 57] = "NINE";
  CharCodes3[CharCodes3["LOWER_A"] = 97] = "LOWER_A";
  CharCodes3[CharCodes3["LOWER_F"] = 102] = "LOWER_F";
  CharCodes3[CharCodes3["LOWER_X"] = 120] = "LOWER_X";
  CharCodes3[CharCodes3["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes3[CharCodes3["UPPER_A"] = 65] = "UPPER_A";
  CharCodes3[CharCodes3["UPPER_F"] = 70] = "UPPER_F";
  CharCodes3[CharCodes3["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a3;
    if (this.consumed <= expectedLength) {
      (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a3;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a3;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);

// node_modules/@react-email/components/node_modules/htmlparser2/lib/esm/Tokenizer.js
var CharCodes2;
(function(CharCodes3) {
  CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
  CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
  CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
  CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes3[CharCodes3["Space"] = 32] = "Space";
  CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes3[CharCodes3["Number"] = 35] = "Number";
  CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
  CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
  CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
  CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
  CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
  CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
  CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
  CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
  CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
  CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
  CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
  CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
  CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
  CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
  CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
  CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
  CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
  CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
  CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes2 || (CharCodes2 = {}));
var State;
(function(State2) {
  State2[State2["Text"] = 1] = "Text";
  State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
  State2[State2["InTagName"] = 3] = "InTagName";
  State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
  State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State2[State2["InAttributeName"] = 9] = "InAttributeName";
  State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
  State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State2[State2["InDeclaration"] = 16] = "InDeclaration";
  State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State2[State2["BeforeComment"] = 18] = "BeforeComment";
  State2[State2["CDATASequence"] = 19] = "CDATASequence";
  State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
  State2[State2["InCommentLike"] = 21] = "InCommentLike";
  State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
  State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
  State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
  State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
  State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
  State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
  State2[State2["InHexEntity"] = 29] = "InHexEntity";
})(State || (State = {}));
function isWhitespace(c) {
  return c === CharCodes2.Space || c === CharCodes2.NewLine || c === CharCodes2.Tab || c === CharCodes2.FormFeed || c === CharCodes2.CarriageReturn;
}
function isEndOfTagSection(c) {
  return c === CharCodes2.Slash || c === CharCodes2.Gt || isWhitespace(c);
}
function isNumber2(c) {
  return c >= CharCodes2.Zero && c <= CharCodes2.Nine;
}
function isASCIIAlpha(c) {
  return c >= CharCodes2.LowerA && c <= CharCodes2.LowerZ || c >= CharCodes2.UpperA && c <= CharCodes2.UpperZ;
}
function isHexDigit(c) {
  return c >= CharCodes2.UpperA && c <= CharCodes2.UpperF || c >= CharCodes2.LowerA && c <= CharCodes2.LowerF;
}
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
var Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  // `</title`
};
var Tokenizer = class {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? decode_data_xml_default : decode_data_html_default;
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = void 0;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  /**
   * The current index within all of the written data.
   */
  getIndex() {
    return this.index;
  }
  /**
   * The start of the current section.
   */
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c) {
    if (c === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.state = State.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === CharCodes2.Gt || isWhitespace(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c === CharCodes2.Amp) {
          this.state = State.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === CharCodes2.Lt);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(c) {
    return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c) {
    if (c === CharCodes2.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c)) {
      const lower = c | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
      }
    } else if (c === CharCodes2.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace(c)) {
    } else if (c === CharCodes2.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === CharCodes2.Gt || isWhitespace(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c) {
    if (c === CharCodes2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === CharCodes2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace(c)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateInAttributeName(c) {
    if (c === CharCodes2.Eq || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c);
    }
  }
  stateAfterAttributeName(c) {
    if (c === CharCodes2.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c === CharCodes2.Slash || c === CharCodes2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (!isWhitespace(c)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c) {
    if (c === CharCodes2.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c);
    }
  }
  handleInAttributeValue(c, quote) {
    if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c) {
    if (isWhitespace(c) || c === CharCodes2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c) {
    if (c === CharCodes2.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c === CharCodes2.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === CharCodes2.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    const lower = c | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c);
    }
  }
  stateBeforeEntity(c) {
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c === CharCodes2.Number) {
      this.state = State.BeforeNumericEntity;
    } else if (c === CharCodes2.Amp) {
    } else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State.InNamedEntity;
      this.stateInNamedEntity(c);
    }
  }
  stateInNamedEntity(c) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    if (masked) {
      const valueLength = (masked >> 14) - 1;
      if (!this.allowLegacyEntity() && c !== CharCodes2.Semi) {
        this.trieIndex += valueLength;
      } else {
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c) {
    if ((c | 32) === CharCodes2.LowerX) {
      this.entityExcess++;
      this.state = State.InHexEntity;
    } else {
      this.state = State.InNumericEntity;
      this.stateInNumericEntity(c);
    }
  }
  emitNumericEntity(strict) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
    if (numberStart !== this.index) {
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c) {
    if (c === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c)) {
      this.entityResult = this.entityResult * 10 + (c - CharCodes2.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c) {
    if (c === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c)) {
      this.entityResult = this.entityResult * 16 + (c - CharCodes2.Zero);
      this.entityExcess++;
    } else if (isHexDigit(c)) {
      this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes2.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    while (this.shouldContinue()) {
      const c = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case State.InNamedEntity: {
          this.stateInNamedEntity(c);
          break;
        }
        case State.BeforeEntity: {
          this.stateBeforeEntity(c);
          break;
        }
        case State.InHexEntity: {
          this.stateInHexEntity(c);
          break;
        }
        case State.InNumericEntity: {
          this.stateInNumericEntity(c);
          break;
        }
        default: {
          this.stateBeforeNumericEntity(c);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InNamedEntity) {
      this.emitNamedEntity();
    }
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
    } else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribentity(cp);
    } else {
      this.cbs.ontextentity(cp);
    }
  }
};

// node_modules/@react-email/components/node_modules/htmlparser2/lib/esm/Parser.js
var formTags = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = /* @__PURE__ */ new Set(["p"]);
var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
var openImpliesClose = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
var htmlIntegrationElements = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;
var Parser = class {
  constructor(cbs, options = {}) {
    var _a3, _b, _c, _d, _e2;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.lowerCaseTagNames = (_a3 = options.lowerCaseTags) !== null && _a3 !== void 0 ? _a3 : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer)(this.options, this);
    (_e2 = (_d = this.cbs).onparserinit) === null || _e2 === void 0 ? void 0 : _e2.call(_d, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(start, endIndex) {
    var _a3, _b;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a3 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a3, data);
    this.startIndex = endIndex;
  }
  /** @internal */
  ontextentity(cp) {
    var _a3, _b;
    const index = this.tokenizer.getSectionStart();
    this.endIndex = index - 1;
    (_b = (_a3 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a3, fromCodePoint(cp));
    this.startIndex = index;
  }
  isVoidElement(name) {
    return !this.options.xmlMode && voidElements.has(name);
  }
  /** @internal */
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    this.emitOpenTag(name);
  }
  emitOpenTag(name) {
    var _a3, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name;
    const impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        const element = this.stack.pop();
        (_b = (_a3 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a3, element, true);
      }
    }
    if (!this.isVoidElement(name)) {
      this.stack.push(name);
      if (foreignContextElements.has(name)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a3, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a3 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a3, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  /** @internal */
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onclosetag(start, endIndex) {
    var _a3, _b, _c, _d, _e2, _f2;
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name)) {
      const pos = this.stack.lastIndexOf(name);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count = this.stack.length - pos;
          while (count--) {
            this.cbs.onclosetag(this.stack.pop(), count !== 0);
          }
        } else
          this.stack.length = pos;
      } else if (!this.options.xmlMode && name === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name === "br") {
      (_b = (_a3 = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a3, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
      (_f2 = (_e2 = this.cbs).onclosetag) === null || _f2 === void 0 ? void 0 : _f2.call(_e2, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a3, _b;
    const name = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[this.stack.length - 1] === name) {
      (_b = (_a3 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a3, name, !isOpenImplied);
      this.stack.pop();
    }
  }
  /** @internal */
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
  }
  /** @internal */
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  /** @internal */
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  /** @internal */
  onattribend(quote, endIndex) {
    var _a3, _b;
    this.endIndex = endIndex;
    (_b = (_a3 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a3, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index = value.search(reNameEnd);
    let name = index < 0 ? value : value.substr(0, index);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    return name;
  }
  /** @internal */
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncomment(start, endIndex, offset) {
    var _a3, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a3 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a3, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncdata(start, endIndex, offset) {
    var _a3, _b, _c, _d, _e2, _f2, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a3 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a3);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f2 = (_e2 = this.cbs).oncdataend) === null || _f2 === void 0 ? void 0 : _f2.call(_e2);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onend() {
    var _a3, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index = this.stack.length; index > 0; this.cbs.onclosetag(this.stack[--index], true))
        ;
    }
    (_b = (_a3 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a3);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var _a3, _b, _c, _d;
    (_b = (_a3 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a3);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(chunk) {
    var _a3, _b;
    if (this.ended) {
      (_b = (_a3 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a3, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(chunk) {
    var _a3, _b;
    if (this.ended) {
      (_b = (_a3 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a3, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(chunk) {
    this.write(chunk);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(chunk) {
    this.end(chunk);
  }
};

// node_modules/@react-email/components/node_modules/domutils/lib/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  DocumentPosition: () => DocumentPosition,
  append: () => append,
  appendChild: () => appendChild,
  compareDocumentPosition: () => compareDocumentPosition,
  existsOne: () => existsOne,
  filter: () => filter,
  find: () => find,
  findAll: () => findAll,
  findOne: () => findOne,
  findOneChild: () => findOneChild,
  getAttributeValue: () => getAttributeValue,
  getChildren: () => getChildren,
  getElementById: () => getElementById,
  getElements: () => getElements,
  getElementsByTagName: () => getElementsByTagName,
  getElementsByTagType: () => getElementsByTagType,
  getFeed: () => getFeed,
  getInnerHTML: () => getInnerHTML,
  getName: () => getName,
  getOuterHTML: () => getOuterHTML,
  getParent: () => getParent,
  getSiblings: () => getSiblings,
  getText: () => getText,
  hasAttrib: () => hasAttrib,
  hasChildren: () => hasChildren,
  innerText: () => innerText,
  isCDATA: () => isCDATA,
  isComment: () => isComment,
  isDocument: () => isDocument,
  isTag: () => isTag2,
  isText: () => isText,
  nextElementSibling: () => nextElementSibling,
  prepend: () => prepend,
  prependChild: () => prependChild,
  prevElementSibling: () => prevElementSibling,
  removeElement: () => removeElement,
  removeSubsets: () => removeSubsets,
  replaceElement: () => replaceElement,
  testElement: () => testElement,
  textContent: () => textContent,
  uniqueSort: () => uniqueSort
});

// node_modules/@react-email/components/node_modules/entities/lib/esm/generated/encode-html.js
function restoreDiff(arr) {
  for (let i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
var encode_html_default = new Map(restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

// node_modules/@react-email/components/node_modules/entities/lib/esm/escape.js
var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index)
  )
);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i = match.index;
    const char = str.charCodeAt(i);
    const next = xmlCodeMap.get(char);
    if (next !== void 0) {
      ret += str.substring(lastIdx, i) + next;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map2) {
  return function escape2(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map2.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/@react-email/components/node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// node_modules/@react-email/components/node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val) => [val.toLowerCase(), val]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val) => [val.toLowerCase(), val]));

// node_modules/@react-email/components/node_modules/dom-serializer/lib/esm/index.js
var unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes, opts) {
  var _a3;
  if (!attributes)
    return;
  const encode = ((_a3 = opts.encodeEntities) !== null && _a3 !== void 0 ? _a3 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes).map((key) => {
    var _a4, _b;
    const value = (_a4 = attributes[key]) !== null && _a4 !== void 0 ? _a4 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode(value)}"`;
  }).join(" ");
}
var singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node, options = {}) {
  const nodes = "length" in node ? node : [node];
  let output = "";
  for (let i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
var esm_default = render;
function renderNode(node, options) {
  switch (node.type) {
    case Root:
      return render(node.children, options);
    case Doctype:
    case Directive:
      return renderDirective(node);
    case Comment:
      return renderComment(node);
    case CDATA:
      return renderCdata(node);
    case Script:
    case Style:
    case Tag:
      return renderTag(node, options);
    case Text:
      return renderText(node, options);
  }
}
var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a3;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a3 = elementNames.get(elem.name)) !== null && _a3 !== void 0 ? _a3 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a3;
  let data = elem.data || "";
  if (((_a3 = opts.encodeEntities) !== null && _a3 !== void 0 ? _a3 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data) : escapeText(data);
  }
  return data;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}

// node_modules/@react-email/components/node_modules/domutils/lib/esm/stringify.js
function getOuterHTML(node, options) {
  return esm_default(node, options);
}
function getInnerHTML(node, options) {
  return hasChildren(node) ? node.children.map((node2) => getOuterHTML(node2, options)).join("") : "";
}
function getText(node) {
  if (Array.isArray(node))
    return node.map(getText).join("");
  if (isTag2(node))
    return node.name === "br" ? "\n" : getText(node.children);
  if (isCDATA(node))
    return getText(node.children);
  if (isText(node))
    return node.data;
  return "";
}
function textContent(node) {
  if (Array.isArray(node))
    return node.map(textContent).join("");
  if (hasChildren(node) && !isComment(node)) {
    return textContent(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}
function innerText(node) {
  if (Array.isArray(node))
    return node.map(innerText).join("");
  if (hasChildren(node) && (node.type === ElementType.Tag || isCDATA(node))) {
    return innerText(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}

// node_modules/@react-email/components/node_modules/domutils/lib/esm/traversal.js
function getChildren(elem) {
  return hasChildren(elem) ? elem.children : [];
}
function getParent(elem) {
  return elem.parent || null;
}
function getSiblings(elem) {
  const parent = getParent(elem);
  if (parent != null)
    return getChildren(parent);
  const siblings = [elem];
  let { prev, next } = elem;
  while (prev != null) {
    siblings.unshift(prev);
    ({ prev } = prev);
  }
  while (next != null) {
    siblings.push(next);
    ({ next } = next);
  }
  return siblings;
}
function getAttributeValue(elem, name) {
  var _a3;
  return (_a3 = elem.attribs) === null || _a3 === void 0 ? void 0 : _a3[name];
}
function hasAttrib(elem, name) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
}
function getName(elem) {
  return elem.name;
}
function nextElementSibling(elem) {
  let { next } = elem;
  while (next !== null && !isTag2(next))
    ({ next } = next);
  return next;
}
function prevElementSibling(elem) {
  let { prev } = elem;
  while (prev !== null && !isTag2(prev))
    ({ prev } = prev);
  return prev;
}

// node_modules/@react-email/components/node_modules/domutils/lib/esm/manipulation.js
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
function replaceElement(elem, replacement) {
  const prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  const next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  const parent = replacement.parent = elem.parent;
  if (parent) {
    const childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
function appendChild(parent, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    const sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
function append(elem, next) {
  removeElement(next);
  const { parent } = elem;
  const currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      const childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
function prependChild(parent, child) {
  removeElement(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    const sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
function prepend(elem, prev) {
  removeElement(prev);
  const { parent } = elem;
  if (parent) {
    const childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}

// node_modules/@react-email/components/node_modules/domutils/lib/esm/querying.js
function filter(test, node, recurse = true, limit = Infinity) {
  return find(test, Array.isArray(node) ? node : [node], recurse, limit);
}
function find(test, nodes, recurse, limit) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
function findOneChild(test, nodes) {
  return nodes.find(test);
}
function findOne(test, nodes, recurse = true) {
  let elem = null;
  for (let i = 0; i < nodes.length && !elem; i++) {
    const node = nodes[i];
    if (!isTag2(node)) {
      continue;
    } else if (test(node)) {
      elem = node;
    } else if (recurse && node.children.length > 0) {
      elem = findOne(test, node.children, true);
    }
  }
  return elem;
}
function existsOne(test, nodes) {
  return nodes.some((checked) => isTag2(checked) && (test(checked) || existsOne(test, checked.children)));
}
function findAll(test, nodes) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (!isTag2(elem))
      continue;
    if (test(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}

// node_modules/@react-email/components/node_modules/domutils/lib/esm/legacy.js
var Checks = {
  tag_name(name) {
    if (typeof name === "function") {
      return (elem) => isTag2(elem) && name(elem.name);
    } else if (name === "*") {
      return isTag2;
    }
    return (elem) => isTag2(elem) && elem.name === name;
  },
  tag_type(type) {
    if (typeof type === "function") {
      return (elem) => type(elem.type);
    }
    return (elem) => elem.type === type;
  },
  tag_contains(data) {
    if (typeof data === "function") {
      return (elem) => isText(elem) && data(elem.data);
    }
    return (elem) => isText(elem) && elem.data === data;
  }
};
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return (elem) => isTag2(elem) && value(elem.attribs[attrib]);
  }
  return (elem) => isTag2(elem) && elem.attribs[attrib] === value;
}
function combineFuncs(a, b) {
  return (elem) => a(elem) || b(elem);
}
function compileTest(options) {
  const funcs = Object.keys(options).map((key) => {
    const value = options[key];
    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options, node) {
  const test = compileTest(options);
  return test ? test(node) : true;
}
function getElements(options, nodes, recurse, limit = Infinity) {
  const test = compileTest(options);
  return test ? filter(test, nodes, recurse, limit) : [];
}
function getElementById(id, nodes, recurse = true) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return findOne(getAttribCheck("id", id), nodes, recurse);
}
function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_name"](tagName), nodes, recurse, limit);
}
function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_type"](type), nodes, recurse, limit);
}

// node_modules/@react-email/components/node_modules/domutils/lib/esm/helpers.js
function removeSubsets(nodes) {
  let idx = nodes.length;
  while (--idx >= 0) {
    const node = nodes[idx];
    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
var DocumentPosition;
(function(DocumentPosition2) {
  DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = hasChildren(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
    }
    return DocumentPosition.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
  }
  return DocumentPosition.PRECEDING;
}
function uniqueSort(nodes) {
  nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));
  nodes.sort((a, b) => {
    const relative = compareDocumentPosition(a, b);
    if (relative & DocumentPosition.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}

// node_modules/@react-email/components/node_modules/domutils/lib/esm/feeds.js
function getFeed(doc) {
  const feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
function getAtomFeed(feedRoot) {
  var _a3;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: getElementsByTagName("entry", childs).map((item) => {
      var _a4;
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "id", children);
      addConditionally(entry, "title", "title", children);
      const href2 = (_a4 = getOneElement("link", children)) === null || _a4 === void 0 ? void 0 : _a4.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      const description = fetch("summary", children) || fetch("content", children);
      if (description) {
        entry.description = description;
      }
      const pubDate = fetch("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  const href = (_a3 = getOneElement("link", childs)) === null || _a3 === void 0 ? void 0 : _a3.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  const updated = fetch("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a3, _b;
  const childs = (_b = (_a3 = getOneElement("channel", feedRoot.children)) === null || _a3 === void 0 ? void 0 : _a3.children) !== null && _b !== void 0 ? _b : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: getElementsByTagName("item", feedRoot.children).map((item) => {
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "guid", children);
      addConditionally(entry, "title", "title", children);
      addConditionally(entry, "link", "link", children);
      addConditionally(entry, "description", "description", children);
      const pubDate = fetch("pubDate", children) || fetch("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  const updated = fetch("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return getElementsByTagName("media:content", where).map((elem) => {
    const { attribs } = elem;
    const media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (const attrib of MEDIA_KEYS_STRING) {
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT) {
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement(tagName, node) {
  return getElementsByTagName(tagName, node, true, 1)[0];
}
function fetch(tagName, where, recurse = false) {
  return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
}
function addConditionally(obj, prop, tagName, where, recurse = false) {
  const val = fetch(tagName, where, recurse);
  if (val)
    obj[prop] = val;
}
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}

// node_modules/@react-email/components/node_modules/htmlparser2/lib/esm/index.js
function parseDocument(data, options) {
  const handler = new DomHandler(void 0, options);
  new Parser(handler, options).end(data);
  return handler.root;
}

// node_modules/@react-email/components/node_modules/html-to-text/lib/html-to-text.mjs
var import_deepmerge = __toESM(require_cjs(), 1);
function limitedDepthRecursive(n, f, g = () => void 0) {
  if (n === void 0) {
    const f1 = function(...args) {
      return f(f1, ...args);
    };
    return f1;
  }
  if (n >= 0) {
    return function(...args) {
      return f(limitedDepthRecursive(n - 1, f, g), ...args);
    };
  }
  return g;
}
function trimCharacter(str, char) {
  let start = 0;
  let end = str.length;
  while (start < end && str[start] === char) {
    ++start;
  }
  while (end > start && str[end - 1] === char) {
    --end;
  }
  return start > 0 || end < str.length ? str.substring(start, end) : str;
}
function trimCharacterEnd(str, char) {
  let end = str.length;
  while (end > 0 && str[end - 1] === char) {
    --end;
  }
  return end < str.length ? str.substring(0, end) : str;
}
function unicodeEscape(str) {
  return str.replace(/[\s\S]/g, (c) => "\\u" + c.charCodeAt().toString(16).padStart(4, "0"));
}
function mergeDuplicatesPreferLast(items, getKey) {
  const map2 = /* @__PURE__ */ new Map();
  for (let i = items.length; i-- > 0; ) {
    const item = items[i];
    const key = getKey(item);
    map2.set(
      key,
      map2.has(key) ? (0, import_deepmerge.default)(item, map2.get(key), { arrayMerge: overwriteMerge$1 }) : item
    );
  }
  return [...map2.values()].reverse();
}
var overwriteMerge$1 = (acc, src, options) => [...src];
function get(obj, path) {
  for (const key of path) {
    if (!obj) {
      return void 0;
    }
    obj = obj[key];
  }
  return obj;
}
function numberToLetterSequence(num, baseChar = "a", base = 26) {
  const digits = [];
  do {
    num -= 1;
    digits.push(num % base);
    num = num / base >> 0;
  } while (num > 0);
  const baseCode = baseChar.charCodeAt(0);
  return digits.reverse().map((n) => String.fromCharCode(baseCode + n)).join("");
}
var I = ["I", "X", "C", "M"];
var V = ["V", "L", "D"];
function numberToRoman(num) {
  return [...num + ""].map((n) => +n).reverse().map((v, i) => v % 5 < 4 ? (v < 5 ? "" : V[i]) + I[i].repeat(v % 5) : I[i] + (v < 5 ? V[i] : I[i + 1])).reverse().join("");
}
var InlineTextBuilder = class {
  /**
   * Creates an instance of InlineTextBuilder.
   *
   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.
   *
   * @param { Options } options           HtmlToText options.
   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.
   */
  constructor(options, maxLineLength = void 0) {
    this.lines = [];
    this.nextLineWords = [];
    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
    this.nextLineAvailableChars = this.maxLineLength;
    this.wrapCharacters = get(options, ["longWordSplit", "wrapCharacters"]) || [];
    this.forceWrapOnLimit = get(options, ["longWordSplit", "forceWrapOnLimit"]) || false;
    this.stashedSpace = false;
    this.wordBreakOpportunity = false;
  }
  /**
   * Add a new word.
   *
   * @param { string } word A word to add.
   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
   */
  pushWord(word, noWrap = false) {
    if (this.nextLineAvailableChars <= 0 && !noWrap) {
      this.startNewLine();
    }
    const isLineStart = this.nextLineWords.length === 0;
    const cost = word.length + (isLineStart ? 0 : 1);
    if (cost <= this.nextLineAvailableChars || noWrap) {
      this.nextLineWords.push(word);
      this.nextLineAvailableChars -= cost;
    } else {
      const [first, ...rest] = this.splitLongWord(word);
      if (!isLineStart) {
        this.startNewLine();
      }
      this.nextLineWords.push(first);
      this.nextLineAvailableChars -= first.length;
      for (const part of rest) {
        this.startNewLine();
        this.nextLineWords.push(part);
        this.nextLineAvailableChars -= part.length;
      }
    }
  }
  /**
   * Pop a word from the currently built line.
   * This doesn't affect completed lines.
   *
   * @returns { string }
   */
  popWord() {
    const lastWord = this.nextLineWords.pop();
    if (lastWord !== void 0) {
      const isLineStart = this.nextLineWords.length === 0;
      const cost = lastWord.length + (isLineStart ? 0 : 1);
      this.nextLineAvailableChars += cost;
    }
    return lastWord;
  }
  /**
   * Concat a word to the last word already in the builder.
   * Adds a new word in case there are no words yet in the last line.
   *
   * @param { string } word A word to be concatenated.
   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
   */
  concatWord(word, noWrap = false) {
    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
      this.pushWord(word, noWrap);
      this.wordBreakOpportunity = false;
    } else {
      const lastWord = this.popWord();
      this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);
    }
  }
  /**
   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.
   *
   * @param { number } n Number of line breaks that will be added to the resulting string.
   */
  startNewLine(n = 1) {
    this.lines.push(this.nextLineWords);
    if (n > 1) {
      this.lines.push(...Array.from({ length: n - 1 }, () => []));
    }
    this.nextLineWords = [];
    this.nextLineAvailableChars = this.maxLineLength;
  }
  /**
   * No words in this builder.
   *
   * @returns { boolean }
   */
  isEmpty() {
    return this.lines.length === 0 && this.nextLineWords.length === 0;
  }
  clear() {
    this.lines.length = 0;
    this.nextLineWords.length = 0;
    this.nextLineAvailableChars = this.maxLineLength;
  }
  /**
   * Join all lines of words inside the InlineTextBuilder into a complete string.
   *
   * @returns { string }
   */
  toString() {
    return [...this.lines, this.nextLineWords].map((words) => words.join(" ")).join("\n");
  }
  /**
   * Split a long word up to fit within the word wrap limit.
   * Use either a character to split looking back from the word wrap limit,
   * or truncate to the word wrap limit.
   *
   * @param   { string }   word Input word.
   * @returns { string[] }      Parts of the word.
   */
  splitLongWord(word) {
    const parts = [];
    let idx = 0;
    while (word.length > this.maxLineLength) {
      const firstLine = word.substring(0, this.maxLineLength);
      const remainingChars = word.substring(this.maxLineLength);
      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);
      if (splitIndex > -1) {
        word = firstLine.substring(splitIndex + 1) + remainingChars;
        parts.push(firstLine.substring(0, splitIndex + 1));
      } else {
        idx++;
        if (idx < this.wrapCharacters.length) {
          word = firstLine + remainingChars;
        } else {
          if (this.forceWrapOnLimit) {
            parts.push(firstLine);
            word = remainingChars;
            if (word.length > this.maxLineLength) {
              continue;
            }
          } else {
            word = firstLine + remainingChars;
          }
          break;
        }
      }
    }
    parts.push(word);
    return parts;
  }
};
var StackItem = class {
  constructor(next = null) {
    this.next = next;
  }
  getRoot() {
    return this.next ? this.next : this;
  }
};
var BlockStackItem = class extends StackItem {
  constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = void 0) {
    super(next);
    this.leadingLineBreaks = leadingLineBreaks;
    this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
};
var ListStackItem = class extends BlockStackItem {
  constructor(options, next = null, {
    interRowLineBreaks = 1,
    leadingLineBreaks = 2,
    maxLineLength = void 0,
    maxPrefixLength = 0,
    prefixAlign = "left"
  } = {}) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.maxPrefixLength = maxPrefixLength;
    this.prefixAlign = prefixAlign;
    this.interRowLineBreaks = interRowLineBreaks;
  }
};
var ListItemStackItem = class extends BlockStackItem {
  constructor(options, next = null, {
    leadingLineBreaks = 1,
    maxLineLength = void 0,
    prefix = ""
  } = {}) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.prefix = prefix;
  }
};
var TableStackItem = class extends StackItem {
  constructor(next = null) {
    super(next);
    this.rows = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
};
var TableRowStackItem = class extends StackItem {
  constructor(next = null) {
    super(next);
    this.cells = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
};
var TableCellStackItem = class extends StackItem {
  constructor(options, next = null, maxColumnWidth = void 0) {
    super(next);
    this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
};
var TransformerStackItem = class extends StackItem {
  constructor(next = null, transform) {
    super(next);
    this.transform = transform;
  }
};
function charactersToCodes(str) {
  return [...str].map((c) => "\\u" + c.charCodeAt(0).toString(16).padStart(4, "0")).join("");
}
var WhitespaceProcessor = class {
  /**
   * Creates an instance of WhitespaceProcessor.
   *
   * @param { Options } options    HtmlToText options.
   * @memberof WhitespaceProcessor
   */
  constructor(options) {
    this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\n/g, "") : options.whitespaceCharacters;
    const whitespaceCodes = charactersToCodes(this.whitespaceChars);
    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);
    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);
    this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, "g");
    this.newlineOrNonNewlineStringRe = new RegExp(`(\\n|[^\\n]+)`, "g");
    if (options.preserveNewlines) {
      const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, "gm");
      this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str) => str, noWrap = false) {
        if (!text) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordOrNewlineRe.exec(text);
        if (m) {
          anyMatch = true;
          if (m[0] === "\n") {
            inlineTextBuilder.startNewLine();
          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform(m[0]), noWrap);
          }
          while ((m = wordOrNewlineRe.exec(text)) !== null) {
            if (m[0] === "\n") {
              inlineTextBuilder.startNewLine();
            } else {
              inlineTextBuilder.pushWord(transform(m[0]), noWrap);
            }
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
      };
    } else {
      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, "g");
      this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str) => str, noWrap = false) {
        if (!text) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordRe.exec(text);
        if (m) {
          anyMatch = true;
          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform(m[0]), noWrap);
          }
          while ((m = wordRe.exec(text)) !== null) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
      };
    }
  }
  /**
   * Add text with only minimal processing.
   * Everything between newlines considered a single word.
   * No whitespace is trimmed.
   * Not affected by preserveNewlines option - `\n` always starts a new line.
   *
   * `noWrap` argument is `true` by default - this won't start a new line
   * even if there is not enough space left in the current line.
   *
   * @param { string }            text              Input text.
   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.
   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.
   */
  addLiteral(text, inlineTextBuilder, noWrap = true) {
    if (!text) {
      return;
    }
    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
    let anyMatch = false;
    let m = this.newlineOrNonNewlineStringRe.exec(text);
    if (m) {
      anyMatch = true;
      if (m[0] === "\n") {
        inlineTextBuilder.startNewLine();
      } else if (previouslyStashedSpace) {
        inlineTextBuilder.pushWord(m[0], noWrap);
      } else {
        inlineTextBuilder.concatWord(m[0], noWrap);
      }
      while ((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null) {
        if (m[0] === "\n") {
          inlineTextBuilder.startNewLine();
        } else {
          inlineTextBuilder.pushWord(m[0], noWrap);
        }
      }
    }
    inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;
  }
  /**
   * Test whether the given text starts with HTML whitespace character.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testLeadingWhitespace(text) {
    return this.leadingWhitespaceRe.test(text);
  }
  /**
   * Test whether the given text ends with HTML whitespace character.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testTrailingWhitespace(text) {
    return this.trailingWhitespaceRe.test(text);
  }
  /**
   * Test whether the given text contains any non-whitespace characters.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testContainsWords(text) {
    return !this.allWhitespaceOrEmptyRe.test(text);
  }
  /**
   * Return the number of newlines if there are no words.
   *
   * If any word is found then return zero regardless of the actual number of newlines.
   *
   * @param   { string }  text  Input string.
   * @returns { number }
   */
  countNewlinesNoWords(text) {
    this.newlineOrNonWhitespaceRe.lastIndex = 0;
    let counter = 0;
    let match;
    while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {
      if (match[0] === "\n") {
        counter++;
      } else {
        return 0;
      }
    }
    return counter;
  }
};
var BlockTextBuilder = class {
  /**
   * Creates an instance of BlockTextBuilder.
   *
   * @param { Options } options HtmlToText options.
   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.
   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.
   */
  constructor(options, picker, metadata = void 0) {
    this.options = options;
    this.picker = picker;
    this.metadata = metadata;
    this.whitespaceProcessor = new WhitespaceProcessor(options);
    this._stackItem = new BlockStackItem(options);
    this._wordTransformer = void 0;
  }
  /**
   * Put a word-by-word transform function onto the transformations stack.
   *
   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.
   *
   * Word transformations applied before wrapping.
   *
   * @param { (str: string) => string } wordTransform Word transformation function.
   */
  pushWordTransform(wordTransform) {
    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
  }
  /**
   * Remove a function from the word transformations stack.
   *
   * @returns { (str: string) => string } A function that was removed.
   */
  popWordTransform() {
    if (!this._wordTransformer) {
      return void 0;
    }
    const transform = this._wordTransformer.transform;
    this._wordTransformer = this._wordTransformer.next;
    return transform;
  }
  /**
   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.
   */
  startNoWrap() {
    this._stackItem.isNoWrap = true;
  }
  /**
   * Return automatic wrapping to behavior defined by options.
   */
  stopNoWrap() {
    this._stackItem.isNoWrap = false;
  }
  /** @returns { (str: string) => string } */
  _getCombinedWordTransformer() {
    const wt = this._wordTransformer ? (str) => applyTransformer(str, this._wordTransformer) : void 0;
    const ce2 = this.options.encodeCharacters;
    return wt ? ce2 ? (str) => ce2(wt(str)) : wt : ce2;
  }
  _popStackItem() {
    const item = this._stackItem;
    this._stackItem = item.next;
    return item;
  }
  /**
   * Add a line break into currently built block.
   */
  addLineBreak() {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += "\n";
    } else {
      this._stackItem.inlineTextBuilder.startNewLine();
    }
  }
  /**
   * Allow to break line in case directly following text will not fit.
   */
  addWordBreakOpportunity() {
    if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {
      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
    }
  }
  /**
   * Add a node inline into the currently built block.
   *
   * @param { string } str
   * Text content of a node to add.
   *
   * @param { object } [param1]
   * Object holding the parameters of the operation.
   *
   * @param { boolean } [param1.noWordTransform]
   * Ignore word transformers if there are any.
   * Don't encode characters as well.
   * (Use this for things like URL addresses).
   */
  addInline(str, { noWordTransform = false } = {}) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (str.length === 0 || // empty string
    this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant
    !this.whitespaceProcessor.testContainsWords(str)) {
      return;
    }
    if (this.options.preserveNewlines) {
      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
      if (newlinesNumber > 0) {
        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
        return;
      }
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.shrinkWrapAdd(
      str,
      this._stackItem.inlineTextBuilder,
      noWordTransform ? void 0 : this._getCombinedWordTransformer(),
      this._stackItem.isNoWrap
    );
    this._stackItem.stashedLineBreaks = 0;
  }
  /**
   * Add a string inline into the currently built block.
   *
   * Use this for markup elements that don't have to adhere
   * to text layout rules.
   *
   * @param { string } str Text to add.
   */
  addLiteral(str) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (str.length === 0) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.addLiteral(
      str,
      this._stackItem.inlineTextBuilder,
      this._stackItem.isNoWrap
    );
    this._stackItem.stashedLineBreaks = 0;
  }
  /**
   * Start building a new block.
   *
   * @param { object } [param0]
   * Object holding the parameters of the block.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This block should have at least this number of line breaks to separate it from any preceding block.
   *
   * @param { number }  [param0.reservedLineLength]
   * Reserve this number of characters on each line for block markup.
   *
   * @param { boolean } [param0.isPre]
   * Should HTML whitespace be preserved inside this block.
   */
  openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
    this._stackItem = new BlockStackItem(
      this.options,
      this._stackItem,
      leadingLineBreaks,
      maxLineLength
    );
    if (isPre) {
      this._stackItem.isPre = true;
    }
  }
  /**
   * Finalize currently built block, add it's content to the parent block.
   *
   * @param { object } [param0]
   * Object holding the parameters of the block.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This block should have at least this number of line breaks to separate it from any following block.
   *
   * @param { (str: string) => string } [param0.blockTransform]
   * A function to transform the block text before adding to the parent block.
   * This happens after word wrap and should be used in combination with reserved line length
   * in order to keep line lengths correct.
   * Used for whole block markup.
   */
  closeBlock({ trailingLineBreaks = 1, blockTransform = void 0 } = {}) {
    const block = this._popStackItem();
    const blockText = blockTransform ? blockTransform(getText2(block)) : getText2(block);
    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
  }
  /**
   * Start building a new list.
   *
   * @param { object } [param0]
   * Object holding the parameters of the list.
   *
   * @param { number } [param0.maxPrefixLength]
   * Length of the longest list item prefix.
   * If not supplied or too small then list items won't be aligned properly.
   *
   * @param { 'left' | 'right' } [param0.prefixAlign]
   * Specify how prefixes of different lengths have to be aligned
   * within a column.
   *
   * @param { number } [param0.interRowLineBreaks]
   * Minimum number of line breaks between list items.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This list should have at least this number of line breaks to separate it from any preceding block.
   */
  openList({ maxPrefixLength = 0, prefixAlign = "left", interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {
    this._stackItem = new ListStackItem(this.options, this._stackItem, {
      interRowLineBreaks,
      leadingLineBreaks,
      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,
      maxPrefixLength,
      prefixAlign
    });
  }
  /**
   * Start building a new list item.
   *
   * @param {object} param0
   * Object holding the parameters of the list item.
   *
   * @param { string } [param0.prefix]
   * Prefix for this list item (item number, bullet point, etc).
   */
  openListItem({ prefix = "" } = {}) {
    if (!(this._stackItem instanceof ListStackItem)) {
      throw new Error("Can't add a list item to something that is not a list! Check the formatter.");
    }
    const list = this._stackItem;
    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);
    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);
    this._stackItem = new ListItemStackItem(this.options, list, {
      prefix,
      maxLineLength,
      leadingLineBreaks: list.interRowLineBreaks
    });
  }
  /**
   * Finalize currently built list item, add it's content to the parent list.
   */
  closeListItem() {
    const listItem = this._popStackItem();
    const list = listItem.next;
    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);
    const spacing = "\n" + " ".repeat(prefixLength);
    const prefix = list.prefixAlign === "right" ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);
    const text = prefix + getText2(listItem).replace(/\n/g, spacing);
    addText(
      list,
      text,
      listItem.leadingLineBreaks,
      Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks)
    );
  }
  /**
   * Finalize currently built list, add it's content to the parent block.
   *
   * @param { object } param0
   * Object holding the parameters of the list.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This list should have at least this number of line breaks to separate it from any following block.
   */
  closeList({ trailingLineBreaks = 2 } = {}) {
    const list = this._popStackItem();
    const text = getText2(list);
    if (text) {
      addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);
    }
  }
  /**
   * Start building a table.
   */
  openTable() {
    this._stackItem = new TableStackItem(this._stackItem);
  }
  /**
   * Start building a table row.
   */
  openTableRow() {
    if (!(this._stackItem instanceof TableStackItem)) {
      throw new Error("Can't add a table row to something that is not a table! Check the formatter.");
    }
    this._stackItem = new TableRowStackItem(this._stackItem);
  }
  /**
   * Start building a table cell.
   *
   * @param { object } [param0]
   * Object holding the parameters of the cell.
   *
   * @param { number } [param0.maxColumnWidth]
   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.
   */
  openTableCell({ maxColumnWidth = void 0 } = {}) {
    if (!(this._stackItem instanceof TableRowStackItem)) {
      throw new Error("Can't add a table cell to something that is not a table row! Check the formatter.");
    }
    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
  }
  /**
   * Finalize currently built table cell and add it to parent table row's cells.
   *
   * @param { object } [param0]
   * Object holding the parameters of the cell.
   *
   * @param { number } [param0.colspan] How many columns this cell should occupy.
   * @param { number } [param0.rowspan] How many rows this cell should occupy.
   */
  closeTableCell({ colspan = 1, rowspan = 1 } = {}) {
    const cell = this._popStackItem();
    const text = trimCharacter(getText2(cell), "\n");
    cell.next.cells.push({ colspan, rowspan, text });
  }
  /**
   * Finalize currently built table row and add it to parent table's rows.
   */
  closeTableRow() {
    const row = this._popStackItem();
    row.next.rows.push(row.cells);
  }
  /**
   * Finalize currently built table and add the rendered text to the parent block.
   *
   * @param { object } param0
   * Object holding the parameters of the table.
   *
   * @param { TablePrinter } param0.tableToString
   * A function to convert a table of stringified cells into a complete table.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This table should have at least this number of line breaks to separate if from any preceding block.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This table should have at least this number of line breaks to separate it from any following block.
   */
  closeTable({ tableToString: tableToString2, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {
    const table = this._popStackItem();
    const output = tableToString2(table.rows);
    if (output) {
      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
    }
  }
  /**
   * Return the rendered text content of this builder.
   *
   * @returns { string }
   */
  toString() {
    return getText2(this._stackItem.getRoot());
  }
};
function getText2(stackItem) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can be requested for text contents.");
  }
  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();
}
function addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can contain text.");
  }
  const parentText = getText2(stackItem);
  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
  stackItem.inlineTextBuilder.clear();
  if (parentText) {
    stackItem.rawText = parentText + "\n".repeat(lineBreaks) + text;
  } else {
    stackItem.rawText = text;
    stackItem.leadingLineBreaks = lineBreaks;
  }
  stackItem.stashedLineBreaks = trailingLineBreaks;
}
function applyTransformer(str, transformer) {
  return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;
}
function compile$1(options = {}) {
  const selectorsWithoutFormat = options.selectors.filter((s) => !s.format);
  if (selectorsWithoutFormat.length) {
    throw new Error(
      "Following selectors have no specified format: " + selectorsWithoutFormat.map((s) => `\`${s.selector}\``).join(", ")
    );
  }
  const picker = new DecisionTree(
    options.selectors.map((s) => [s.selector, s])
  ).build(hp2Builder);
  if (typeof options.encodeCharacters !== "function") {
    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);
  }
  const baseSelectorsPicker = new DecisionTree(
    options.baseElements.selectors.map((s, i) => [s, i + 1])
  ).build(hp2Builder);
  function findBaseElements(dom) {
    return findBases(dom, options, baseSelectorsPicker);
  }
  const limitedWalk = limitedDepthRecursive(
    options.limits.maxDepth,
    recursiveWalk,
    function(dom, builder) {
      builder.addInline(options.limits.ellipsis || "");
    }
  );
  return function(html, metadata = void 0) {
    return process2(html, metadata, options, picker, findBaseElements, limitedWalk);
  };
}
function process2(html, metadata, options, picker, findBaseElements, walk) {
  const maxInputLength = options.limits.maxInputLength;
  if (maxInputLength && html && html.length > maxInputLength) {
    console.warn(
      `Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`
    );
    html = html.substring(0, maxInputLength);
  }
  const document2 = parseDocument(html, { decodeEntities: options.decodeEntities });
  const bases = findBaseElements(document2.children);
  const builder = new BlockTextBuilder(options, picker, metadata);
  walk(bases, builder);
  return builder.toString();
}
function findBases(dom, options, baseSelectorsPicker) {
  const results = [];
  function recursiveWalk2(walk, dom2) {
    dom2 = dom2.slice(0, options.limits.maxChildNodes);
    for (const elem of dom2) {
      if (elem.type !== "tag") {
        continue;
      }
      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
      if (pickedSelectorIndex > 0) {
        results.push({ selectorIndex: pickedSelectorIndex, element: elem });
      } else if (elem.children) {
        walk(elem.children);
      }
      if (results.length >= options.limits.maxBaseElements) {
        return;
      }
    }
  }
  const limitedWalk = limitedDepthRecursive(
    options.limits.maxDepth,
    recursiveWalk2
  );
  limitedWalk(dom);
  if (options.baseElements.orderBy !== "occurrence") {
    results.sort((a, b) => a.selectorIndex - b.selectorIndex);
  }
  return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x) => x.element);
}
function recursiveWalk(walk, dom, builder) {
  if (!dom) {
    return;
  }
  const options = builder.options;
  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
  if (tooManyChildNodes) {
    dom = dom.slice(0, options.limits.maxChildNodes);
    dom.push({
      data: options.limits.ellipsis,
      type: "text"
    });
  }
  for (const elem of dom) {
    switch (elem.type) {
      case "text": {
        builder.addInline(elem.data);
        break;
      }
      case "tag": {
        const tagDefinition = builder.picker.pick1(elem);
        const format = options.formatters[tagDefinition.format];
        format(elem, walk, builder, tagDefinition.options || {});
        break;
      }
    }
  }
  return;
}
function makeReplacerFromDict(dict) {
  if (!dict || Object.keys(dict).length === 0) {
    return void 0;
  }
  const entries = Object.entries(dict).filter(([, v]) => v !== false);
  const regex = new RegExp(
    entries.map(([c]) => `(${unicodeEscape([...c][0])})`).join("|"),
    "g"
  );
  const values = entries.map(([, v]) => v);
  const replacer = (m, ...cgs) => values[cgs.findIndex((cg) => cg)];
  return (str) => str.replace(regex, replacer);
}
function formatSkip(elem, walk, builder, formatOptions) {
}
function formatInlineString(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.string || "");
}
function formatBlockString(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addLiteral(formatOptions.string || "");
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInline(elem, walk, builder, formatOptions) {
  walk(elem.children, builder);
}
function formatBlock$1(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function renderOpenTag(elem) {
  const attrs = elem.attribs && elem.attribs.length ? " " + Object.entries(elem.attribs).map(([k, v]) => v === "" ? k : `${k}=${v.replace(/"/g, "&quot;")}`).join(" ") : "";
  return `<${elem.name}${attrs}>`;
}
function renderCloseTag(elem) {
  return `</${elem.name}>`;
}
function formatInlineTag(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
}
function formatBlockTag(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineHtml(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(
    render(elem, { decodeEntities: builder.options.decodeEntities })
  );
  builder.stopNoWrap();
}
function formatBlockHtml(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(
    render(elem, { decodeEntities: builder.options.decodeEntities })
  );
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineSurround(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.prefix || "");
  walk(elem.children, builder);
  builder.addLiteral(formatOptions.suffix || "");
}
var genericFormatters = Object.freeze({
  __proto__: null,
  block: formatBlock$1,
  blockHtml: formatBlockHtml,
  blockString: formatBlockString,
  blockTag: formatBlockTag,
  inline: formatInline,
  inlineHtml: formatInlineHtml,
  inlineString: formatInlineString,
  inlineSurround: formatInlineSurround,
  inlineTag: formatInlineTag,
  skip: formatSkip
});
function getRow(matrix, j) {
  if (!matrix[j]) {
    matrix[j] = [];
  }
  return matrix[j];
}
function findFirstVacantIndex(row, x = 0) {
  while (row[x]) {
    x++;
  }
  return x;
}
function transposeInPlace(matrix, maxSize) {
  for (let i = 0; i < maxSize; i++) {
    const rowI = getRow(matrix, i);
    for (let j = 0; j < i; j++) {
      const rowJ = getRow(matrix, j);
      const temp = rowI[j];
      rowI[j] = rowJ[i];
      rowJ[i] = temp;
    }
  }
}
function putCellIntoLayout(cell, layout, baseRow, baseCol) {
  for (let r = 0; r < cell.rowspan; r++) {
    const layoutRow = getRow(layout, baseRow + r);
    for (let c = 0; c < cell.colspan; c++) {
      layoutRow[baseCol + c] = cell;
    }
  }
}
function updateOffset(offsets, base, span, value) {
  offsets[base + span] = Math.max(
    offsets[base + span] || 0,
    offsets[base] + value
  );
}
function tableToString(tableRows, rowSpacing, colSpacing) {
  const layout = [];
  let colNumber = 0;
  const rowNumber = tableRows.length;
  const rowOffsets = [0];
  for (let j = 0; j < rowNumber; j++) {
    const layoutRow = getRow(layout, j);
    const cells = tableRows[j];
    let x = 0;
    for (let i = 0; i < cells.length; i++) {
      const cell = cells[i];
      x = findFirstVacantIndex(layoutRow, x);
      putCellIntoLayout(cell, layout, j, x);
      x += cell.colspan;
      cell.lines = cell.text.split("\n");
      const cellHeight = cell.lines.length;
      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);
    }
    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;
  }
  transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);
  const outputLines = [];
  const colOffsets = [0];
  for (let x = 0; x < colNumber; x++) {
    let y = 0;
    let cell;
    while (y < rowNumber && (cell = layout[x][y])) {
      if (!cell.rendered) {
        let cellWidth = 0;
        for (let j = 0; j < cell.lines.length; j++) {
          const line = cell.lines[j];
          const lineOffset = rowOffsets[y] + j;
          outputLines[lineOffset] = (outputLines[lineOffset] || "").padEnd(colOffsets[x]) + line;
          cellWidth = line.length > cellWidth ? line.length : cellWidth;
        }
        updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);
        cell.rendered = true;
      }
      y += cell.rowspan;
    }
  }
  return outputLines.join("\n");
}
function formatLineBreak(elem, walk, builder, formatOptions) {
  builder.addLineBreak();
}
function formatWbr(elem, walk, builder, formatOptions) {
  builder.addWordBreakOpportunity();
}
function formatHorizontalLine(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addInline("-".repeat(formatOptions.length || builder.options.wordwrap || 40));
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatParagraph(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatPre(elem, walk, builder, formatOptions) {
  builder.openBlock({
    isPre: true,
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2
  });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatHeading(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  if (formatOptions.uppercase !== false) {
    builder.pushWordTransform((str) => str.toUpperCase());
    walk(elem.children, builder);
    builder.popWordTransform();
  } else {
    walk(elem.children, builder);
  }
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatBlockquote(elem, walk, builder, formatOptions) {
  builder.openBlock({
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
    reservedLineLength: 2
  });
  walk(elem.children, builder);
  builder.closeBlock({
    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
    blockTransform: (str) => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, "\n") : str).split("\n").map((line) => "> " + line).join("\n")
  });
}
function withBrackets(str, brackets) {
  if (!brackets) {
    return str;
  }
  const lbr = typeof brackets[0] === "string" ? brackets[0] : "[";
  const rbr = typeof brackets[1] === "string" ? brackets[1] : "]";
  return lbr + str + rbr;
}
function pathRewrite(path, rewriter, baseUrl, metadata, elem) {
  const modifiedPath = typeof rewriter === "function" ? rewriter(path, metadata, elem) : path;
  return modifiedPath[0] === "/" && baseUrl ? trimCharacterEnd(baseUrl, "/") + modifiedPath : modifiedPath;
}
function formatImage(elem, walk, builder, formatOptions) {
  const attribs = elem.attribs || {};
  const alt = attribs.alt ? attribs.alt : "";
  const src = !attribs.src ? "" : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
  const text = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + " " + withBrackets(src, formatOptions.linkBrackets);
  builder.addInline(text, { noWordTransform: true });
}
function formatAnchor(elem, walk, builder, formatOptions) {
  function getHref() {
    if (formatOptions.ignoreHref) {
      return "";
    }
    if (!elem.attribs || !elem.attribs.href) {
      return "";
    }
    let href2 = elem.attribs.href.replace(/^mailto:/, "");
    if (formatOptions.noAnchorUrl && href2[0] === "#") {
      return "";
    }
    href2 = pathRewrite(href2, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
    return href2;
  }
  const href = getHref();
  if (!href) {
    walk(elem.children, builder);
  } else {
    let text = "";
    builder.pushWordTransform(
      (str) => {
        if (str) {
          text += str;
        }
        return str;
      }
    );
    walk(elem.children, builder);
    builder.popWordTransform();
    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;
    if (!hideSameLink) {
      builder.addInline(
        !text ? href : " " + withBrackets(href, formatOptions.linkBrackets),
        { noWordTransform: true }
      );
    }
  }
}
function formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {
  const isNestedList = get(elem, ["parent", "name"]) === "li";
  let maxPrefixLength = 0;
  const listItems = (elem.children || []).filter((child) => child.type !== "text" || !/^\s*$/.test(child.data)).map(function(child) {
    if (child.name !== "li") {
      return { node: child, prefix: "" };
    }
    const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();
    if (prefix.length > maxPrefixLength) {
      maxPrefixLength = prefix.length;
    }
    return { node: child, prefix };
  });
  if (!listItems.length) {
    return;
  }
  builder.openList({
    interRowLineBreaks: 1,
    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,
    maxPrefixLength,
    prefixAlign: "left"
  });
  for (const { node, prefix } of listItems) {
    builder.openListItem({ prefix });
    walk([node], builder);
    builder.closeListItem();
  }
  builder.closeList({ trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2 });
}
function formatUnorderedList(elem, walk, builder, formatOptions) {
  const prefix = formatOptions.itemPrefix || " * ";
  return formatList(elem, walk, builder, formatOptions, () => prefix);
}
function formatOrderedList(elem, walk, builder, formatOptions) {
  let nextIndex = Number(elem.attribs.start || "1");
  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
  const nextPrefixCallback = () => " " + indexFunction(nextIndex++) + ". ";
  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
}
function getOrderedListIndexFunction(olType = "1") {
  switch (olType) {
    case "a":
      return (i) => numberToLetterSequence(i, "a");
    case "A":
      return (i) => numberToLetterSequence(i, "A");
    case "i":
      return (i) => numberToRoman(i).toLowerCase();
    case "I":
      return (i) => numberToRoman(i);
    case "1":
    default:
      return (i) => i.toString();
  }
}
function splitClassesAndIds(selectors) {
  const classes = [];
  const ids = [];
  for (const selector of selectors) {
    if (selector.startsWith(".")) {
      classes.push(selector.substring(1));
    } else if (selector.startsWith("#")) {
      ids.push(selector.substring(1));
    }
  }
  return { classes, ids };
}
function isDataTable(attr, tables) {
  if (tables === true) {
    return true;
  }
  if (!attr) {
    return false;
  }
  const { classes, ids } = splitClassesAndIds(tables);
  const attrClasses = (attr["class"] || "").split(" ");
  const attrIds = (attr["id"] || "").split(" ");
  return attrClasses.some((x) => classes.includes(x)) || attrIds.some((x) => ids.includes(x));
}
function formatTable(elem, walk, builder, formatOptions) {
  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);
}
function formatBlock(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
}
function formatDataTable(elem, walk, builder, formatOptions) {
  builder.openTable();
  elem.children.forEach(walkTable);
  builder.closeTable({
    tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),
    leadingLineBreaks: formatOptions.leadingLineBreaks,
    trailingLineBreaks: formatOptions.trailingLineBreaks
  });
  function formatCell(cellNode) {
    const colspan = +get(cellNode, ["attribs", "colspan"]) || 1;
    const rowspan = +get(cellNode, ["attribs", "rowspan"]) || 1;
    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
    walk(cellNode.children, builder);
    builder.closeTableCell({ colspan, rowspan });
  }
  function walkTable(elem2) {
    if (elem2.type !== "tag") {
      return;
    }
    const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode) => {
      builder.pushWordTransform((str) => str.toUpperCase());
      formatCell(cellNode);
      builder.popWordTransform();
    } : formatCell;
    switch (elem2.name) {
      case "thead":
      case "tbody":
      case "tfoot":
      case "center":
        elem2.children.forEach(walkTable);
        return;
      case "tr": {
        builder.openTableRow();
        for (const childOfTr of elem2.children) {
          if (childOfTr.type !== "tag") {
            continue;
          }
          switch (childOfTr.name) {
            case "th": {
              formatHeaderCell(childOfTr);
              break;
            }
            case "td": {
              formatCell(childOfTr);
              break;
            }
          }
        }
        builder.closeTableRow();
        break;
      }
    }
  }
}
var textFormatters = Object.freeze({
  __proto__: null,
  anchor: formatAnchor,
  blockquote: formatBlockquote,
  dataTable: formatDataTable,
  heading: formatHeading,
  horizontalLine: formatHorizontalLine,
  image: formatImage,
  lineBreak: formatLineBreak,
  orderedList: formatOrderedList,
  paragraph: formatParagraph,
  pre: formatPre,
  table: formatTable,
  unorderedList: formatUnorderedList,
  wbr: formatWbr
});
var DEFAULT_OPTIONS = {
  baseElements: {
    selectors: ["body"],
    orderBy: "selectors",
    // 'selectors' | 'occurrence'
    returnDomByDefault: true
  },
  decodeEntities: true,
  encodeCharacters: {},
  formatters: {},
  limits: {
    ellipsis: "...",
    maxBaseElements: void 0,
    maxChildNodes: void 0,
    maxDepth: void 0,
    maxInputLength: 1 << 24
    // 16_777_216
  },
  longWordSplit: {
    forceWrapOnLimit: false,
    wrapCharacters: []
  },
  preserveNewlines: false,
  selectors: [
    { selector: "*", format: "inline" },
    {
      selector: "a",
      format: "anchor",
      options: {
        baseUrl: null,
        hideLinkHrefIfSameAsText: false,
        ignoreHref: false,
        linkBrackets: ["[", "]"],
        noAnchorUrl: true
      }
    },
    { selector: "article", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "aside", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "blockquote",
      format: "blockquote",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
    },
    { selector: "br", format: "lineBreak" },
    { selector: "div", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "footer", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "form", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "h1", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h2", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h3", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h4", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h5", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h6", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "header", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "hr",
      format: "horizontalLine",
      options: { leadingLineBreaks: 2, length: void 0, trailingLineBreaks: 2 }
    },
    {
      selector: "img",
      format: "image",
      options: { baseUrl: null, linkBrackets: ["[", "]"] }
    },
    { selector: "main", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "nav", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "ol",
      format: "orderedList",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "p", format: "paragraph", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "pre", format: "pre", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "section", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "table",
      format: "table",
      options: {
        colSpacing: 3,
        leadingLineBreaks: 2,
        maxColumnWidth: 60,
        rowSpacing: 0,
        trailingLineBreaks: 2,
        uppercaseHeaderCells: true
      }
    },
    {
      selector: "ul",
      format: "unorderedList",
      options: { itemPrefix: " * ", leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "wbr", format: "wbr" }
  ],
  tables: [],
  // deprecated
  whitespaceCharacters: " 	\r\n\f",
  wordwrap: 80
};
var concatMerge = (acc, src, options) => [...acc, ...src];
var overwriteMerge = (acc, src, options) => [...src];
var selectorsMerge = (acc, src, options) => acc.some((s) => typeof s === "object") ? concatMerge(acc, src) : overwriteMerge(acc, src);
function compile(options = {}) {
  options = (0, import_deepmerge.default)(
    DEFAULT_OPTIONS,
    options,
    {
      arrayMerge: overwriteMerge,
      customMerge: (key) => key === "selectors" ? selectorsMerge : void 0
    }
  );
  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);
  options.selectors = mergeDuplicatesPreferLast(options.selectors, (s) => s.selector);
  handleDeprecatedOptions(options);
  return compile$1(options);
}
function convert(html, options = {}, metadata = void 0) {
  return compile(options)(html, metadata);
}
function handleDeprecatedOptions(options) {
  if (options.tags) {
    const tagDefinitions = Object.entries(options.tags).map(
      ([selector, definition]) => ({ ...definition, selector: selector || "*" })
    );
    options.selectors.push(...tagDefinitions);
    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s) => s.selector);
  }
  function set(obj, path, value) {
    const valueKey = path.pop();
    for (const key of path) {
      let nested = obj[key];
      if (!nested) {
        nested = {};
        obj[key] = nested;
      }
      obj = nested;
    }
    obj[valueKey] = value;
  }
  if (options["baseElement"]) {
    const baseElement = options["baseElement"];
    set(
      options,
      ["baseElements", "selectors"],
      Array.isArray(baseElement) ? baseElement : [baseElement]
    );
  }
  if (options["returnDomByDefault"] !== void 0) {
    set(options, ["baseElements", "returnDomByDefault"], options["returnDomByDefault"]);
  }
  for (const definition of options.selectors) {
    if (definition.format === "anchor" && get(definition, ["options", "noLinkBrackets"])) {
      set(definition, ["options", "linkBrackets"], false);
    }
  }
}

// node_modules/@react-email/components/node_modules/@react-email/render/dist/index.mjs
var import_pretty = __toESM(require_pretty(), 1);
var import_pretty2 = __toESM(require_pretty(), 1);
var import_server = __toESM(require_server_browser(), 1);
var render2 = (component, options) => {
  if (options == null ? void 0 : options.plainText) {
    return renderAsPlainText(component, options);
  }
  const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
  const markup = ReactDomServer.renderToStaticMarkup(component);
  const document2 = `${doctype}${markup}`;
  if (options && options.pretty) {
    return (0, import_pretty.default)(document2);
  }
  return document2;
};
var renderAsPlainText = (component, _options) => {
  return convert(ReactDomServer.renderToStaticMarkup(component), {
    selectors: [
      { selector: "img", format: "skip" },
      { selector: "#__react-email-preview", format: "skip" }
    ]
  });
};
async function renderToString(children) {
  const stream = await (0, import_server.renderToReadableStream)(children);
  const html = await readableStreamToString(
    stream
  );
  return html.replace(/^<!DOCTYPE html>/, "").replace(/<!-- -->/g, "");
}
async function readableStreamToString(readableStream) {
  let result = "";
  const decoder = new TextDecoder();
  for await (const chunk of readableStream) {
    result += decoder.decode(chunk);
  }
  return result;
}
var renderAsync = async (component, options) => {
  const markup = typeof import_server.renderToStaticMarkup === "undefined" ? await renderToString(component) : (0, import_server.renderToStaticMarkup)(component);
  if (options == null ? void 0 : options.plainText) {
    return convert(markup, {
      selectors: [
        { selector: "img", format: "skip" },
        { selector: "#__react-email-preview", format: "skip" }
      ]
    });
  }
  const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
  const document2 = `${doctype}${markup}`;
  if (options == null ? void 0 : options.pretty) {
    return (0, import_pretty2.default)(document2);
  }
  return document2;
};

// node_modules/@react-email/row/dist/index.mjs
var React11 = __toESM(require_react(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var Row = React11.forwardRef(
  ({ children, style, ...props }, forwardedRef) => {
    return (0, import_jsx_runtime13.jsx)(
      "table",
      {
        align: "center",
        width: "100%",
        ...props,
        ref: forwardedRef,
        "data-id": "react-email-row",
        style,
        role: "presentation",
        cellSpacing: "0",
        cellPadding: "0",
        border: 0,
        children: (0, import_jsx_runtime13.jsx)("tbody", { style: { width: "100%" }, children: (0, import_jsx_runtime13.jsx)("tr", { style: { width: "100%" }, children }) })
      }
    );
  }
);
Row.displayName = "Row";

// node_modules/@react-email/section/dist/index.mjs
var React12 = __toESM(require_react(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var Section = React12.forwardRef(
  ({ children, style, ...props }, forwardedRef) => {
    return (0, import_jsx_runtime14.jsx)(
      "table",
      {
        align: "center",
        width: "100%",
        ...props,
        ref: forwardedRef,
        "data-id": "react-email-section",
        style,
        border: 0,
        cellPadding: "0",
        cellSpacing: "0",
        role: "presentation",
        children: (0, import_jsx_runtime14.jsx)("tbody", { children: (0, import_jsx_runtime14.jsx)("tr", { children: (0, import_jsx_runtime14.jsx)("td", { children }) }) })
      }
    );
  }
);
Section.displayName = "Section";

// node_modules/@react-email/tailwind/dist/index.mjs
var React13 = __toESM(require_react(), 1);
var import_server2 = __toESM(require_server_browser(), 1);

// node_modules/html-react-parser/index.mjs
var import_index = __toESM(require_html_react_parser(), 1);
var domToReact = import_index.default.domToReact;
var htmlToDOM = import_index.default.htmlToDOM;
var attributesToProps = import_index.default.attributesToProps;
var Comment3 = import_index.default.Comment;
var Element2 = import_index.default.Element;
var ProcessingInstruction2 = import_index.default.ProcessingInstruction;
var Text3 = import_index.default.Text;
var html_react_parser_default = import_index.default;

// node_modules/tw-to-css/dist/index.mjs.js
var kp = Object.create;
var gr = Object.defineProperty;
var Cp = Object.getOwnPropertyDescriptor;
var Ep = Object.getOwnPropertyNames;
var Ap = Object.getPrototypeOf;
var Op = Object.prototype.hasOwnProperty;
var Ye = (t, e) => () => (t && (e = t(t = 0)), e);
var S = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var dt = (t, e) => {
  for (var r in e)
    gr(t, r, { get: e[r], enumerable: true });
};
var Oa = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of Ep(e))
      !Op.call(t, i) && i !== r && gr(t, i, { get: () => e[i], enumerable: !(n = Cp(e, i)) || n.enumerable });
  return t;
};
var Y = (t, e, r) => (r = t != null ? kp(Ap(t)) : {}, Oa(e || !t || !t.__esModule ? gr(r, "default", { value: t, enumerable: true }) : r, t));
var _e = (t) => Oa(gr({}, "__esModule", { value: true }), t);
var Pa;
var Ta = Ye(() => {
  Pa = `*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:theme("borderColor.DEFAULT",currentColor)}:before,:after{--tw-content: ""}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:theme("fontFamily.sans",ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:theme("fontFamily.sans[1].fontFeatureSettings",normal)}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:theme("fontFamily.mono",ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:theme("colors.gray.400",#9ca3af)}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}
`;
});
var Ra = {};
dt(Ra, { default: () => ht });
var ht;
var yr = Ye(() => {
  Ta();
  ht = { readFileSync: () => Pa };
});
var Da = S((mb, Ia) => {
  "use strict";
  var qn = class {
    constructor(e = {}) {
      if (!(e.maxSize && e.maxSize > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      this.maxSize = e.maxSize, this.onEviction = e.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
    }
    _set(e, r) {
      if (this.cache.set(e, r), this._size++, this._size >= this.maxSize) {
        if (this._size = 0, typeof this.onEviction == "function")
          for (let [n, i] of this.oldCache.entries())
            this.onEviction(n, i);
        this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map();
      }
    }
    get(e) {
      if (this.cache.has(e))
        return this.cache.get(e);
      if (this.oldCache.has(e)) {
        let r = this.oldCache.get(e);
        return this.oldCache.delete(e), this._set(e, r), r;
      }
    }
    set(e, r) {
      return this.cache.has(e) ? this.cache.set(e, r) : this._set(e, r), this;
    }
    has(e) {
      return this.cache.has(e) || this.oldCache.has(e);
    }
    peek(e) {
      if (this.cache.has(e))
        return this.cache.get(e);
      if (this.oldCache.has(e))
        return this.oldCache.get(e);
    }
    delete(e) {
      let r = this.cache.delete(e);
      return r && this._size--, this.oldCache.delete(e) || r;
    }
    clear() {
      this.cache.clear(), this.oldCache.clear(), this._size = 0;
    }
    *keys() {
      for (let [e] of this)
        yield e;
    }
    *values() {
      for (let [, e] of this)
        yield e;
    }
    *[Symbol.iterator]() {
      for (let e of this.cache)
        yield e;
      for (let e of this.oldCache) {
        let [r] = e;
        this.cache.has(r) || (yield e);
      }
    }
    get size() {
      let e = 0;
      for (let r of this.oldCache.keys())
        this.cache.has(r) || e++;
      return Math.min(this._size + e, this.maxSize);
    }
  };
  Ia.exports = qn;
});
var Fa = {};
dt(Fa, { default: () => zn });
var zn;
var Vn = Ye(() => {
  zn = { yellow: (t) => t };
});
var Wn = S(() => {
});
var vr = S((bb, $a) => {
  "use strict";
  var Na = (Vn(), _e(Fa)), qa = Wn(), Ue = class extends Error {
    constructor(e, r, n, i, s, a) {
      super(e), this.name = "CssSyntaxError", this.reason = e, s && (this.file = s), i && (this.source = i), a && (this.plugin = a), typeof r < "u" && typeof n < "u" && (typeof r == "number" ? (this.line = r, this.column = n) : (this.line = r.line, this.column = r.column, this.endLine = n.line, this.endColumn = n.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, Ue);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(e) {
      if (!this.source)
        return "";
      let r = this.source;
      e == null && (e = Na.isColorSupported), qa && e && (r = qa(r));
      let n = r.split(/\r?\n/), i = Math.max(this.line - 3, 0), s = Math.min(this.line + 2, n.length), a = String(s).length, o2, l;
      if (e) {
        let { bold: u, red: f, gray: p } = Na.createColors(true);
        o2 = (c) => u(f(c)), l = (c) => p(c);
      } else
        o2 = l = (u) => u;
      return n.slice(i, s).map((u, f) => {
        let p = i + 1 + f, c = " " + (" " + p).slice(-a) + " | ";
        if (p === this.line) {
          let d = l(c.replace(/\d/g, " ")) + u.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return o2(">") + l(c) + u + `
 ` + d + o2("^");
        }
        return " " + l(c) + u;
      }).join(`
`);
    }
    toString() {
      let e = this.showSourceCode();
      return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
    }
  };
  $a.exports = Ue;
  Ue.default = Ue;
});
var br = S((xb, Bn) => {
  "use strict";
  Bn.exports.isClean = Symbol("isClean");
  Bn.exports.my = Symbol("my");
});
var Gn = S((Sb, ja) => {
  "use strict";
  var Ua = { colon: ": ", indent: "    ", beforeDecl: `
`, beforeRule: `
`, beforeOpen: " ", beforeClose: `
`, beforeComment: `
`, after: `
`, emptyBody: "", commentLeft: " ", commentRight: " ", semicolon: false };
  function Ip(t) {
    return t[0].toUpperCase() + t.slice(1);
  }
  var gt = class {
    constructor(e) {
      this.builder = e;
    }
    stringify(e, r) {
      if (!this[e.type])
        throw new Error("Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier.");
      this[e.type](e, r);
    }
    document(e) {
      this.body(e);
    }
    root(e) {
      this.body(e), e.raws.after && this.builder(e.raws.after);
    }
    comment(e) {
      let r = this.raw(e, "left", "commentLeft"), n = this.raw(e, "right", "commentRight");
      this.builder("/*" + r + e.text + n + "*/", e);
    }
    decl(e, r) {
      let n = this.raw(e, "between", "colon"), i = e.prop + n + this.rawValue(e, "value");
      e.important && (i += e.raws.important || " !important"), r && (i += ";"), this.builder(i, e);
    }
    rule(e) {
      this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
    }
    atrule(e, r) {
      let n = "@" + e.name, i = e.params ? this.rawValue(e, "params") : "";
      if (typeof e.raws.afterName < "u" ? n += e.raws.afterName : i && (n += " "), e.nodes)
        this.block(e, n + i);
      else {
        let s = (e.raws.between || "") + (r ? ";" : "");
        this.builder(n + i + s, e);
      }
    }
    body(e) {
      let r = e.nodes.length - 1;
      for (; r > 0 && e.nodes[r].type === "comment"; )
        r -= 1;
      let n = this.raw(e, "semicolon");
      for (let i = 0; i < e.nodes.length; i++) {
        let s = e.nodes[i], a = this.raw(s, "before");
        a && this.builder(a), this.stringify(s, r !== i || n);
      }
    }
    block(e, r) {
      let n = this.raw(e, "between", "beforeOpen");
      this.builder(r + n + "{", e, "start");
      let i;
      e.nodes && e.nodes.length ? (this.body(e), i = this.raw(e, "after")) : i = this.raw(e, "after", "emptyBody"), i && this.builder(i), this.builder("}", e, "end");
    }
    raw(e, r, n) {
      let i;
      if (n || (n = r), r && (i = e.raws[r], typeof i < "u"))
        return i;
      let s = e.parent;
      if (n === "before" && (!s || s.type === "root" && s.first === e || s && s.type === "document"))
        return "";
      if (!s)
        return Ua[n];
      let a = e.root();
      if (a.rawCache || (a.rawCache = {}), typeof a.rawCache[n] < "u")
        return a.rawCache[n];
      if (n === "before" || n === "after")
        return this.beforeAfter(e, n);
      {
        let o2 = "raw" + Ip(n);
        this[o2] ? i = this[o2](a, e) : a.walk((l) => {
          if (i = l.raws[r], typeof i < "u")
            return false;
        });
      }
      return typeof i > "u" && (i = Ua[n]), a.rawCache[n] = i, i;
    }
    rawSemicolon(e) {
      let r;
      return e.walk((n) => {
        if (n.nodes && n.nodes.length && n.last.type === "decl" && (r = n.raws.semicolon, typeof r < "u"))
          return false;
      }), r;
    }
    rawEmptyBody(e) {
      let r;
      return e.walk((n) => {
        if (n.nodes && n.nodes.length === 0 && (r = n.raws.after, typeof r < "u"))
          return false;
      }), r;
    }
    rawIndent(e) {
      if (e.raws.indent)
        return e.raws.indent;
      let r;
      return e.walk((n) => {
        let i = n.parent;
        if (i && i !== e && i.parent && i.parent === e && typeof n.raws.before < "u") {
          let s = n.raws.before.split(`
`);
          return r = s[s.length - 1], r = r.replace(/\S/g, ""), false;
        }
      }), r;
    }
    rawBeforeComment(e, r) {
      let n;
      return e.walkComments((i) => {
        if (typeof i.raws.before < "u")
          return n = i.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), false;
      }), typeof n > "u" ? n = this.raw(r, null, "beforeDecl") : n && (n = n.replace(/\S/g, "")), n;
    }
    rawBeforeDecl(e, r) {
      let n;
      return e.walkDecls((i) => {
        if (typeof i.raws.before < "u")
          return n = i.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), false;
      }), typeof n > "u" ? n = this.raw(r, null, "beforeRule") : n && (n = n.replace(/\S/g, "")), n;
    }
    rawBeforeRule(e) {
      let r;
      return e.walk((n) => {
        if (n.nodes && (n.parent !== e || e.first !== n) && typeof n.raws.before < "u")
          return r = n.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), false;
      }), r && (r = r.replace(/\S/g, "")), r;
    }
    rawBeforeClose(e) {
      let r;
      return e.walk((n) => {
        if (n.nodes && n.nodes.length > 0 && typeof n.raws.after < "u")
          return r = n.raws.after, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), false;
      }), r && (r = r.replace(/\S/g, "")), r;
    }
    rawBeforeOpen(e) {
      let r;
      return e.walk((n) => {
        if (n.type !== "decl" && (r = n.raws.between, typeof r < "u"))
          return false;
      }), r;
    }
    rawColon(e) {
      let r;
      return e.walkDecls((n) => {
        if (typeof n.raws.between < "u")
          return r = n.raws.between.replace(/[^\s:]/g, ""), false;
      }), r;
    }
    beforeAfter(e, r) {
      let n;
      e.type === "decl" ? n = this.raw(e, null, "beforeDecl") : e.type === "comment" ? n = this.raw(e, null, "beforeComment") : r === "before" ? n = this.raw(e, null, "beforeRule") : n = this.raw(e, null, "beforeClose");
      let i = e.parent, s = 0;
      for (; i && i.type !== "root"; )
        s += 1, i = i.parent;
      if (n.includes(`
`)) {
        let a = this.raw(e, null, "indent");
        if (a.length)
          for (let o2 = 0; o2 < s; o2++)
            n += a;
      }
      return n;
    }
    rawValue(e, r) {
      let n = e[r], i = e.raws[r];
      return i && i.value === n ? i.raw : n;
    }
  };
  ja.exports = gt;
  gt.default = gt;
});
var yt = S((kb, za) => {
  "use strict";
  var Dp = Gn();
  function Yn(t, e) {
    new Dp(e).stringify(t);
  }
  za.exports = Yn;
  Yn.default = Yn;
});
var vt = S((Cb, Va) => {
  "use strict";
  var { isClean: xr, my: Mp } = br(), Lp = vr(), Fp = Gn(), Np = yt();
  function Hn(t, e) {
    let r = new t.constructor();
    for (let n in t) {
      if (!Object.prototype.hasOwnProperty.call(t, n) || n === "proxyCache")
        continue;
      let i = t[n], s = typeof i;
      n === "parent" && s === "object" ? e && (r[n] = e) : n === "source" ? r[n] = i : Array.isArray(i) ? r[n] = i.map((a) => Hn(a, r)) : (s === "object" && i !== null && (i = Hn(i)), r[n] = i);
    }
    return r;
  }
  var wt = class {
    constructor(e = {}) {
      this.raws = {}, this[xr] = false, this[Mp] = true;
      for (let r in e)
        if (r === "nodes") {
          this.nodes = [];
          for (let n of e[r])
            typeof n.clone == "function" ? this.append(n.clone()) : this.append(n);
        } else
          this[r] = e[r];
    }
    error(e, r = {}) {
      if (this.source) {
        let { start: n, end: i } = this.rangeBy(r);
        return this.source.input.error(e, { line: n.line, column: n.column }, { line: i.line, column: i.column }, r);
      }
      return new Lp(e);
    }
    warn(e, r, n) {
      let i = { node: this };
      for (let s in n)
        i[s] = n[s];
      return e.warn(r, i);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    toString(e = Np) {
      e.stringify && (e = e.stringify);
      let r = "";
      return e(this, (n) => {
        r += n;
      }), r;
    }
    assign(e = {}) {
      for (let r in e)
        this[r] = e[r];
      return this;
    }
    clone(e = {}) {
      let r = Hn(this);
      for (let n in e)
        r[n] = e[n];
      return r;
    }
    cloneBefore(e = {}) {
      let r = this.clone(e);
      return this.parent.insertBefore(this, r), r;
    }
    cloneAfter(e = {}) {
      let r = this.clone(e);
      return this.parent.insertAfter(this, r), r;
    }
    replaceWith(...e) {
      if (this.parent) {
        let r = this, n = false;
        for (let i of e)
          i === this ? n = true : n ? (this.parent.insertAfter(r, i), r = i) : this.parent.insertBefore(r, i);
        n || this.remove();
      }
      return this;
    }
    next() {
      if (!this.parent)
        return;
      let e = this.parent.index(this);
      return this.parent.nodes[e + 1];
    }
    prev() {
      if (!this.parent)
        return;
      let e = this.parent.index(this);
      return this.parent.nodes[e - 1];
    }
    before(e) {
      return this.parent.insertBefore(this, e), this;
    }
    after(e) {
      return this.parent.insertAfter(this, e), this;
    }
    root() {
      let e = this;
      for (; e.parent && e.parent.type !== "document"; )
        e = e.parent;
      return e;
    }
    raw(e, r) {
      return new Fp().raw(this, e, r);
    }
    cleanRaws(e) {
      delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
    }
    toJSON(e, r) {
      let n = {}, i = r == null;
      r = r || /* @__PURE__ */ new Map();
      let s = 0;
      for (let a in this) {
        if (!Object.prototype.hasOwnProperty.call(this, a) || a === "parent" || a === "proxyCache")
          continue;
        let o2 = this[a];
        if (Array.isArray(o2))
          n[a] = o2.map((l) => typeof l == "object" && l.toJSON ? l.toJSON(null, r) : l);
        else if (typeof o2 == "object" && o2.toJSON)
          n[a] = o2.toJSON(null, r);
        else if (a === "source") {
          let l = r.get(o2.input);
          l == null && (l = s, r.set(o2.input, s), s++), n[a] = { inputId: l, start: o2.start, end: o2.end };
        } else
          n[a] = o2;
      }
      return i && (n.inputs = [...r.keys()].map((a) => a.toJSON())), n;
    }
    positionInside(e) {
      let r = this.toString(), n = this.source.start.column, i = this.source.start.line;
      for (let s = 0; s < e; s++)
        r[s] === `
` ? (n = 1, i += 1) : n += 1;
      return { line: i, column: n };
    }
    positionBy(e) {
      let r = this.source.start;
      if (e.index)
        r = this.positionInside(e.index);
      else if (e.word) {
        let n = this.toString().indexOf(e.word);
        n !== -1 && (r = this.positionInside(n));
      }
      return r;
    }
    rangeBy(e) {
      let r = { line: this.source.start.line, column: this.source.start.column }, n = this.source.end ? { line: this.source.end.line, column: this.source.end.column + 1 } : { line: r.line, column: r.column + 1 };
      if (e.word) {
        let i = this.toString().indexOf(e.word);
        i !== -1 && (r = this.positionInside(i), n = this.positionInside(i + e.word.length));
      } else
        e.start ? r = { line: e.start.line, column: e.start.column } : e.index && (r = this.positionInside(e.index)), e.end ? n = { line: e.end.line, column: e.end.column } : e.endIndex ? n = this.positionInside(e.endIndex) : e.index && (n = this.positionInside(e.index + 1));
      return (n.line < r.line || n.line === r.line && n.column <= r.column) && (n = { line: r.line, column: r.column + 1 }), { start: r, end: n };
    }
    getProxyProcessor() {
      return { set(e, r, n) {
        return e[r] === n || (e[r] = n, (r === "prop" || r === "value" || r === "name" || r === "params" || r === "important" || r === "text") && e.markDirty()), true;
      }, get(e, r) {
        return r === "proxyOf" ? e : r === "root" ? () => e.root().toProxy() : e[r];
      } };
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    addToError(e) {
      if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
        let r = this.source;
        e.stack = e.stack.replace(/\n\s{4}at /, `$&${r.input.from}:${r.start.line}:${r.start.column}$&`);
      }
      return e;
    }
    markDirty() {
      if (this[xr]) {
        this[xr] = false;
        let e = this;
        for (; e = e.parent; )
          e[xr] = false;
      }
    }
    get proxyOf() {
      return this;
    }
  };
  Va.exports = wt;
  wt.default = wt;
});
var xt = S((Eb, Wa) => {
  "use strict";
  var qp = vt(), bt = class extends qp {
    constructor(e) {
      e && typeof e.value < "u" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }), super(e), this.type = "decl";
    }
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
  };
  Wa.exports = bt;
  bt.default = bt;
});
var Sr = S(() => {
});
var St = {};
dt(St, { join: () => Qn });
var Qn;
var kt = Ye(() => {
  Qn = () => "";
});
var Jn = {};
dt(Jn, { default: () => $p });
var $p;
var Xn = Ye(() => {
  $p = null;
});
var Ga = S((_b, Ba) => {
  var Up = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", jp = (t, e = 21) => (r = e) => {
    let n = "", i = r;
    for (; i--; )
      n += t[Math.random() * t.length | 0];
    return n;
  }, zp = (t = 21) => {
    let e = "", r = t;
    for (; r--; )
      e += Up[Math.random() * 64 | 0];
    return e;
  };
  Ba.exports = { nanoid: zp, customAlphabet: jp };
});
var Zn = S((Tb, Qa) => {
  "use strict";
  var { SourceMapConsumer: Ya, SourceMapGenerator: Ha } = Sr(), { existsSync: Vp, readFileSync: Wp } = (yr(), _e(Ra)), { dirname: Kn, join: Bp } = (kt(), _e(St));
  function Gp(t) {
    return Buffer ? Buffer.from(t, "base64").toString() : window.atob(t);
  }
  var Ct = class {
    constructor(e, r) {
      if (r.map === false)
        return;
      this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
      let n = r.map ? r.map.prev : void 0, i = this.loadMap(r.from, n);
      !this.mapFile && r.from && (this.mapFile = r.from), this.mapFile && (this.root = Kn(this.mapFile)), i && (this.text = i);
    }
    consumer() {
      return this.consumerCache || (this.consumerCache = new Ya(this.text)), this.consumerCache;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
    startWith(e, r) {
      return e ? e.substr(0, r.length) === r : false;
    }
    getAnnotationURL(e) {
      return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    loadAnnotation(e) {
      let r = e.match(/\/\*\s*# sourceMappingURL=/gm);
      if (!r)
        return;
      let n = e.lastIndexOf(r.pop()), i = e.indexOf("*/", n);
      n > -1 && i > -1 && (this.annotation = this.getAnnotationURL(e.substring(n, i)));
    }
    decodeInline(e) {
      let r = /^data:application\/json;charset=utf-?8;base64,/, n = /^data:application\/json;base64,/, i = /^data:application\/json;charset=utf-?8,/, s = /^data:application\/json,/;
      if (i.test(e) || s.test(e))
        return decodeURIComponent(e.substr(RegExp.lastMatch.length));
      if (r.test(e) || n.test(e))
        return Gp(e.substr(RegExp.lastMatch.length));
      let a = e.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + a);
    }
    loadFile(e) {
      if (this.root = Kn(e), Vp(e))
        return this.mapFile = e, Wp(e, "utf-8").toString().trim();
    }
    loadMap(e, r) {
      if (r === false)
        return false;
      if (r) {
        if (typeof r == "string")
          return r;
        if (typeof r == "function") {
          let n = r(e);
          if (n) {
            let i = this.loadFile(n);
            if (!i)
              throw new Error("Unable to load previous source map: " + n.toString());
            return i;
          }
        } else {
          if (r instanceof Ya)
            return Ha.fromSourceMap(r).toString();
          if (r instanceof Ha)
            return r.toString();
          if (this.isMap(r))
            return JSON.stringify(r);
          throw new Error("Unsupported previous source map format: " + r.toString());
        }
      } else {
        if (this.inline)
          return this.decodeInline(this.annotation);
        if (this.annotation) {
          let n = this.annotation;
          return e && (n = Bp(Kn(e), n)), this.loadFile(n);
        }
      }
    }
    isMap(e) {
      return typeof e != "object" ? false : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
    }
  };
  Qa.exports = Ct;
  Ct.default = Ct;
});
var Et = S((Pb, Za) => {
  "use strict";
  var { SourceMapConsumer: Yp, SourceMapGenerator: Hp } = Sr(), { fileURLToPath: Ja, pathToFileURL: kr } = (Xn(), _e(Jn)), { resolve: ri, isAbsolute: ni } = (kt(), _e(St)), { nanoid: Qp } = Ga(), ei = Wn(), Xa = vr(), Jp = Zn(), ti = Symbol("fromOffsetCache"), Xp = Boolean(Yp && Hp), Ka = Boolean(ri && ni), He = class {
    constructor(e, r = {}) {
      if (e === null || typeof e > "u" || typeof e == "object" && !e.toString)
        throw new Error(`PostCSS received ${e} instead of CSS string`);
      if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, r.from && (!Ka || /^\w+:\/\//.test(r.from) || ni(r.from) ? this.file = r.from : this.file = ri(r.from)), Ka && Xp) {
        let n = new Jp(this.css, r);
        if (n.text) {
          this.map = n;
          let i = n.consumer().file;
          !this.file && i && (this.file = this.mapResolve(i));
        }
      }
      this.file || (this.id = "<input css " + Qp(6) + ">"), this.map && (this.map.file = this.from);
    }
    fromOffset(e) {
      let r, n;
      if (this[ti])
        n = this[ti];
      else {
        let s = this.css.split(`
`);
        n = new Array(s.length);
        let a = 0;
        for (let o2 = 0, l = s.length; o2 < l; o2++)
          n[o2] = a, a += s[o2].length + 1;
        this[ti] = n;
      }
      r = n[n.length - 1];
      let i = 0;
      if (e >= r)
        i = n.length - 1;
      else {
        let s = n.length - 2, a;
        for (; i < s; )
          if (a = i + (s - i >> 1), e < n[a])
            s = a - 1;
          else if (e >= n[a + 1])
            i = a + 1;
          else {
            i = a;
            break;
          }
      }
      return { line: i + 1, col: e - n[i] + 1 };
    }
    error(e, r, n, i = {}) {
      let s, a, o2;
      if (r && typeof r == "object") {
        let u = r, f = n;
        if (typeof u.offset == "number") {
          let p = this.fromOffset(u.offset);
          r = p.line, n = p.col;
        } else
          r = u.line, n = u.column;
        if (typeof f.offset == "number") {
          let p = this.fromOffset(f.offset);
          a = p.line, o2 = p.col;
        } else
          a = f.line, o2 = f.column;
      } else if (!n) {
        let u = this.fromOffset(r);
        r = u.line, n = u.col;
      }
      let l = this.origin(r, n, a, o2);
      return l ? s = new Xa(e, l.endLine === void 0 ? l.line : { line: l.line, column: l.column }, l.endLine === void 0 ? l.column : { line: l.endLine, column: l.endColumn }, l.source, l.file, i.plugin) : s = new Xa(e, a === void 0 ? r : { line: r, column: n }, a === void 0 ? n : { line: a, column: o2 }, this.css, this.file, i.plugin), s.input = { line: r, column: n, endLine: a, endColumn: o2, source: this.css }, this.file && (kr && (s.input.url = kr(this.file).toString()), s.input.file = this.file), s;
    }
    origin(e, r, n, i) {
      if (!this.map)
        return false;
      let s = this.map.consumer(), a = s.originalPositionFor({ line: e, column: r });
      if (!a.source)
        return false;
      let o2;
      typeof n == "number" && (o2 = s.originalPositionFor({ line: n, column: i }));
      let l;
      ni(a.source) ? l = kr(a.source) : l = new URL(a.source, this.map.consumer().sourceRoot || kr(this.map.mapFile));
      let u = { url: l.toString(), line: a.line, column: a.column, endLine: o2 && o2.line, endColumn: o2 && o2.column };
      if (l.protocol === "file:")
        if (Ja)
          u.file = Ja(l);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let f = s.sourceContentFor(a.source);
      return f && (u.source = f), u;
    }
    mapResolve(e) {
      return /^\w+:\/\//.test(e) ? e : ri(this.map.consumer().sourceRoot || this.map.root || ".", e);
    }
    get from() {
      return this.file || this.id;
    }
    toJSON() {
      let e = {};
      for (let r of ["hasBOM", "css", "file", "id"])
        this[r] != null && (e[r] = this[r]);
      return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = void 0)), e;
    }
  };
  Za.exports = He;
  He.default = He;
  ei && ei.registerInput && ei.registerInput(He);
});
var si = S((Rb, so) => {
  "use strict";
  var { SourceMapConsumer: to, SourceMapGenerator: Cr } = Sr(), { dirname: Er, resolve: ro, relative: no, sep: io } = (kt(), _e(St)), { pathToFileURL: eo } = (Xn(), _e(Jn)), Kp = Et(), Zp = Boolean(to && Cr), ed = Boolean(Er && ro && no && io), ii = class {
    constructor(e, r, n, i) {
      this.stringify = e, this.mapOpts = n.map || {}, this.root = r, this.opts = n, this.css = i, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
    }
    isMap() {
      return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
    }
    previous() {
      if (!this.previousMaps)
        if (this.previousMaps = [], this.root)
          this.root.walk((e) => {
            if (e.source && e.source.input.map) {
              let r = e.source.input.map;
              this.previousMaps.includes(r) || this.previousMaps.push(r);
            }
          });
        else {
          let e = new Kp(this.css, this.opts);
          e.map && this.previousMaps.push(e.map);
        }
      return this.previousMaps;
    }
    isInline() {
      if (typeof this.mapOpts.inline < "u")
        return this.mapOpts.inline;
      let e = this.mapOpts.annotation;
      return typeof e < "u" && e !== true ? false : this.previous().length ? this.previous().some((r) => r.inline) : true;
    }
    isSourcesContent() {
      return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : true;
    }
    clearAnnotation() {
      if (this.mapOpts.annotation !== false)
        if (this.root) {
          let e;
          for (let r = this.root.nodes.length - 1; r >= 0; r--)
            e = this.root.nodes[r], e.type === "comment" && e.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(r);
        } else
          this.css && (this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, ""));
    }
    setSourcesContent() {
      let e = {};
      if (this.root)
        this.root.walk((r) => {
          if (r.source) {
            let n = r.source.input.from;
            if (n && !e[n]) {
              e[n] = true;
              let i = this.usesFileUrls ? this.toFileUrl(n) : this.toUrl(this.path(n));
              this.map.setSourceContent(i, r.source.input.css);
            }
          }
        });
      else if (this.css) {
        let r = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(r, this.css);
      }
    }
    applyPrevMaps() {
      for (let e of this.previous()) {
        let r = this.toUrl(this.path(e.file)), n = e.root || Er(e.file), i;
        this.mapOpts.sourcesContent === false ? (i = new to(e.text), i.sourcesContent && (i.sourcesContent = i.sourcesContent.map(() => null))) : i = e.consumer(), this.map.applySourceMap(i, r, this.toUrl(this.path(n)));
      }
    }
    isAnnotation() {
      return this.isInline() ? true : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : true;
    }
    toBase64(e) {
      return Buffer ? Buffer.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
    }
    addAnnotation() {
      let e;
      this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
      let r = `
`;
      this.css.includes(`\r
`) && (r = `\r
`), this.css += r + "/*# sourceMappingURL=" + e + " */";
    }
    outputFile() {
      return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
    }
    generateMap() {
      if (this.root)
        this.generateString();
      else if (this.previous().length === 1) {
        let e = this.previous()[0].consumer();
        e.file = this.outputFile(), this.map = Cr.fromSourceMap(e);
      } else
        this.map = new Cr({ file: this.outputFile() }), this.map.addMapping({ source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>", generated: { line: 1, column: 0 }, original: { line: 1, column: 0 } });
      return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
    }
    path(e) {
      if (e.indexOf("<") === 0 || /^\w+:\/\//.test(e) || this.mapOpts.absolute)
        return e;
      let r = this.opts.to ? Er(this.opts.to) : ".";
      return typeof this.mapOpts.annotation == "string" && (r = Er(ro(r, this.mapOpts.annotation))), e = no(r, e), e;
    }
    toUrl(e) {
      return io === "\\" && (e = e.replace(/\\/g, "/")), encodeURI(e).replace(/[#?]/g, encodeURIComponent);
    }
    toFileUrl(e) {
      if (eo)
        return eo(e).toString();
      throw new Error("`map.absolute` option is not available in this PostCSS build");
    }
    sourcePath(e) {
      return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
    }
    generateString() {
      this.css = "", this.map = new Cr({ file: this.outputFile() });
      let e = 1, r = 1, n = "<no source>", i = { source: "", generated: { line: 0, column: 0 }, original: { line: 0, column: 0 } }, s, a;
      this.stringify(this.root, (o2, l, u) => {
        if (this.css += o2, l && u !== "end" && (i.generated.line = e, i.generated.column = r - 1, l.source && l.source.start ? (i.source = this.sourcePath(l), i.original.line = l.source.start.line, i.original.column = l.source.start.column - 1, this.map.addMapping(i)) : (i.source = n, i.original.line = 1, i.original.column = 0, this.map.addMapping(i))), s = o2.match(/\n/g), s ? (e += s.length, a = o2.lastIndexOf(`
`), r = o2.length - a) : r += o2.length, l && u !== "start") {
          let f = l.parent || { raws: {} };
          (!(l.type === "decl" || l.type === "atrule" && !l.nodes) || l !== f.last || f.raws.semicolon) && (l.source && l.source.end ? (i.source = this.sourcePath(l), i.original.line = l.source.end.line, i.original.column = l.source.end.column - 1, i.generated.line = e, i.generated.column = r - 2, this.map.addMapping(i)) : (i.source = n, i.original.line = 1, i.original.column = 0, i.generated.line = e, i.generated.column = r - 1, this.map.addMapping(i)));
        }
      });
    }
    generate() {
      if (this.clearAnnotation(), ed && Zp && this.isMap())
        return this.generateMap();
      {
        let e = "";
        return this.stringify(this.root, (r) => {
          e += r;
        }), [e];
      }
    }
  };
  so.exports = ii;
});
var Ot = S((Ib, ao) => {
  "use strict";
  var td = vt(), At = class extends td {
    constructor(e) {
      super(e), this.type = "comment";
    }
  };
  ao.exports = At;
  At.default = At;
});
var Te = S((Db, go) => {
  "use strict";
  var { isClean: oo, my: lo } = br(), uo = xt(), fo = Ot(), rd = vt(), co, ai, oi, po;
  function ho(t) {
    return t.map((e) => (e.nodes && (e.nodes = ho(e.nodes)), delete e.source, e));
  }
  function mo(t) {
    if (t[oo] = false, t.proxyOf.nodes)
      for (let e of t.proxyOf.nodes)
        mo(e);
  }
  var ae = class extends rd {
    push(e) {
      return e.parent = this, this.proxyOf.nodes.push(e), this;
    }
    each(e) {
      if (!this.proxyOf.nodes)
        return;
      let r = this.getIterator(), n, i;
      for (; this.indexes[r] < this.proxyOf.nodes.length && (n = this.indexes[r], i = e(this.proxyOf.nodes[n], n), i !== false); )
        this.indexes[r] += 1;
      return delete this.indexes[r], i;
    }
    walk(e) {
      return this.each((r, n) => {
        let i;
        try {
          i = e(r, n);
        } catch (s) {
          throw r.addToError(s);
        }
        return i !== false && r.walk && (i = r.walk(e)), i;
      });
    }
    walkDecls(e, r) {
      return r ? e instanceof RegExp ? this.walk((n, i) => {
        if (n.type === "decl" && e.test(n.prop))
          return r(n, i);
      }) : this.walk((n, i) => {
        if (n.type === "decl" && n.prop === e)
          return r(n, i);
      }) : (r = e, this.walk((n, i) => {
        if (n.type === "decl")
          return r(n, i);
      }));
    }
    walkRules(e, r) {
      return r ? e instanceof RegExp ? this.walk((n, i) => {
        if (n.type === "rule" && e.test(n.selector))
          return r(n, i);
      }) : this.walk((n, i) => {
        if (n.type === "rule" && n.selector === e)
          return r(n, i);
      }) : (r = e, this.walk((n, i) => {
        if (n.type === "rule")
          return r(n, i);
      }));
    }
    walkAtRules(e, r) {
      return r ? e instanceof RegExp ? this.walk((n, i) => {
        if (n.type === "atrule" && e.test(n.name))
          return r(n, i);
      }) : this.walk((n, i) => {
        if (n.type === "atrule" && n.name === e)
          return r(n, i);
      }) : (r = e, this.walk((n, i) => {
        if (n.type === "atrule")
          return r(n, i);
      }));
    }
    walkComments(e) {
      return this.walk((r, n) => {
        if (r.type === "comment")
          return e(r, n);
      });
    }
    append(...e) {
      for (let r of e) {
        let n = this.normalize(r, this.last);
        for (let i of n)
          this.proxyOf.nodes.push(i);
      }
      return this.markDirty(), this;
    }
    prepend(...e) {
      e = e.reverse();
      for (let r of e) {
        let n = this.normalize(r, this.first, "prepend").reverse();
        for (let i of n)
          this.proxyOf.nodes.unshift(i);
        for (let i in this.indexes)
          this.indexes[i] = this.indexes[i] + n.length;
      }
      return this.markDirty(), this;
    }
    cleanRaws(e) {
      if (super.cleanRaws(e), this.nodes)
        for (let r of this.nodes)
          r.cleanRaws(e);
    }
    insertBefore(e, r) {
      let n = this.index(e), i = n === 0 ? "prepend" : false, s = this.normalize(r, this.proxyOf.nodes[n], i).reverse();
      n = this.index(e);
      for (let o2 of s)
        this.proxyOf.nodes.splice(n, 0, o2);
      let a;
      for (let o2 in this.indexes)
        a = this.indexes[o2], n <= a && (this.indexes[o2] = a + s.length);
      return this.markDirty(), this;
    }
    insertAfter(e, r) {
      let n = this.index(e), i = this.normalize(r, this.proxyOf.nodes[n]).reverse();
      n = this.index(e);
      for (let a of i)
        this.proxyOf.nodes.splice(n + 1, 0, a);
      let s;
      for (let a in this.indexes)
        s = this.indexes[a], n < s && (this.indexes[a] = s + i.length);
      return this.markDirty(), this;
    }
    removeChild(e) {
      e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
      let r;
      for (let n in this.indexes)
        r = this.indexes[n], r >= e && (this.indexes[n] = r - 1);
      return this.markDirty(), this;
    }
    removeAll() {
      for (let e of this.proxyOf.nodes)
        e.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    replaceValues(e, r, n) {
      return n || (n = r, r = {}), this.walkDecls((i) => {
        r.props && !r.props.includes(i.prop) || r.fast && !i.value.includes(r.fast) || (i.value = i.value.replace(e, n));
      }), this.markDirty(), this;
    }
    every(e) {
      return this.nodes.every(e);
    }
    some(e) {
      return this.nodes.some(e);
    }
    index(e) {
      return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
    }
    get first() {
      if (!!this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (!!this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
    normalize(e, r) {
      if (typeof e == "string")
        e = ho(co(e).nodes);
      else if (Array.isArray(e)) {
        e = e.slice(0);
        for (let i of e)
          i.parent && i.parent.removeChild(i, "ignore");
      } else if (e.type === "root" && this.type !== "document") {
        e = e.nodes.slice(0);
        for (let i of e)
          i.parent && i.parent.removeChild(i, "ignore");
      } else if (e.type)
        e = [e];
      else if (e.prop) {
        if (typeof e.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof e.value != "string" && (e.value = String(e.value)), e = [new uo(e)];
      } else if (e.selector)
        e = [new ai(e)];
      else if (e.name)
        e = [new oi(e)];
      else if (e.text)
        e = [new fo(e)];
      else
        throw new Error("Unknown node type in node creation");
      return e.map((i) => (i[lo] || ae.rebuild(i), i = i.proxyOf, i.parent && i.parent.removeChild(i), i[oo] && mo(i), typeof i.raws.before > "u" && r && typeof r.raws.before < "u" && (i.raws.before = r.raws.before.replace(/\S/g, "")), i.parent = this.proxyOf, i));
    }
    getProxyProcessor() {
      return { set(e, r, n) {
        return e[r] === n || (e[r] = n, (r === "name" || r === "params" || r === "selector") && e.markDirty()), true;
      }, get(e, r) {
        return r === "proxyOf" ? e : e[r] ? r === "each" || typeof r == "string" && r.startsWith("walk") ? (...n) => e[r](...n.map((i) => typeof i == "function" ? (s, a) => i(s.toProxy(), a) : i)) : r === "every" || r === "some" ? (n) => e[r]((i, ...s) => n(i.toProxy(), ...s)) : r === "root" ? () => e.root().toProxy() : r === "nodes" ? e.nodes.map((n) => n.toProxy()) : r === "first" || r === "last" ? e[r].toProxy() : e[r] : e[r];
      } };
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let e = this.lastEach;
      return this.indexes[e] = 0, e;
    }
  };
  ae.registerParse = (t) => {
    co = t;
  };
  ae.registerRule = (t) => {
    ai = t;
  };
  ae.registerAtRule = (t) => {
    oi = t;
  };
  ae.registerRoot = (t) => {
    po = t;
  };
  go.exports = ae;
  ae.default = ae;
  ae.rebuild = (t) => {
    t.type === "atrule" ? Object.setPrototypeOf(t, oi.prototype) : t.type === "rule" ? Object.setPrototypeOf(t, ai.prototype) : t.type === "decl" ? Object.setPrototypeOf(t, uo.prototype) : t.type === "comment" ? Object.setPrototypeOf(t, fo.prototype) : t.type === "root" && Object.setPrototypeOf(t, po.prototype), t[lo] = true, t.nodes && t.nodes.forEach((e) => {
      ae.rebuild(e);
    });
  };
});
var Ar = S((Mb, vo) => {
  "use strict";
  var nd = Te(), yo, wo, je = class extends nd {
    constructor(e) {
      super({ type: "document", ...e }), this.nodes || (this.nodes = []);
    }
    toResult(e = {}) {
      return new yo(new wo(), this, e).stringify();
    }
  };
  je.registerLazyResult = (t) => {
    yo = t;
  };
  je.registerProcessor = (t) => {
    wo = t;
  };
  vo.exports = je;
  je.default = je;
});
var li = S((Lb, xo) => {
  "use strict";
  var bo = {};
  xo.exports = function(e) {
    bo[e] || (bo[e] = true, typeof console < "u" && console.warn && console.warn(e));
  };
});
var ui = S((Fb, So) => {
  "use strict";
  var _t = class {
    constructor(e, r = {}) {
      if (this.type = "warning", this.text = e, r.node && r.node.source) {
        let n = r.node.rangeBy(r);
        this.line = n.start.line, this.column = n.start.column, this.endLine = n.end.line, this.endColumn = n.end.column;
      }
      for (let n in r)
        this[n] = r[n];
    }
    toString() {
      return this.node ? this.node.error(this.text, { plugin: this.plugin, index: this.index, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  };
  So.exports = _t;
  _t.default = _t;
});
var Or = S((Nb, ko) => {
  "use strict";
  var id = ui(), Tt = class {
    constructor(e, r, n) {
      this.processor = e, this.messages = [], this.root = r, this.opts = n, this.css = void 0, this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(e, r = {}) {
      r.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (r.plugin = this.lastPlugin.postcssPlugin);
      let n = new id(e, r);
      return this.messages.push(n), n;
    }
    warnings() {
      return this.messages.filter((e) => e.type === "warning");
    }
    get content() {
      return this.css;
    }
  };
  ko.exports = Tt;
  Tt.default = Tt;
});
var _o = S((qb, Oo) => {
  "use strict";
  var fi = "'".charCodeAt(0), Co = '"'.charCodeAt(0), _r = "\\".charCodeAt(0), Eo = "/".charCodeAt(0), Tr = `
`.charCodeAt(0), Pt = " ".charCodeAt(0), Pr = "\f".charCodeAt(0), Rr = "	".charCodeAt(0), Ir = "\r".charCodeAt(0), sd = "[".charCodeAt(0), ad = "]".charCodeAt(0), od = "(".charCodeAt(0), ld = ")".charCodeAt(0), ud = "{".charCodeAt(0), fd = "}".charCodeAt(0), cd = ";".charCodeAt(0), pd = "*".charCodeAt(0), dd = ":".charCodeAt(0), hd = "@".charCodeAt(0), Dr = /[\t\n\f\r "#'()/;[\\\]{}]/g, Mr = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, md = /.[\n"'(/\\]/, Ao = /[\da-f]/i;
  Oo.exports = function(e, r = {}) {
    let n = e.css.valueOf(), i = r.ignoreErrors, s, a, o2, l, u, f, p, c, d, h, y = n.length, m = 0, g = [], w = [];
    function b() {
      return m;
    }
    function v(E) {
      throw e.error("Unclosed " + E, m);
    }
    function C() {
      return w.length === 0 && m >= y;
    }
    function x(E) {
      if (w.length)
        return w.pop();
      if (m >= y)
        return;
      let R = E ? E.ignoreUnclosed : false;
      switch (s = n.charCodeAt(m), s) {
        case Tr:
        case Pt:
        case Rr:
        case Ir:
        case Pr: {
          a = m;
          do
            a += 1, s = n.charCodeAt(a);
          while (s === Pt || s === Tr || s === Rr || s === Ir || s === Pr);
          h = ["space", n.slice(m, a)], m = a - 1;
          break;
        }
        case sd:
        case ad:
        case ud:
        case fd:
        case dd:
        case cd:
        case ld: {
          let L = String.fromCharCode(s);
          h = [L, L, m];
          break;
        }
        case od: {
          if (c = g.length ? g.pop()[1] : "", d = n.charCodeAt(m + 1), c === "url" && d !== fi && d !== Co && d !== Pt && d !== Tr && d !== Rr && d !== Pr && d !== Ir) {
            a = m;
            do {
              if (f = false, a = n.indexOf(")", a + 1), a === -1)
                if (i || R) {
                  a = m;
                  break;
                } else
                  v("bracket");
              for (p = a; n.charCodeAt(p - 1) === _r; )
                p -= 1, f = !f;
            } while (f);
            h = ["brackets", n.slice(m, a + 1), m, a], m = a;
          } else
            a = n.indexOf(")", m + 1), l = n.slice(m, a + 1), a === -1 || md.test(l) ? h = ["(", "(", m] : (h = ["brackets", l, m, a], m = a);
          break;
        }
        case fi:
        case Co: {
          o2 = s === fi ? "'" : '"', a = m;
          do {
            if (f = false, a = n.indexOf(o2, a + 1), a === -1)
              if (i || R) {
                a = m + 1;
                break;
              } else
                v("string");
            for (p = a; n.charCodeAt(p - 1) === _r; )
              p -= 1, f = !f;
          } while (f);
          h = ["string", n.slice(m, a + 1), m, a], m = a;
          break;
        }
        case hd: {
          Dr.lastIndex = m + 1, Dr.test(n), Dr.lastIndex === 0 ? a = n.length - 1 : a = Dr.lastIndex - 2, h = ["at-word", n.slice(m, a + 1), m, a], m = a;
          break;
        }
        case _r: {
          for (a = m, u = true; n.charCodeAt(a + 1) === _r; )
            a += 1, u = !u;
          if (s = n.charCodeAt(a + 1), u && s !== Eo && s !== Pt && s !== Tr && s !== Rr && s !== Ir && s !== Pr && (a += 1, Ao.test(n.charAt(a)))) {
            for (; Ao.test(n.charAt(a + 1)); )
              a += 1;
            n.charCodeAt(a + 1) === Pt && (a += 1);
          }
          h = ["word", n.slice(m, a + 1), m, a], m = a;
          break;
        }
        default: {
          s === Eo && n.charCodeAt(m + 1) === pd ? (a = n.indexOf("*/", m + 2) + 1, a === 0 && (i || R ? a = n.length : v("comment")), h = ["comment", n.slice(m, a + 1), m, a], m = a) : (Mr.lastIndex = m + 1, Mr.test(n), Mr.lastIndex === 0 ? a = n.length - 1 : a = Mr.lastIndex - 2, h = ["word", n.slice(m, a + 1), m, a], g.push(h), m = a);
          break;
        }
      }
      return m++, h;
    }
    function O(E) {
      w.push(E);
    }
    return { back: O, nextToken: x, endOfFile: C, position: b };
  };
});
var Lr = S(($b, Po) => {
  "use strict";
  var To = Te(), Qe = class extends To {
    constructor(e) {
      super(e), this.type = "atrule";
    }
    append(...e) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
    }
    prepend(...e) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
    }
  };
  Po.exports = Qe;
  Qe.default = Qe;
  To.registerAtRule(Qe);
});
var Je = S((Ub, Mo) => {
  "use strict";
  var Ro = Te(), Io, Do, Pe = class extends Ro {
    constructor(e) {
      super(e), this.type = "root", this.nodes || (this.nodes = []);
    }
    removeChild(e, r) {
      let n = this.index(e);
      return !r && n === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[n].raws.before), super.removeChild(e);
    }
    normalize(e, r, n) {
      let i = super.normalize(e);
      if (r) {
        if (n === "prepend")
          this.nodes.length > 1 ? r.raws.before = this.nodes[1].raws.before : delete r.raws.before;
        else if (this.first !== r)
          for (let s of i)
            s.raws.before = r.raws.before;
      }
      return i;
    }
    toResult(e = {}) {
      return new Io(new Do(), this, e).stringify();
    }
  };
  Pe.registerLazyResult = (t) => {
    Io = t;
  };
  Pe.registerProcessor = (t) => {
    Do = t;
  };
  Mo.exports = Pe;
  Pe.default = Pe;
  Ro.registerRoot(Pe);
});
var ci = S((jb, Lo) => {
  "use strict";
  var Rt = { split(t, e, r) {
    let n = [], i = "", s = false, a = 0, o2 = false, l = "", u = false;
    for (let f of t)
      u ? u = false : f === "\\" ? u = true : o2 ? f === l && (o2 = false) : f === '"' || f === "'" ? (o2 = true, l = f) : f === "(" ? a += 1 : f === ")" ? a > 0 && (a -= 1) : a === 0 && e.includes(f) && (s = true), s ? (i !== "" && n.push(i.trim()), i = "", s = false) : i += f;
    return (r || i !== "") && n.push(i.trim()), n;
  }, space(t) {
    let e = [" ", `
`, "	"];
    return Rt.split(t, e);
  }, comma(t) {
    return Rt.split(t, [","], true);
  } };
  Lo.exports = Rt;
  Rt.default = Rt;
});
var Fr = S((zb, No) => {
  "use strict";
  var Fo = Te(), gd = ci(), Xe = class extends Fo {
    constructor(e) {
      super(e), this.type = "rule", this.nodes || (this.nodes = []);
    }
    get selectors() {
      return gd.comma(this.selector);
    }
    set selectors(e) {
      let r = this.selector ? this.selector.match(/,\s*/) : null, n = r ? r[0] : "," + this.raw("between", "beforeOpen");
      this.selector = e.join(n);
    }
  };
  No.exports = Xe;
  Xe.default = Xe;
  Fo.registerRule(Xe);
});
var jo = S((Vb, Uo) => {
  "use strict";
  var yd = xt(), wd = _o(), vd = Ot(), bd = Lr(), xd = Je(), qo = Fr(), $o = { empty: true, space: true };
  function Sd(t) {
    for (let e = t.length - 1; e >= 0; e--) {
      let r = t[e], n = r[3] || r[2];
      if (n)
        return n;
    }
  }
  var pi = class {
    constructor(e) {
      this.input = e, this.root = new xd(), this.current = this.root, this.spaces = "", this.semicolon = false, this.customProperty = false, this.createTokenizer(), this.root.source = { input: e, start: { offset: 0, line: 1, column: 1 } };
    }
    createTokenizer() {
      this.tokenizer = wd(this.input);
    }
    parse() {
      let e;
      for (; !this.tokenizer.endOfFile(); )
        switch (e = this.tokenizer.nextToken(), e[0]) {
          case "space":
            this.spaces += e[1];
            break;
          case ";":
            this.freeSemicolon(e);
            break;
          case "}":
            this.end(e);
            break;
          case "comment":
            this.comment(e);
            break;
          case "at-word":
            this.atrule(e);
            break;
          case "{":
            this.emptyRule(e);
            break;
          default:
            this.other(e);
            break;
        }
      this.endFile();
    }
    comment(e) {
      let r = new vd();
      this.init(r, e[2]), r.source.end = this.getPosition(e[3] || e[2]);
      let n = e[1].slice(2, -2);
      if (/^\s*$/.test(n))
        r.text = "", r.raws.left = n, r.raws.right = "";
      else {
        let i = n.match(/^(\s*)([^]*\S)(\s*)$/);
        r.text = i[2], r.raws.left = i[1], r.raws.right = i[3];
      }
    }
    emptyRule(e) {
      let r = new qo();
      this.init(r, e[2]), r.selector = "", r.raws.between = "", this.current = r;
    }
    other(e) {
      let r = false, n = null, i = false, s = null, a = [], o2 = e[1].startsWith("--"), l = [], u = e;
      for (; u; ) {
        if (n = u[0], l.push(u), n === "(" || n === "[")
          s || (s = u), a.push(n === "(" ? ")" : "]");
        else if (o2 && i && n === "{")
          s || (s = u), a.push("}");
        else if (a.length === 0)
          if (n === ";")
            if (i) {
              this.decl(l, o2);
              return;
            } else
              break;
          else if (n === "{") {
            this.rule(l);
            return;
          } else if (n === "}") {
            this.tokenizer.back(l.pop()), r = true;
            break;
          } else
            n === ":" && (i = true);
        else
          n === a[a.length - 1] && (a.pop(), a.length === 0 && (s = null));
        u = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (r = true), a.length > 0 && this.unclosedBracket(s), r && i) {
        if (!o2)
          for (; l.length && (u = l[l.length - 1][0], !(u !== "space" && u !== "comment")); )
            this.tokenizer.back(l.pop());
        this.decl(l, o2);
      } else
        this.unknownWord(l);
    }
    rule(e) {
      e.pop();
      let r = new qo();
      this.init(r, e[0][2]), r.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(r, "selector", e), this.current = r;
    }
    decl(e, r) {
      let n = new yd();
      this.init(n, e[0][2]);
      let i = e[e.length - 1];
      for (i[0] === ";" && (this.semicolon = true, e.pop()), n.source.end = this.getPosition(i[3] || i[2] || Sd(e)); e[0][0] !== "word"; )
        e.length === 1 && this.unknownWord(e), n.raws.before += e.shift()[1];
      for (n.source.start = this.getPosition(e[0][2]), n.prop = ""; e.length; ) {
        let u = e[0][0];
        if (u === ":" || u === "space" || u === "comment")
          break;
        n.prop += e.shift()[1];
      }
      n.raws.between = "";
      let s;
      for (; e.length; )
        if (s = e.shift(), s[0] === ":") {
          n.raws.between += s[1];
          break;
        } else
          s[0] === "word" && /\w/.test(s[1]) && this.unknownWord([s]), n.raws.between += s[1];
      (n.prop[0] === "_" || n.prop[0] === "*") && (n.raws.before += n.prop[0], n.prop = n.prop.slice(1));
      let a = [], o2;
      for (; e.length && (o2 = e[0][0], !(o2 !== "space" && o2 !== "comment")); )
        a.push(e.shift());
      this.precheckMissedSemicolon(e);
      for (let u = e.length - 1; u >= 0; u--) {
        if (s = e[u], s[1].toLowerCase() === "!important") {
          n.important = true;
          let f = this.stringFrom(e, u);
          f = this.spacesFromEnd(e) + f, f !== " !important" && (n.raws.important = f);
          break;
        } else if (s[1].toLowerCase() === "important") {
          let f = e.slice(0), p = "";
          for (let c = u; c > 0; c--) {
            let d = f[c][0];
            if (p.trim().indexOf("!") === 0 && d !== "space")
              break;
            p = f.pop()[1] + p;
          }
          p.trim().indexOf("!") === 0 && (n.important = true, n.raws.important = p, e = f);
        }
        if (s[0] !== "space" && s[0] !== "comment")
          break;
      }
      e.some((u) => u[0] !== "space" && u[0] !== "comment") && (n.raws.between += a.map((u) => u[1]).join(""), a = []), this.raw(n, "value", a.concat(e), r), n.value.includes(":") && !r && this.checkMissedSemicolon(e);
    }
    atrule(e) {
      let r = new bd();
      r.name = e[1].slice(1), r.name === "" && this.unnamedAtrule(r, e), this.init(r, e[2]);
      let n, i, s, a = false, o2 = false, l = [], u = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (e = this.tokenizer.nextToken(), n = e[0], n === "(" || n === "[" ? u.push(n === "(" ? ")" : "]") : n === "{" && u.length > 0 ? u.push("}") : n === u[u.length - 1] && u.pop(), u.length === 0)
          if (n === ";") {
            r.source.end = this.getPosition(e[2]), this.semicolon = true;
            break;
          } else if (n === "{") {
            o2 = true;
            break;
          } else if (n === "}") {
            if (l.length > 0) {
              for (s = l.length - 1, i = l[s]; i && i[0] === "space"; )
                i = l[--s];
              i && (r.source.end = this.getPosition(i[3] || i[2]));
            }
            this.end(e);
            break;
          } else
            l.push(e);
        else
          l.push(e);
        if (this.tokenizer.endOfFile()) {
          a = true;
          break;
        }
      }
      r.raws.between = this.spacesAndCommentsFromEnd(l), l.length ? (r.raws.afterName = this.spacesAndCommentsFromStart(l), this.raw(r, "params", l), a && (e = l[l.length - 1], r.source.end = this.getPosition(e[3] || e[2]), this.spaces = r.raws.between, r.raws.between = "")) : (r.raws.afterName = "", r.params = ""), o2 && (r.nodes = [], this.current = r);
    }
    end(e) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current = this.current.parent) : this.unexpectedClose(e);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    }
    freeSemicolon(e) {
      if (this.spaces += e[1], this.current.nodes) {
        let r = this.current.nodes[this.current.nodes.length - 1];
        r && r.type === "rule" && !r.raws.ownSemicolon && (r.raws.ownSemicolon = this.spaces, this.spaces = "");
      }
    }
    getPosition(e) {
      let r = this.input.fromOffset(e);
      return { offset: e, line: r.line, column: r.col };
    }
    init(e, r) {
      this.current.push(e), e.source = { start: this.getPosition(r), input: this.input }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = false);
    }
    raw(e, r, n, i) {
      let s, a, o2 = n.length, l = "", u = true, f, p;
      for (let c = 0; c < o2; c += 1)
        s = n[c], a = s[0], a === "space" && c === o2 - 1 && !i ? u = false : a === "comment" ? (p = n[c - 1] ? n[c - 1][0] : "empty", f = n[c + 1] ? n[c + 1][0] : "empty", !$o[p] && !$o[f] ? l.slice(-1) === "," ? u = false : l += s[1] : u = false) : l += s[1];
      if (!u) {
        let c = n.reduce((d, h) => d + h[1], "");
        e.raws[r] = { value: l, raw: c };
      }
      e[r] = l;
    }
    spacesAndCommentsFromEnd(e) {
      let r, n = "";
      for (; e.length && (r = e[e.length - 1][0], !(r !== "space" && r !== "comment")); )
        n = e.pop()[1] + n;
      return n;
    }
    spacesAndCommentsFromStart(e) {
      let r, n = "";
      for (; e.length && (r = e[0][0], !(r !== "space" && r !== "comment")); )
        n += e.shift()[1];
      return n;
    }
    spacesFromEnd(e) {
      let r, n = "";
      for (; e.length && (r = e[e.length - 1][0], r === "space"); )
        n = e.pop()[1] + n;
      return n;
    }
    stringFrom(e, r) {
      let n = "";
      for (let i = r; i < e.length; i++)
        n += e[i][1];
      return e.splice(r, e.length - r), n;
    }
    colon(e) {
      let r = 0, n, i, s;
      for (let [a, o2] of e.entries()) {
        if (n = o2, i = n[0], i === "(" && (r += 1), i === ")" && (r -= 1), r === 0 && i === ":")
          if (!s)
            this.doubleColon(n);
          else {
            if (s[0] === "word" && s[1] === "progid")
              continue;
            return a;
          }
        s = n;
      }
      return false;
    }
    unclosedBracket(e) {
      throw this.input.error("Unclosed bracket", { offset: e[2] }, { offset: e[2] + 1 });
    }
    unknownWord(e) {
      throw this.input.error("Unknown word", { offset: e[0][2] }, { offset: e[0][2] + e[0][1].length });
    }
    unexpectedClose(e) {
      throw this.input.error("Unexpected }", { offset: e[2] }, { offset: e[2] + 1 });
    }
    unclosedBlock() {
      let e = this.current.source.start;
      throw this.input.error("Unclosed block", e.line, e.column);
    }
    doubleColon(e) {
      throw this.input.error("Double colon", { offset: e[2] }, { offset: e[2] + e[1].length });
    }
    unnamedAtrule(e, r) {
      throw this.input.error("At-rule without name", { offset: r[2] }, { offset: r[2] + r[1].length });
    }
    precheckMissedSemicolon() {
    }
    checkMissedSemicolon(e) {
      let r = this.colon(e);
      if (r === false)
        return;
      let n = 0, i;
      for (let s = r - 1; s >= 0 && (i = e[s], !(i[0] !== "space" && (n += 1, n === 2))); s--)
        ;
      throw this.input.error("Missed semicolon", i[0] === "word" ? i[3] + 1 : i[2]);
    }
  };
  Uo.exports = pi;
});
var qr = S((Wb, zo) => {
  "use strict";
  var kd = Te(), Cd = jo(), Ed = Et();
  function Nr(t, e) {
    let r = new Ed(t, e), n = new Cd(r);
    try {
      n.parse();
    } catch (i) {
      throw i;
    }
    return n.root;
  }
  zo.exports = Nr;
  Nr.default = Nr;
  kd.registerParse(Nr);
});
var mi = S((Gb, Go) => {
  "use strict";
  var { isClean: ge, my: Ad } = br(), Od = si(), _d = yt(), Td = Te(), Pd = Ar(), Bb = li(), Vo = Or(), Rd = qr(), Id = Je(), Dd = { document: "Document", root: "Root", atrule: "AtRule", rule: "Rule", decl: "Declaration", comment: "Comment" }, Md = { postcssPlugin: true, prepare: true, Once: true, Document: true, Root: true, Declaration: true, Rule: true, AtRule: true, Comment: true, DeclarationExit: true, RuleExit: true, AtRuleExit: true, CommentExit: true, RootExit: true, DocumentExit: true, OnceExit: true }, Ld = { postcssPlugin: true, prepare: true, Once: true }, Ke = 0;
  function It(t) {
    return typeof t == "object" && typeof t.then == "function";
  }
  function Bo(t) {
    let e = false, r = Dd[t.type];
    return t.type === "decl" ? e = t.prop.toLowerCase() : t.type === "atrule" && (e = t.name.toLowerCase()), e && t.append ? [r, r + "-" + e, Ke, r + "Exit", r + "Exit-" + e] : e ? [r, r + "-" + e, r + "Exit", r + "Exit-" + e] : t.append ? [r, Ke, r + "Exit"] : [r, r + "Exit"];
  }
  function Wo(t) {
    let e;
    return t.type === "document" ? e = ["Document", Ke, "DocumentExit"] : t.type === "root" ? e = ["Root", Ke, "RootExit"] : e = Bo(t), { node: t, events: e, eventIndex: 0, visitors: [], visitorIndex: 0, iterator: 0 };
  }
  function di(t) {
    return t[ge] = false, t.nodes && t.nodes.forEach((e) => di(e)), t;
  }
  var hi = {}, ye = class {
    constructor(e, r, n) {
      this.stringified = false, this.processed = false;
      let i;
      if (typeof r == "object" && r !== null && (r.type === "root" || r.type === "document"))
        i = di(r);
      else if (r instanceof ye || r instanceof Vo)
        i = di(r.root), r.map && (typeof n.map > "u" && (n.map = {}), n.map.inline || (n.map.inline = false), n.map.prev = r.map);
      else {
        let s = Rd;
        n.syntax && (s = n.syntax.parse), n.parser && (s = n.parser), s.parse && (s = s.parse);
        try {
          i = s(r, n);
        } catch (a) {
          this.processed = true, this.error = a;
        }
        i && !i[Ad] && Td.rebuild(i);
      }
      this.result = new Vo(e, i, n), this.helpers = { ...hi, result: this.result, postcss: hi }, this.plugins = this.processor.plugins.map((s) => typeof s == "object" && s.prepare ? { ...s, ...s.prepare(this.result) } : s);
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
    get processor() {
      return this.result.processor;
    }
    get opts() {
      return this.result.opts;
    }
    get css() {
      return this.stringify().css;
    }
    get content() {
      return this.stringify().content;
    }
    get map() {
      return this.stringify().map;
    }
    get root() {
      return this.sync().root;
    }
    get messages() {
      return this.sync().messages;
    }
    warnings() {
      return this.sync().warnings();
    }
    toString() {
      return this.css;
    }
    then(e, r) {
      return this.async().then(e, r);
    }
    catch(e) {
      return this.async().catch(e);
    }
    finally(e) {
      return this.async().then(e, e);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    sync() {
      if (this.error)
        throw this.error;
      if (this.processed)
        return this.result;
      if (this.processed = true, this.processing)
        throw this.getAsyncError();
      for (let e of this.plugins) {
        let r = this.runOnRoot(e);
        if (It(r))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e = this.result.root;
        for (; !e[ge]; )
          e[ge] = true, this.walkSync(e);
        if (this.listeners.OnceExit)
          if (e.type === "document")
            for (let r of e.nodes)
              this.visitSync(this.listeners.OnceExit, r);
          else
            this.visitSync(this.listeners.OnceExit, e);
      }
      return this.result;
    }
    stringify() {
      if (this.error)
        throw this.error;
      if (this.stringified)
        return this.result;
      this.stringified = true, this.sync();
      let e = this.result.opts, r = _d;
      e.syntax && (r = e.syntax.stringify), e.stringifier && (r = e.stringifier), r.stringify && (r = r.stringify);
      let i = new Od(r, this.result.root, this.result.opts).generate();
      return this.result.css = i[0], this.result.map = i[1], this.result;
    }
    walkSync(e) {
      e[ge] = true;
      let r = Bo(e);
      for (let n of r)
        if (n === Ke)
          e.nodes && e.each((i) => {
            i[ge] || this.walkSync(i);
          });
        else {
          let i = this.listeners[n];
          if (i && this.visitSync(i, e.toProxy()))
            return;
        }
    }
    visitSync(e, r) {
      for (let [n, i] of e) {
        this.result.lastPlugin = n;
        let s;
        try {
          s = i(r, this.helpers);
        } catch (a) {
          throw this.handleError(a, r.proxyOf);
        }
        if (r.type !== "root" && r.type !== "document" && !r.parent)
          return true;
        if (It(s))
          throw this.getAsyncError();
      }
    }
    runOnRoot(e) {
      this.result.lastPlugin = e;
      try {
        if (typeof e == "object" && e.Once) {
          if (this.result.root.type === "document") {
            let r = this.result.root.nodes.map((n) => e.Once(n, this.helpers));
            return It(r[0]) ? Promise.all(r) : r;
          }
          return e.Once(this.result.root, this.helpers);
        } else if (typeof e == "function")
          return e(this.result.root, this.result);
      } catch (r) {
        throw this.handleError(r);
      }
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(e, r) {
      let n = this.result.lastPlugin;
      try {
        r && r.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin ? (e.plugin = n.postcssPlugin, e.setMessage()) : n.postcssVersion;
      } catch (i) {
        console && console.error && console.error(i);
      }
      return e;
    }
    async runAsync() {
      this.plugin = 0;
      for (let e = 0; e < this.plugins.length; e++) {
        let r = this.plugins[e], n = this.runOnRoot(r);
        if (It(n))
          try {
            await n;
          } catch (i) {
            throw this.handleError(i);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e = this.result.root;
        for (; !e[ge]; ) {
          e[ge] = true;
          let r = [Wo(e)];
          for (; r.length > 0; ) {
            let n = this.visitTick(r);
            if (It(n))
              try {
                await n;
              } catch (i) {
                let s = r[r.length - 1].node;
                throw this.handleError(i, s);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [r, n] of this.listeners.OnceExit) {
            this.result.lastPlugin = r;
            try {
              if (e.type === "document") {
                let i = e.nodes.map((s) => n(s, this.helpers));
                await Promise.all(i);
              } else
                await n(e, this.helpers);
            } catch (i) {
              throw this.handleError(i);
            }
          }
      }
      return this.processed = true, this.stringify();
    }
    prepareVisitors() {
      this.listeners = {};
      let e = (r, n, i) => {
        this.listeners[n] || (this.listeners[n] = []), this.listeners[n].push([r, i]);
      };
      for (let r of this.plugins)
        if (typeof r == "object")
          for (let n in r) {
            if (!Md[n] && /^[A-Z]/.test(n))
              throw new Error(`Unknown event ${n} in ${r.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
            if (!Ld[n])
              if (typeof r[n] == "object")
                for (let i in r[n])
                  i === "*" ? e(r, n, r[n][i]) : e(r, n + "-" + i.toLowerCase(), r[n][i]);
              else
                typeof r[n] == "function" && e(r, n, r[n]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    visitTick(e) {
      let r = e[e.length - 1], { node: n, visitors: i } = r;
      if (n.type !== "root" && n.type !== "document" && !n.parent) {
        e.pop();
        return;
      }
      if (i.length > 0 && r.visitorIndex < i.length) {
        let [a, o2] = i[r.visitorIndex];
        r.visitorIndex += 1, r.visitorIndex === i.length && (r.visitors = [], r.visitorIndex = 0), this.result.lastPlugin = a;
        try {
          return o2(n.toProxy(), this.helpers);
        } catch (l) {
          throw this.handleError(l, n);
        }
      }
      if (r.iterator !== 0) {
        let a = r.iterator, o2;
        for (; o2 = n.nodes[n.indexes[a]]; )
          if (n.indexes[a] += 1, !o2[ge]) {
            o2[ge] = true, e.push(Wo(o2));
            return;
          }
        r.iterator = 0, delete n.indexes[a];
      }
      let s = r.events;
      for (; r.eventIndex < s.length; ) {
        let a = s[r.eventIndex];
        if (r.eventIndex += 1, a === Ke) {
          n.nodes && n.nodes.length && (n[ge] = true, r.iterator = n.getIterator());
          return;
        } else if (this.listeners[a]) {
          r.visitors = this.listeners[a];
          return;
        }
      }
      e.pop();
    }
  };
  ye.registerPostcss = (t) => {
    hi = t;
  };
  Go.exports = ye;
  ye.default = ye;
  Id.registerLazyResult(ye);
  Pd.registerLazyResult(ye);
});
var Ho = S((Hb, Yo) => {
  "use strict";
  var Fd = si(), Nd = yt(), Yb = li(), qd = qr(), $d = Or(), Dt = class {
    constructor(e, r, n) {
      r = r.toString(), this.stringified = false, this._processor = e, this._css = r, this._opts = n, this._map = void 0;
      let i, s = Nd;
      this.result = new $d(this._processor, i, this._opts), this.result.css = r;
      let a = this;
      Object.defineProperty(this.result, "root", { get() {
        return a.root;
      } });
      let o2 = new Fd(s, i, this._opts, r);
      if (o2.isMap()) {
        let [l, u] = o2.generate();
        l && (this.result.css = l), u && (this.result.map = u);
      }
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
    get processor() {
      return this.result.processor;
    }
    get opts() {
      return this.result.opts;
    }
    get css() {
      return this.result.css;
    }
    get content() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get root() {
      if (this._root)
        return this._root;
      let e, r = qd;
      try {
        e = r(this._css, this._opts);
      } catch (n) {
        this.error = n;
      }
      if (this.error)
        throw this.error;
      return this._root = e, e;
    }
    get messages() {
      return [];
    }
    warnings() {
      return [];
    }
    toString() {
      return this._css;
    }
    then(e, r) {
      return this.async().then(e, r);
    }
    catch(e) {
      return this.async().catch(e);
    }
    finally(e) {
      return this.async().then(e, e);
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    sync() {
      if (this.error)
        throw this.error;
      return this.result;
    }
  };
  Yo.exports = Dt;
  Dt.default = Dt;
});
var Jo = S((Qb, Qo) => {
  "use strict";
  var Ud = Ho(), jd = mi(), zd = Ar(), Vd = Je(), ze = class {
    constructor(e = []) {
      this.version = "8.4.21", this.plugins = this.normalize(e);
    }
    use(e) {
      return this.plugins = this.plugins.concat(this.normalize([e])), this;
    }
    process(e, r = {}) {
      return this.plugins.length === 0 && typeof r.parser > "u" && typeof r.stringifier > "u" && typeof r.syntax > "u" ? new Ud(this, e, r) : new jd(this, e, r);
    }
    normalize(e) {
      let r = [];
      for (let n of e)
        if (n.postcss === true ? n = n() : n.postcss && (n = n.postcss), typeof n == "object" && Array.isArray(n.plugins))
          r = r.concat(n.plugins);
        else if (typeof n == "object" && n.postcssPlugin)
          r.push(n);
        else if (typeof n == "function")
          r.push(n);
        else if (!(typeof n == "object" && (n.parse || n.stringify)))
          throw new Error(n + " is not a PostCSS plugin");
      return r;
    }
  };
  Qo.exports = ze;
  ze.default = ze;
  Vd.registerProcessor(ze);
  zd.registerProcessor(ze);
});
var Ko = S((Jb, Xo) => {
  "use strict";
  var Wd = xt(), Bd = Zn(), Gd = Ot(), Yd = Lr(), Hd = Et(), Qd = Je(), Jd = Fr();
  function Mt(t, e) {
    if (Array.isArray(t))
      return t.map((i) => Mt(i));
    let { inputs: r, ...n } = t;
    if (r) {
      e = [];
      for (let i of r) {
        let s = { ...i, __proto__: Hd.prototype };
        s.map && (s.map = { ...s.map, __proto__: Bd.prototype }), e.push(s);
      }
    }
    if (n.nodes && (n.nodes = t.nodes.map((i) => Mt(i, e))), n.source) {
      let { inputId: i, ...s } = n.source;
      n.source = s, i != null && (n.source.input = e[i]);
    }
    if (n.type === "root")
      return new Qd(n);
    if (n.type === "decl")
      return new Wd(n);
    if (n.type === "rule")
      return new Jd(n);
    if (n.type === "comment")
      return new Gd(n);
    if (n.type === "atrule")
      return new Yd(n);
    throw new Error("Unknown node type: " + t.type);
  }
  Xo.exports = Mt;
  Mt.default = Mt;
});
var Ze = S((Xb, sl) => {
  "use strict";
  var Xd = vr(), Zo = xt(), Kd = mi(), Zd = Te(), gi = Jo(), eh = yt(), th = Ko(), el = Ar(), rh = ui(), tl = Ot(), rl = Lr(), nh = Or(), ih = Et(), sh = qr(), ah = ci(), nl = Fr(), il = Je(), oh = vt();
  function F(...t) {
    return t.length === 1 && Array.isArray(t[0]) && (t = t[0]), new gi(t);
  }
  F.plugin = function(e, r) {
    let n = false;
    function i(...a) {
      console && console.warn && !n && (n = true, console.warn(e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(e + `:  postcss.plugin . :
https://www.w3ctech.com/topic/2226`));
      let o2 = r(...a);
      return o2.postcssPlugin = e, o2.postcssVersion = new gi().version, o2;
    }
    let s;
    return Object.defineProperty(i, "postcss", { get() {
      return s || (s = i()), s;
    } }), i.process = function(a, o2, l) {
      return F([i(l)]).process(a, o2);
    }, i;
  };
  F.stringify = eh;
  F.parse = sh;
  F.fromJSON = th;
  F.list = ah;
  F.comment = (t) => new tl(t);
  F.atRule = (t) => new rl(t);
  F.decl = (t) => new Zo(t);
  F.rule = (t) => new nl(t);
  F.root = (t) => new il(t);
  F.document = (t) => new el(t);
  F.CssSyntaxError = Xd;
  F.Declaration = Zo;
  F.Container = Zd;
  F.Processor = gi;
  F.Document = el;
  F.Comment = tl;
  F.Warning = rh;
  F.AtRule = rl;
  F.Result = nh;
  F.Input = ih;
  F.Rule = nl;
  F.Root = il;
  F.Node = oh;
  Kd.registerPostcss(F);
  sl.exports = F;
  F.default = F;
});
var Ur = S(($r, al) => {
  "use strict";
  $r.__esModule = true;
  $r.default = fh;
  function lh(t) {
    for (var e = t.toLowerCase(), r = "", n = false, i = 0; i < 6 && e[i] !== void 0; i++) {
      var s = e.charCodeAt(i), a = s >= 97 && s <= 102 || s >= 48 && s <= 57;
      if (n = s === 32, !a)
        break;
      r += e[i];
    }
    if (r.length !== 0) {
      var o2 = parseInt(r, 16), l = o2 >= 55296 && o2 <= 57343;
      return l || o2 === 0 || o2 > 1114111 ? ["", r.length + (n ? 1 : 0)] : [String.fromCodePoint(o2), r.length + (n ? 1 : 0)];
    }
  }
  var uh = /\\/;
  function fh(t) {
    var e = uh.test(t);
    if (!e)
      return t;
    for (var r = "", n = 0; n < t.length; n++) {
      if (t[n] === "\\") {
        var i = lh(t.slice(n + 1, n + 7));
        if (i !== void 0) {
          r += i[0], n += i[1];
          continue;
        }
        if (t[n + 1] === "\\") {
          r += "\\", n++;
          continue;
        }
        t.length === n + 1 && (r += t[n]);
        continue;
      }
      r += t[n];
    }
    return r;
  }
  al.exports = $r.default;
});
var ll = S((jr, ol) => {
  "use strict";
  jr.__esModule = true;
  jr.default = ch;
  function ch(t) {
    for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
      r[n - 1] = arguments[n];
    for (; r.length > 0; ) {
      var i = r.shift();
      if (!t[i])
        return;
      t = t[i];
    }
    return t;
  }
  ol.exports = jr.default;
});
var fl = S((zr, ul) => {
  "use strict";
  zr.__esModule = true;
  zr.default = ph;
  function ph(t) {
    for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
      r[n - 1] = arguments[n];
    for (; r.length > 0; ) {
      var i = r.shift();
      t[i] || (t[i] = {}), t = t[i];
    }
  }
  ul.exports = zr.default;
});
var pl = S((Vr, cl) => {
  "use strict";
  Vr.__esModule = true;
  Vr.default = dh;
  function dh(t) {
    for (var e = "", r = t.indexOf("/*"), n = 0; r >= 0; ) {
      e = e + t.slice(n, r);
      var i = t.indexOf("*/", r + 2);
      if (i < 0)
        return e;
      n = i + 2, r = t.indexOf("/*", n);
    }
    return e = e + t.slice(n), e;
  }
  cl.exports = Vr.default;
});
var Lt = S((we) => {
  "use strict";
  we.__esModule = true;
  we.stripComments = we.ensureObject = we.getProp = we.unesc = void 0;
  var hh = Wr(Ur());
  we.unesc = hh.default;
  var mh = Wr(ll());
  we.getProp = mh.default;
  var gh = Wr(fl());
  we.ensureObject = gh.default;
  var yh = Wr(pl());
  we.stripComments = yh.default;
  function Wr(t) {
    return t && t.__esModule ? t : { default: t };
  }
});
var Ce = S((Ft, ml) => {
  "use strict";
  Ft.__esModule = true;
  Ft.default = void 0;
  var dl = Lt();
  function hl(t, e) {
    for (var r = 0; r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function wh(t, e, r) {
    return e && hl(t.prototype, e), r && hl(t, r), t;
  }
  var vh = function t(e, r) {
    if (typeof e != "object" || e === null)
      return e;
    var n = new e.constructor();
    for (var i in e)
      if (!!e.hasOwnProperty(i)) {
        var s = e[i], a = typeof s;
        i === "parent" && a === "object" ? r && (n[i] = r) : s instanceof Array ? n[i] = s.map(function(o2) {
          return t(o2, n);
        }) : n[i] = t(s, n);
      }
    return n;
  }, bh = function() {
    function t(r) {
      r === void 0 && (r = {}), Object.assign(this, r), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
    }
    var e = t.prototype;
    return e.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, e.replaceWith = function() {
      if (this.parent) {
        for (var n in arguments)
          this.parent.insertBefore(this, arguments[n]);
        this.remove();
      }
      return this;
    }, e.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, e.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, e.clone = function(n) {
      n === void 0 && (n = {});
      var i = vh(this);
      for (var s in n)
        i[s] = n[s];
      return i;
    }, e.appendToPropertyAndEscape = function(n, i, s) {
      this.raws || (this.raws = {});
      var a = this[n], o2 = this.raws[n];
      this[n] = a + i, o2 || s !== i ? this.raws[n] = (o2 || a) + s : delete this.raws[n];
    }, e.setPropertyAndEscape = function(n, i, s) {
      this.raws || (this.raws = {}), this[n] = i, this.raws[n] = s;
    }, e.setPropertyWithoutEscape = function(n, i) {
      this[n] = i, this.raws && delete this.raws[n];
    }, e.isAtPosition = function(n, i) {
      if (this.source && this.source.start && this.source.end)
        return !(this.source.start.line > n || this.source.end.line < n || this.source.start.line === n && this.source.start.column > i || this.source.end.line === n && this.source.end.column < i);
    }, e.stringifyProperty = function(n) {
      return this.raws && this.raws[n] || this[n];
    }, e.valueToString = function() {
      return String(this.stringifyProperty("value"));
    }, e.toString = function() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
    }, wh(t, [{ key: "rawSpaceBefore", get: function() {
      var n = this.raws && this.raws.spaces && this.raws.spaces.before;
      return n === void 0 && (n = this.spaces && this.spaces.before), n || "";
    }, set: function(n) {
      (0, dl.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = n;
    } }, { key: "rawSpaceAfter", get: function() {
      var n = this.raws && this.raws.spaces && this.raws.spaces.after;
      return n === void 0 && (n = this.spaces.after), n || "";
    }, set: function(n) {
      (0, dl.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = n;
    } }]), t;
  }();
  Ft.default = bh;
  ml.exports = Ft.default;
});
var J = S((U) => {
  "use strict";
  U.__esModule = true;
  U.UNIVERSAL = U.ATTRIBUTE = U.CLASS = U.COMBINATOR = U.COMMENT = U.ID = U.NESTING = U.PSEUDO = U.ROOT = U.SELECTOR = U.STRING = U.TAG = void 0;
  var xh = "tag";
  U.TAG = xh;
  var Sh = "string";
  U.STRING = Sh;
  var kh = "selector";
  U.SELECTOR = kh;
  var Ch = "root";
  U.ROOT = Ch;
  var Eh = "pseudo";
  U.PSEUDO = Eh;
  var Ah = "nesting";
  U.NESTING = Ah;
  var Oh = "id";
  U.ID = Oh;
  var _h = "comment";
  U.COMMENT = _h;
  var Th = "combinator";
  U.COMBINATOR = Th;
  var Ph = "class";
  U.CLASS = Ph;
  var Rh = "attribute";
  U.ATTRIBUTE = Rh;
  var Ih = "universal";
  U.UNIVERSAL = Ih;
});
var Br = S((Nt, vl) => {
  "use strict";
  Nt.__esModule = true;
  Nt.default = void 0;
  var Dh = Lh(Ce()), Ee = Mh(J());
  function wl() {
    if (typeof WeakMap != "function")
      return null;
    var t = /* @__PURE__ */ new WeakMap();
    return wl = function() {
      return t;
    }, t;
  }
  function Mh(t) {
    if (t && t.__esModule)
      return t;
    if (t === null || typeof t != "object" && typeof t != "function")
      return { default: t };
    var e = wl();
    if (e && e.has(t))
      return e.get(t);
    var r = {}, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var i in t)
      if (Object.prototype.hasOwnProperty.call(t, i)) {
        var s = n ? Object.getOwnPropertyDescriptor(t, i) : null;
        s && (s.get || s.set) ? Object.defineProperty(r, i, s) : r[i] = t[i];
      }
    return r.default = t, e && e.set(t, r), r;
  }
  function Lh(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Fh(t, e) {
    var r;
    if (typeof Symbol > "u" || t[Symbol.iterator] == null) {
      if (Array.isArray(t) || (r = Nh(t)) || e && t && typeof t.length == "number") {
        r && (t = r);
        var n = 0;
        return function() {
          return n >= t.length ? { done: true } : { done: false, value: t[n++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    return r = t[Symbol.iterator](), r.next.bind(r);
  }
  function Nh(t, e) {
    if (!!t) {
      if (typeof t == "string")
        return gl(t, e);
      var r = Object.prototype.toString.call(t).slice(8, -1);
      if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set")
        return Array.from(t);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
        return gl(t, e);
    }
  }
  function gl(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r = 0, n = new Array(e); r < e; r++)
      n[r] = t[r];
    return n;
  }
  function yl(t, e) {
    for (var r = 0; r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function qh(t, e, r) {
    return e && yl(t.prototype, e), r && yl(t, r), t;
  }
  function $h(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, yi(t, e);
  }
  function yi(t, e) {
    return yi = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, yi(t, e);
  }
  var Uh = function(t) {
    $h(e, t);
    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.nodes || (i.nodes = []), i;
    }
    var r = e.prototype;
    return r.append = function(i) {
      return i.parent = this, this.nodes.push(i), this;
    }, r.prepend = function(i) {
      return i.parent = this, this.nodes.unshift(i), this;
    }, r.at = function(i) {
      return this.nodes[i];
    }, r.index = function(i) {
      return typeof i == "number" ? i : this.nodes.indexOf(i);
    }, r.removeChild = function(i) {
      i = this.index(i), this.at(i).parent = void 0, this.nodes.splice(i, 1);
      var s;
      for (var a in this.indexes)
        s = this.indexes[a], s >= i && (this.indexes[a] = s - 1);
      return this;
    }, r.removeAll = function() {
      for (var i = Fh(this.nodes), s; !(s = i()).done; ) {
        var a = s.value;
        a.parent = void 0;
      }
      return this.nodes = [], this;
    }, r.empty = function() {
      return this.removeAll();
    }, r.insertAfter = function(i, s) {
      s.parent = this;
      var a = this.index(i);
      this.nodes.splice(a + 1, 0, s), s.parent = this;
      var o2;
      for (var l in this.indexes)
        o2 = this.indexes[l], a <= o2 && (this.indexes[l] = o2 + 1);
      return this;
    }, r.insertBefore = function(i, s) {
      s.parent = this;
      var a = this.index(i);
      this.nodes.splice(a, 0, s), s.parent = this;
      var o2;
      for (var l in this.indexes)
        o2 = this.indexes[l], o2 <= a && (this.indexes[l] = o2 + 1);
      return this;
    }, r._findChildAtPosition = function(i, s) {
      var a = void 0;
      return this.each(function(o2) {
        if (o2.atPosition) {
          var l = o2.atPosition(i, s);
          if (l)
            return a = l, false;
        } else if (o2.isAtPosition(i, s))
          return a = o2, false;
      }), a;
    }, r.atPosition = function(i, s) {
      if (this.isAtPosition(i, s))
        return this._findChildAtPosition(i, s) || this;
    }, r._inferEndPosition = function() {
      this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
    }, r.each = function(i) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var s = this.lastEach;
      if (this.indexes[s] = 0, !!this.length) {
        for (var a, o2; this.indexes[s] < this.length && (a = this.indexes[s], o2 = i(this.at(a), a), o2 !== false); )
          this.indexes[s] += 1;
        if (delete this.indexes[s], o2 === false)
          return false;
      }
    }, r.walk = function(i) {
      return this.each(function(s, a) {
        var o2 = i(s, a);
        if (o2 !== false && s.length && (o2 = s.walk(i)), o2 === false)
          return false;
      });
    }, r.walkAttributes = function(i) {
      var s = this;
      return this.walk(function(a) {
        if (a.type === Ee.ATTRIBUTE)
          return i.call(s, a);
      });
    }, r.walkClasses = function(i) {
      var s = this;
      return this.walk(function(a) {
        if (a.type === Ee.CLASS)
          return i.call(s, a);
      });
    }, r.walkCombinators = function(i) {
      var s = this;
      return this.walk(function(a) {
        if (a.type === Ee.COMBINATOR)
          return i.call(s, a);
      });
    }, r.walkComments = function(i) {
      var s = this;
      return this.walk(function(a) {
        if (a.type === Ee.COMMENT)
          return i.call(s, a);
      });
    }, r.walkIds = function(i) {
      var s = this;
      return this.walk(function(a) {
        if (a.type === Ee.ID)
          return i.call(s, a);
      });
    }, r.walkNesting = function(i) {
      var s = this;
      return this.walk(function(a) {
        if (a.type === Ee.NESTING)
          return i.call(s, a);
      });
    }, r.walkPseudos = function(i) {
      var s = this;
      return this.walk(function(a) {
        if (a.type === Ee.PSEUDO)
          return i.call(s, a);
      });
    }, r.walkTags = function(i) {
      var s = this;
      return this.walk(function(a) {
        if (a.type === Ee.TAG)
          return i.call(s, a);
      });
    }, r.walkUniversals = function(i) {
      var s = this;
      return this.walk(function(a) {
        if (a.type === Ee.UNIVERSAL)
          return i.call(s, a);
      });
    }, r.split = function(i) {
      var s = this, a = [];
      return this.reduce(function(o2, l, u) {
        var f = i.call(s, l);
        return a.push(l), f ? (o2.push(a), a = []) : u === s.length - 1 && o2.push(a), o2;
      }, []);
    }, r.map = function(i) {
      return this.nodes.map(i);
    }, r.reduce = function(i, s) {
      return this.nodes.reduce(i, s);
    }, r.every = function(i) {
      return this.nodes.every(i);
    }, r.some = function(i) {
      return this.nodes.some(i);
    }, r.filter = function(i) {
      return this.nodes.filter(i);
    }, r.sort = function(i) {
      return this.nodes.sort(i);
    }, r.toString = function() {
      return this.map(String).join("");
    }, qh(e, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), e;
  }(Dh.default);
  Nt.default = Uh;
  vl.exports = Nt.default;
});
var vi = S((qt, xl) => {
  "use strict";
  qt.__esModule = true;
  qt.default = void 0;
  var jh = Vh(Br()), zh = J();
  function Vh(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function bl(t, e) {
    for (var r = 0; r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function Wh(t, e, r) {
    return e && bl(t.prototype, e), r && bl(t, r), t;
  }
  function Bh(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, wi(t, e);
  }
  function wi(t, e) {
    return wi = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, wi(t, e);
  }
  var Gh = function(t) {
    Bh(e, t);
    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.type = zh.ROOT, i;
    }
    var r = e.prototype;
    return r.toString = function() {
      var i = this.reduce(function(s, a) {
        return s.push(String(a)), s;
      }, []).join(",");
      return this.trailingComma ? i + "," : i;
    }, r.error = function(i, s) {
      return this._error ? this._error(i, s) : new Error(i);
    }, Wh(e, [{ key: "errorGenerator", set: function(i) {
      this._error = i;
    } }]), e;
  }(jh.default);
  qt.default = Gh;
  xl.exports = qt.default;
});
var xi = S(($t, Sl) => {
  "use strict";
  $t.__esModule = true;
  $t.default = void 0;
  var Yh = Qh(Br()), Hh = J();
  function Qh(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Jh(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, bi(t, e);
  }
  function bi(t, e) {
    return bi = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, bi(t, e);
  }
  var Xh = function(t) {
    Jh(e, t);
    function e(r) {
      var n;
      return n = t.call(this, r) || this, n.type = Hh.SELECTOR, n;
    }
    return e;
  }(Yh.default);
  $t.default = Xh;
  Sl.exports = $t.default;
});
var Gr = S((Ex, kl) => {
  "use strict";
  var Kh = {}, Zh = Kh.hasOwnProperty, em = function(e, r) {
    if (!e)
      return r;
    var n = {};
    for (var i in r)
      n[i] = Zh.call(e, i) ? e[i] : r[i];
    return n;
  }, tm = /[ -,\.\/:-@\[-\^`\{-~]/, rm = /[ -,\.\/:-@\[\]\^`\{-~]/, nm = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, Si = function t(e, r) {
    r = em(r, t.options), r.quotes != "single" && r.quotes != "double" && (r.quotes = "single");
    for (var n = r.quotes == "double" ? '"' : "'", i = r.isIdentifier, s = e.charAt(0), a = "", o2 = 0, l = e.length; o2 < l; ) {
      var u = e.charAt(o2++), f = u.charCodeAt(), p = void 0;
      if (f < 32 || f > 126) {
        if (f >= 55296 && f <= 56319 && o2 < l) {
          var c = e.charCodeAt(o2++);
          (c & 64512) == 56320 ? f = ((f & 1023) << 10) + (c & 1023) + 65536 : o2--;
        }
        p = "\\" + f.toString(16).toUpperCase() + " ";
      } else
        r.escapeEverything ? tm.test(u) ? p = "\\" + u : p = "\\" + f.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(u) ? p = "\\" + f.toString(16).toUpperCase() + " " : u == "\\" || !i && (u == '"' && n == u || u == "'" && n == u) || i && rm.test(u) ? p = "\\" + u : p = u;
      a += p;
    }
    return i && (/^-[-\d]/.test(a) ? a = "\\-" + a.slice(1) : /\d/.test(s) && (a = "\\3" + s + " " + a.slice(1))), a = a.replace(nm, function(d, h, y) {
      return h && h.length % 2 ? d : (h || "") + y;
    }), !i && r.wrap ? n + a + n : a;
  };
  Si.options = { escapeEverything: false, isIdentifier: false, quotes: "single", wrap: false };
  Si.version = "3.0.0";
  kl.exports = Si;
});
var Ci = S((Ut, Al) => {
  "use strict";
  Ut.__esModule = true;
  Ut.default = void 0;
  var im = El(Gr()), sm = Lt(), am = El(Ce()), om = J();
  function El(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Cl(t, e) {
    for (var r = 0; r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function lm(t, e, r) {
    return e && Cl(t.prototype, e), r && Cl(t, r), t;
  }
  function um(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, ki(t, e);
  }
  function ki(t, e) {
    return ki = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, ki(t, e);
  }
  var fm = function(t) {
    um(e, t);
    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.type = om.CLASS, i._constructed = true, i;
    }
    var r = e.prototype;
    return r.valueToString = function() {
      return "." + t.prototype.valueToString.call(this);
    }, lm(e, [{ key: "value", get: function() {
      return this._value;
    }, set: function(i) {
      if (this._constructed) {
        var s = (0, im.default)(i, { isIdentifier: true });
        s !== i ? ((0, sm.ensureObject)(this, "raws"), this.raws.value = s) : this.raws && delete this.raws.value;
      }
      this._value = i;
    } }]), e;
  }(am.default);
  Ut.default = fm;
  Al.exports = Ut.default;
});
var Ai = S((jt, Ol) => {
  "use strict";
  jt.__esModule = true;
  jt.default = void 0;
  var cm = dm(Ce()), pm = J();
  function dm(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function hm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ei(t, e);
  }
  function Ei(t, e) {
    return Ei = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, Ei(t, e);
  }
  var mm = function(t) {
    hm(e, t);
    function e(r) {
      var n;
      return n = t.call(this, r) || this, n.type = pm.COMMENT, n;
    }
    return e;
  }(cm.default);
  jt.default = mm;
  Ol.exports = jt.default;
});
var _i = S((zt, _l) => {
  "use strict";
  zt.__esModule = true;
  zt.default = void 0;
  var gm = wm(Ce()), ym = J();
  function wm(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function vm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Oi(t, e);
  }
  function Oi(t, e) {
    return Oi = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, Oi(t, e);
  }
  var bm = function(t) {
    vm(e, t);
    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.type = ym.ID, i;
    }
    var r = e.prototype;
    return r.valueToString = function() {
      return "#" + t.prototype.valueToString.call(this);
    }, e;
  }(gm.default);
  zt.default = bm;
  _l.exports = zt.default;
});
var Yr = S((Vt, Rl) => {
  "use strict";
  Vt.__esModule = true;
  Vt.default = void 0;
  var xm = Pl(Gr()), Sm = Lt(), km = Pl(Ce());
  function Pl(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Tl(t, e) {
    for (var r = 0; r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function Cm(t, e, r) {
    return e && Tl(t.prototype, e), r && Tl(t, r), t;
  }
  function Em(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ti(t, e);
  }
  function Ti(t, e) {
    return Ti = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, Ti(t, e);
  }
  var Am = function(t) {
    Em(e, t);
    function e() {
      return t.apply(this, arguments) || this;
    }
    var r = e.prototype;
    return r.qualifiedName = function(i) {
      return this.namespace ? this.namespaceString + "|" + i : i;
    }, r.valueToString = function() {
      return this.qualifiedName(t.prototype.valueToString.call(this));
    }, Cm(e, [{ key: "namespace", get: function() {
      return this._namespace;
    }, set: function(i) {
      if (i === true || i === "*" || i === "&") {
        this._namespace = i, this.raws && delete this.raws.namespace;
        return;
      }
      var s = (0, xm.default)(i, { isIdentifier: true });
      this._namespace = i, s !== i ? ((0, Sm.ensureObject)(this, "raws"), this.raws.namespace = s) : this.raws && delete this.raws.namespace;
    } }, { key: "ns", get: function() {
      return this._namespace;
    }, set: function(i) {
      this.namespace = i;
    } }, { key: "namespaceString", get: function() {
      if (this.namespace) {
        var i = this.stringifyProperty("namespace");
        return i === true ? "" : i;
      } else
        return "";
    } }]), e;
  }(km.default);
  Vt.default = Am;
  Rl.exports = Vt.default;
});
var Ri = S((Wt, Il) => {
  "use strict";
  Wt.__esModule = true;
  Wt.default = void 0;
  var Om = Tm(Yr()), _m = J();
  function Tm(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Pm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Pi(t, e);
  }
  function Pi(t, e) {
    return Pi = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, Pi(t, e);
  }
  var Rm = function(t) {
    Pm(e, t);
    function e(r) {
      var n;
      return n = t.call(this, r) || this, n.type = _m.TAG, n;
    }
    return e;
  }(Om.default);
  Wt.default = Rm;
  Il.exports = Wt.default;
});
var Di = S((Bt, Dl) => {
  "use strict";
  Bt.__esModule = true;
  Bt.default = void 0;
  var Im = Mm(Ce()), Dm = J();
  function Mm(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Lm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ii(t, e);
  }
  function Ii(t, e) {
    return Ii = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, Ii(t, e);
  }
  var Fm = function(t) {
    Lm(e, t);
    function e(r) {
      var n;
      return n = t.call(this, r) || this, n.type = Dm.STRING, n;
    }
    return e;
  }(Im.default);
  Bt.default = Fm;
  Dl.exports = Bt.default;
});
var Li = S((Gt, Ml) => {
  "use strict";
  Gt.__esModule = true;
  Gt.default = void 0;
  var Nm = $m(Br()), qm = J();
  function $m(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Um(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Mi(t, e);
  }
  function Mi(t, e) {
    return Mi = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, Mi(t, e);
  }
  var jm = function(t) {
    Um(e, t);
    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.type = qm.PSEUDO, i;
    }
    var r = e.prototype;
    return r.toString = function() {
      var i = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.rawSpaceBefore, this.stringifyProperty("value"), i, this.rawSpaceAfter].join("");
    }, e;
  }(Nm.default);
  Gt.default = jm;
  Ml.exports = Gt.default;
});
var Fl = S((Ax, Ll) => {
  Ll.exports = zm;
  function zm(t, e) {
    if (Fi("noDeprecation"))
      return t;
    var r = false;
    function n() {
      if (!r) {
        if (Fi("throwDeprecation"))
          throw new Error(e);
        Fi("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
      }
      return t.apply(this, arguments);
    }
    return n;
  }
  function Fi(t) {
    try {
      if (!global.localStorage)
        return false;
    } catch {
      return false;
    }
    var e = global.localStorage[t];
    return e == null ? false : String(e).toLowerCase() === "true";
  }
});
var zi = S((Qt) => {
  "use strict";
  Qt.__esModule = true;
  Qt.unescapeValue = ji;
  Qt.default = void 0;
  var Yt = Ui(Gr()), Vm = Ui(Ur()), Wm = Ui(Yr()), Bm = J(), Ni;
  function Ui(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Nl(t, e) {
    for (var r = 0; r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function Gm(t, e, r) {
    return e && Nl(t.prototype, e), r && Nl(t, r), t;
  }
  function Ym(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, $i(t, e);
  }
  function $i(t, e) {
    return $i = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, $i(t, e);
  }
  var Ht = Fl(), Hm = /^('|")([^]*)\1$/, Qm = Ht(function() {
  }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), Jm = Ht(function() {
  }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), Xm = Ht(function() {
  }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
  function ji(t) {
    var e = false, r = null, n = t, i = n.match(Hm);
    return i && (r = i[1], n = i[2]), n = (0, Vm.default)(n), n !== t && (e = true), { deprecatedUsage: e, unescaped: n, quoteMark: r };
  }
  function Km(t) {
    if (t.quoteMark !== void 0 || t.value === void 0)
      return t;
    Xm();
    var e = ji(t.value), r = e.quoteMark, n = e.unescaped;
    return t.raws || (t.raws = {}), t.raws.value === void 0 && (t.raws.value = t.value), t.value = n, t.quoteMark = r, t;
  }
  var Hr2 = function(t) {
    Ym(e, t);
    function e(n) {
      var i;
      return n === void 0 && (n = {}), i = t.call(this, Km(n)) || this, i.type = Bm.ATTRIBUTE, i.raws = i.raws || {}, Object.defineProperty(i.raws, "unquoted", { get: Ht(function() {
        return i.value;
      }, "attr.raws.unquoted is deprecated. Call attr.value instead."), set: Ht(function() {
        return i.value;
      }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") }), i._constructed = true, i;
    }
    var r = e.prototype;
    return r.getQuotedValue = function(i) {
      i === void 0 && (i = {});
      var s = this._determineQuoteMark(i), a = qi[s], o2 = (0, Yt.default)(this._value, a);
      return o2;
    }, r._determineQuoteMark = function(i) {
      return i.smart ? this.smartQuoteMark(i) : this.preferredQuoteMark(i);
    }, r.setValue = function(i, s) {
      s === void 0 && (s = {}), this._value = i, this._quoteMark = this._determineQuoteMark(s), this._syncRawValue();
    }, r.smartQuoteMark = function(i) {
      var s = this.value, a = s.replace(/[^']/g, "").length, o2 = s.replace(/[^"]/g, "").length;
      if (a + o2 === 0) {
        var l = (0, Yt.default)(s, { isIdentifier: true });
        if (l === s)
          return e.NO_QUOTE;
        var u = this.preferredQuoteMark(i);
        if (u === e.NO_QUOTE) {
          var f = this.quoteMark || i.quoteMark || e.DOUBLE_QUOTE, p = qi[f], c = (0, Yt.default)(s, p);
          if (c.length < l.length)
            return f;
        }
        return u;
      } else
        return o2 === a ? this.preferredQuoteMark(i) : o2 < a ? e.DOUBLE_QUOTE : e.SINGLE_QUOTE;
    }, r.preferredQuoteMark = function(i) {
      var s = i.preferCurrentQuoteMark ? this.quoteMark : i.quoteMark;
      return s === void 0 && (s = i.preferCurrentQuoteMark ? i.quoteMark : this.quoteMark), s === void 0 && (s = e.DOUBLE_QUOTE), s;
    }, r._syncRawValue = function() {
      var i = (0, Yt.default)(this._value, qi[this.quoteMark]);
      i === this._value ? this.raws && delete this.raws.value : this.raws.value = i;
    }, r._handleEscapes = function(i, s) {
      if (this._constructed) {
        var a = (0, Yt.default)(s, { isIdentifier: true });
        a !== s ? this.raws[i] = a : delete this.raws[i];
      }
    }, r._spacesFor = function(i) {
      var s = { before: "", after: "" }, a = this.spaces[i] || {}, o2 = this.raws.spaces && this.raws.spaces[i] || {};
      return Object.assign(s, a, o2);
    }, r._stringFor = function(i, s, a) {
      s === void 0 && (s = i), a === void 0 && (a = ql);
      var o2 = this._spacesFor(s);
      return a(this.stringifyProperty(i), o2);
    }, r.offsetOf = function(i) {
      var s = 1, a = this._spacesFor("attribute");
      if (s += a.before.length, i === "namespace" || i === "ns")
        return this.namespace ? s : -1;
      if (i === "attributeNS" || (s += this.namespaceString.length, this.namespace && (s += 1), i === "attribute"))
        return s;
      s += this.stringifyProperty("attribute").length, s += a.after.length;
      var o2 = this._spacesFor("operator");
      s += o2.before.length;
      var l = this.stringifyProperty("operator");
      if (i === "operator")
        return l ? s : -1;
      s += l.length, s += o2.after.length;
      var u = this._spacesFor("value");
      s += u.before.length;
      var f = this.stringifyProperty("value");
      if (i === "value")
        return f ? s : -1;
      s += f.length, s += u.after.length;
      var p = this._spacesFor("insensitive");
      return s += p.before.length, i === "insensitive" && this.insensitive ? s : -1;
    }, r.toString = function() {
      var i = this, s = [this.rawSpaceBefore, "["];
      return s.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (s.push(this._stringFor("operator")), s.push(this._stringFor("value")), s.push(this._stringFor("insensitiveFlag", "insensitive", function(a, o2) {
        return a.length > 0 && !i.quoted && o2.before.length === 0 && !(i.spaces.value && i.spaces.value.after) && (o2.before = " "), ql(a, o2);
      }))), s.push("]"), s.push(this.rawSpaceAfter), s.join("");
    }, Gm(e, [{ key: "quoted", get: function() {
      var i = this.quoteMark;
      return i === "'" || i === '"';
    }, set: function(i) {
      Jm();
    } }, { key: "quoteMark", get: function() {
      return this._quoteMark;
    }, set: function(i) {
      if (!this._constructed) {
        this._quoteMark = i;
        return;
      }
      this._quoteMark !== i && (this._quoteMark = i, this._syncRawValue());
    } }, { key: "qualifiedAttribute", get: function() {
      return this.qualifiedName(this.raws.attribute || this.attribute);
    } }, { key: "insensitiveFlag", get: function() {
      return this.insensitive ? "i" : "";
    } }, { key: "value", get: function() {
      return this._value;
    }, set: function(i) {
      if (this._constructed) {
        var s = ji(i), a = s.deprecatedUsage, o2 = s.unescaped, l = s.quoteMark;
        if (a && Qm(), o2 === this._value && l === this._quoteMark)
          return;
        this._value = o2, this._quoteMark = l, this._syncRawValue();
      } else
        this._value = i;
    } }, { key: "insensitive", get: function() {
      return this._insensitive;
    }, set: function(i) {
      i || (this._insensitive = false, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = i;
    } }, { key: "attribute", get: function() {
      return this._attribute;
    }, set: function(i) {
      this._handleEscapes("attribute", i), this._attribute = i;
    } }]), e;
  }(Wm.default);
  Qt.default = Hr2;
  Hr2.NO_QUOTE = null;
  Hr2.SINGLE_QUOTE = "'";
  Hr2.DOUBLE_QUOTE = '"';
  var qi = (Ni = { "'": { quotes: "single", wrap: true }, '"': { quotes: "double", wrap: true } }, Ni[null] = { isIdentifier: true }, Ni);
  function ql(t, e) {
    return "" + e.before + t + e.after;
  }
});
var Wi = S((Jt, $l) => {
  "use strict";
  Jt.__esModule = true;
  Jt.default = void 0;
  var Zm = tg(Yr()), eg = J();
  function tg(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function rg(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Vi(t, e);
  }
  function Vi(t, e) {
    return Vi = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, Vi(t, e);
  }
  var ng = function(t) {
    rg(e, t);
    function e(r) {
      var n;
      return n = t.call(this, r) || this, n.type = eg.UNIVERSAL, n.value = "*", n;
    }
    return e;
  }(Zm.default);
  Jt.default = ng;
  $l.exports = Jt.default;
});
var Gi = S((Xt, Ul) => {
  "use strict";
  Xt.__esModule = true;
  Xt.default = void 0;
  var ig = ag(Ce()), sg = J();
  function ag(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function og(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Bi(t, e);
  }
  function Bi(t, e) {
    return Bi = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, Bi(t, e);
  }
  var lg = function(t) {
    og(e, t);
    function e(r) {
      var n;
      return n = t.call(this, r) || this, n.type = sg.COMBINATOR, n;
    }
    return e;
  }(ig.default);
  Xt.default = lg;
  Ul.exports = Xt.default;
});
var Hi = S((Kt, jl) => {
  "use strict";
  Kt.__esModule = true;
  Kt.default = void 0;
  var ug = cg(Ce()), fg = J();
  function cg(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function pg(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Yi(t, e);
  }
  function Yi(t, e) {
    return Yi = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, Yi(t, e);
  }
  var dg = function(t) {
    pg(e, t);
    function e(r) {
      var n;
      return n = t.call(this, r) || this, n.type = fg.NESTING, n.value = "&", n;
    }
    return e;
  }(ug.default);
  Kt.default = dg;
  jl.exports = Kt.default;
});
var Vl = S((Qr, zl) => {
  "use strict";
  Qr.__esModule = true;
  Qr.default = hg;
  function hg(t) {
    return t.sort(function(e, r) {
      return e - r;
    });
  }
  zl.exports = Qr.default;
});
var Qi = S((P) => {
  "use strict";
  P.__esModule = true;
  P.combinator = P.word = P.comment = P.str = P.tab = P.newline = P.feed = P.cr = P.backslash = P.bang = P.slash = P.doubleQuote = P.singleQuote = P.space = P.greaterThan = P.pipe = P.equals = P.plus = P.caret = P.tilde = P.dollar = P.closeSquare = P.openSquare = P.closeParenthesis = P.openParenthesis = P.semicolon = P.colon = P.comma = P.at = P.asterisk = P.ampersand = void 0;
  var mg = 38;
  P.ampersand = mg;
  var gg = 42;
  P.asterisk = gg;
  var yg = 64;
  P.at = yg;
  var wg = 44;
  P.comma = wg;
  var vg = 58;
  P.colon = vg;
  var bg = 59;
  P.semicolon = bg;
  var xg = 40;
  P.openParenthesis = xg;
  var Sg = 41;
  P.closeParenthesis = Sg;
  var kg = 91;
  P.openSquare = kg;
  var Cg = 93;
  P.closeSquare = Cg;
  var Eg = 36;
  P.dollar = Eg;
  var Ag = 126;
  P.tilde = Ag;
  var Og = 94;
  P.caret = Og;
  var _g = 43;
  P.plus = _g;
  var Tg = 61;
  P.equals = Tg;
  var Pg = 124;
  P.pipe = Pg;
  var Rg = 62;
  P.greaterThan = Rg;
  var Ig = 32;
  P.space = Ig;
  var Wl = 39;
  P.singleQuote = Wl;
  var Dg = 34;
  P.doubleQuote = Dg;
  var Mg = 47;
  P.slash = Mg;
  var Lg = 33;
  P.bang = Lg;
  var Fg = 92;
  P.backslash = Fg;
  var Ng = 13;
  P.cr = Ng;
  var qg = 12;
  P.feed = qg;
  var $g = 10;
  P.newline = $g;
  var Ug = 9;
  P.tab = Ug;
  var jg = Wl;
  P.str = jg;
  var zg = -1;
  P.comment = zg;
  var Vg = -2;
  P.word = Vg;
  var Wg = -3;
  P.combinator = Wg;
});
var Yl = S((Zt) => {
  "use strict";
  Zt.__esModule = true;
  Zt.default = Xg;
  Zt.FIELDS = void 0;
  var A = Bg(Qi()), et, q;
  function Gl() {
    if (typeof WeakMap != "function")
      return null;
    var t = /* @__PURE__ */ new WeakMap();
    return Gl = function() {
      return t;
    }, t;
  }
  function Bg(t) {
    if (t && t.__esModule)
      return t;
    if (t === null || typeof t != "object" && typeof t != "function")
      return { default: t };
    var e = Gl();
    if (e && e.has(t))
      return e.get(t);
    var r = {}, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var i in t)
      if (Object.prototype.hasOwnProperty.call(t, i)) {
        var s = n ? Object.getOwnPropertyDescriptor(t, i) : null;
        s && (s.get || s.set) ? Object.defineProperty(r, i, s) : r[i] = t[i];
      }
    return r.default = t, e && e.set(t, r), r;
  }
  var Gg = (et = {}, et[A.tab] = true, et[A.newline] = true, et[A.cr] = true, et[A.feed] = true, et), Yg = (q = {}, q[A.space] = true, q[A.tab] = true, q[A.newline] = true, q[A.cr] = true, q[A.feed] = true, q[A.ampersand] = true, q[A.asterisk] = true, q[A.bang] = true, q[A.comma] = true, q[A.colon] = true, q[A.semicolon] = true, q[A.openParenthesis] = true, q[A.closeParenthesis] = true, q[A.openSquare] = true, q[A.closeSquare] = true, q[A.singleQuote] = true, q[A.doubleQuote] = true, q[A.plus] = true, q[A.pipe] = true, q[A.tilde] = true, q[A.greaterThan] = true, q[A.equals] = true, q[A.dollar] = true, q[A.caret] = true, q[A.slash] = true, q), Ji = {}, Bl = "0123456789abcdefABCDEF";
  for (Jr = 0; Jr < Bl.length; Jr++)
    Ji[Bl.charCodeAt(Jr)] = true;
  var Jr;
  function Hg(t, e) {
    var r = e, n;
    do {
      if (n = t.charCodeAt(r), Yg[n])
        return r - 1;
      n === A.backslash ? r = Qg(t, r) + 1 : r++;
    } while (r < t.length);
    return r - 1;
  }
  function Qg(t, e) {
    var r = e, n = t.charCodeAt(r + 1);
    if (!Gg[n])
      if (Ji[n]) {
        var i = 0;
        do
          r++, i++, n = t.charCodeAt(r + 1);
        while (Ji[n] && i < 6);
        i < 6 && n === A.space && r++;
      } else
        r++;
    return r;
  }
  var Jg = { TYPE: 0, START_LINE: 1, START_COL: 2, END_LINE: 3, END_COL: 4, START_POS: 5, END_POS: 6 };
  Zt.FIELDS = Jg;
  function Xg(t) {
    var e = [], r = t.css.valueOf(), n = r, i = n.length, s = -1, a = 1, o2 = 0, l = 0, u, f, p, c, d, h, y, m, g, w, b, v, C;
    function x(O, E) {
      if (t.safe)
        r += E, g = r.length - 1;
      else
        throw t.error("Unclosed " + O, a, o2 - s, o2);
    }
    for (; o2 < i; ) {
      switch (u = r.charCodeAt(o2), u === A.newline && (s = o2, a += 1), u) {
        case A.space:
        case A.tab:
        case A.newline:
        case A.cr:
        case A.feed:
          g = o2;
          do
            g += 1, u = r.charCodeAt(g), u === A.newline && (s = g, a += 1);
          while (u === A.space || u === A.newline || u === A.tab || u === A.cr || u === A.feed);
          C = A.space, c = a, p = g - s - 1, l = g;
          break;
        case A.plus:
        case A.greaterThan:
        case A.tilde:
        case A.pipe:
          g = o2;
          do
            g += 1, u = r.charCodeAt(g);
          while (u === A.plus || u === A.greaterThan || u === A.tilde || u === A.pipe);
          C = A.combinator, c = a, p = o2 - s, l = g;
          break;
        case A.asterisk:
        case A.ampersand:
        case A.bang:
        case A.comma:
        case A.equals:
        case A.dollar:
        case A.caret:
        case A.openSquare:
        case A.closeSquare:
        case A.colon:
        case A.semicolon:
        case A.openParenthesis:
        case A.closeParenthesis:
          g = o2, C = u, c = a, p = o2 - s, l = g + 1;
          break;
        case A.singleQuote:
        case A.doubleQuote:
          v = u === A.singleQuote ? "'" : '"', g = o2;
          do
            for (d = false, g = r.indexOf(v, g + 1), g === -1 && x("quote", v), h = g; r.charCodeAt(h - 1) === A.backslash; )
              h -= 1, d = !d;
          while (d);
          C = A.str, c = a, p = o2 - s, l = g + 1;
          break;
        default:
          u === A.slash && r.charCodeAt(o2 + 1) === A.asterisk ? (g = r.indexOf("*/", o2 + 2) + 1, g === 0 && x("comment", "*/"), f = r.slice(o2, g + 1), m = f.split(`
`), y = m.length - 1, y > 0 ? (w = a + y, b = g - m[y].length) : (w = a, b = s), C = A.comment, a = w, c = w, p = g - b) : u === A.slash ? (g = o2, C = u, c = a, p = o2 - s, l = g + 1) : (g = Hg(r, o2), C = A.word, c = a, p = g - s), l = g + 1;
          break;
      }
      e.push([C, a, o2 - s, c, p, o2, l]), b && (s = b, b = null), o2 = l;
    }
    return e;
  }
});
var tu = S((er, eu) => {
  "use strict";
  er.__esModule = true;
  er.default = void 0;
  var Kg = le(vi()), Xi = le(xi()), Zg = le(Ci()), Hl = le(Ai()), ey = le(_i()), ty = le(Ri()), Ki = le(Di()), ry = le(Li()), Ql = Xr(zi()), ny = le(Wi()), Zi = le(Gi()), iy = le(Hi()), sy = le(Vl()), k = Xr(Yl()), _ = Xr(Qi()), ay = Xr(J()), V2 = Lt(), Ve, es;
  function Zl() {
    if (typeof WeakMap != "function")
      return null;
    var t = /* @__PURE__ */ new WeakMap();
    return Zl = function() {
      return t;
    }, t;
  }
  function Xr(t) {
    if (t && t.__esModule)
      return t;
    if (t === null || typeof t != "object" && typeof t != "function")
      return { default: t };
    var e = Zl();
    if (e && e.has(t))
      return e.get(t);
    var r = {}, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var i in t)
      if (Object.prototype.hasOwnProperty.call(t, i)) {
        var s = n ? Object.getOwnPropertyDescriptor(t, i) : null;
        s && (s.get || s.set) ? Object.defineProperty(r, i, s) : r[i] = t[i];
      }
    return r.default = t, e && e.set(t, r), r;
  }
  function le(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Jl(t, e) {
    for (var r = 0; r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function oy(t, e, r) {
    return e && Jl(t.prototype, e), r && Jl(t, r), t;
  }
  var ns = (Ve = {}, Ve[_.space] = true, Ve[_.cr] = true, Ve[_.feed] = true, Ve[_.newline] = true, Ve[_.tab] = true, Ve), ly = Object.assign({}, ns, (es = {}, es[_.comment] = true, es));
  function Xl(t) {
    return { line: t[k.FIELDS.START_LINE], column: t[k.FIELDS.START_COL] };
  }
  function Kl(t) {
    return { line: t[k.FIELDS.END_LINE], column: t[k.FIELDS.END_COL] };
  }
  function We(t, e, r, n) {
    return { start: { line: t, column: e }, end: { line: r, column: n } };
  }
  function tt(t) {
    return We(t[k.FIELDS.START_LINE], t[k.FIELDS.START_COL], t[k.FIELDS.END_LINE], t[k.FIELDS.END_COL]);
  }
  function ts(t, e) {
    if (!!t)
      return We(t[k.FIELDS.START_LINE], t[k.FIELDS.START_COL], e[k.FIELDS.END_LINE], e[k.FIELDS.END_COL]);
  }
  function rt(t, e) {
    var r = t[e];
    if (typeof r == "string")
      return r.indexOf("\\") !== -1 && ((0, V2.ensureObject)(t, "raws"), t[e] = (0, V2.unesc)(r), t.raws[e] === void 0 && (t.raws[e] = r)), t;
  }
  function rs(t, e) {
    for (var r = -1, n = []; (r = t.indexOf(e, r + 1)) !== -1; )
      n.push(r);
    return n;
  }
  function uy() {
    var t = Array.prototype.concat.apply([], arguments);
    return t.filter(function(e, r) {
      return r === t.indexOf(e);
    });
  }
  var fy = function() {
    function t(r, n) {
      n === void 0 && (n = {}), this.rule = r, this.options = Object.assign({ lossy: false, safe: false }, n), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, k.default)({ css: this.css, error: this._errorGenerator(), safe: this.options.safe });
      var i = ts(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new Kg.default({ source: i }), this.root.errorGenerator = this._errorGenerator();
      var s = new Xi.default({ source: { start: { line: 1, column: 1 } } });
      this.root.append(s), this.current = s, this.loop();
    }
    var e = t.prototype;
    return e._errorGenerator = function() {
      var n = this;
      return function(i, s) {
        return typeof n.rule == "string" ? new Error(i) : n.rule.error(i, s);
      };
    }, e.attribute = function() {
      var n = [], i = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[k.FIELDS.TYPE] !== _.closeSquare; )
        n.push(this.currToken), this.position++;
      if (this.currToken[k.FIELDS.TYPE] !== _.closeSquare)
        return this.expected("closing square bracket", this.currToken[k.FIELDS.START_POS]);
      var s = n.length, a = { source: We(i[1], i[2], this.currToken[3], this.currToken[4]), sourceIndex: i[k.FIELDS.START_POS] };
      if (s === 1 && !~[_.word].indexOf(n[0][k.FIELDS.TYPE]))
        return this.expected("attribute", n[0][k.FIELDS.START_POS]);
      for (var o2 = 0, l = "", u = "", f = null, p = false; o2 < s; ) {
        var c = n[o2], d = this.content(c), h = n[o2 + 1];
        switch (c[k.FIELDS.TYPE]) {
          case _.space:
            if (p = true, this.options.lossy)
              break;
            if (f) {
              (0, V2.ensureObject)(a, "spaces", f);
              var y = a.spaces[f].after || "";
              a.spaces[f].after = y + d;
              var m = (0, V2.getProp)(a, "raws", "spaces", f, "after") || null;
              m && (a.raws.spaces[f].after = m + d);
            } else
              l = l + d, u = u + d;
            break;
          case _.asterisk:
            if (h[k.FIELDS.TYPE] === _.equals)
              a.operator = d, f = "operator";
            else if ((!a.namespace || f === "namespace" && !p) && h) {
              l && ((0, V2.ensureObject)(a, "spaces", "attribute"), a.spaces.attribute.before = l, l = ""), u && ((0, V2.ensureObject)(a, "raws", "spaces", "attribute"), a.raws.spaces.attribute.before = l, u = ""), a.namespace = (a.namespace || "") + d;
              var g = (0, V2.getProp)(a, "raws", "namespace") || null;
              g && (a.raws.namespace += d), f = "namespace";
            }
            p = false;
            break;
          case _.dollar:
            if (f === "value") {
              var w = (0, V2.getProp)(a, "raws", "value");
              a.value += "$", w && (a.raws.value = w + "$");
              break;
            }
          case _.caret:
            h[k.FIELDS.TYPE] === _.equals && (a.operator = d, f = "operator"), p = false;
            break;
          case _.combinator:
            if (d === "~" && h[k.FIELDS.TYPE] === _.equals && (a.operator = d, f = "operator"), d !== "|") {
              p = false;
              break;
            }
            h[k.FIELDS.TYPE] === _.equals ? (a.operator = d, f = "operator") : !a.namespace && !a.attribute && (a.namespace = true), p = false;
            break;
          case _.word:
            if (h && this.content(h) === "|" && n[o2 + 2] && n[o2 + 2][k.FIELDS.TYPE] !== _.equals && !a.operator && !a.namespace)
              a.namespace = d, f = "namespace";
            else if (!a.attribute || f === "attribute" && !p) {
              l && ((0, V2.ensureObject)(a, "spaces", "attribute"), a.spaces.attribute.before = l, l = ""), u && ((0, V2.ensureObject)(a, "raws", "spaces", "attribute"), a.raws.spaces.attribute.before = u, u = ""), a.attribute = (a.attribute || "") + d;
              var b = (0, V2.getProp)(a, "raws", "attribute") || null;
              b && (a.raws.attribute += d), f = "attribute";
            } else if (!a.value && a.value !== "" || f === "value" && !(p || a.quoteMark)) {
              var v = (0, V2.unesc)(d), C = (0, V2.getProp)(a, "raws", "value") || "", x = a.value || "";
              a.value = x + v, a.quoteMark = null, (v !== d || C) && ((0, V2.ensureObject)(a, "raws"), a.raws.value = (C || x) + d), f = "value";
            } else {
              var O = d === "i" || d === "I";
              (a.value || a.value === "") && (a.quoteMark || p) ? (a.insensitive = O, (!O || d === "I") && ((0, V2.ensureObject)(a, "raws"), a.raws.insensitiveFlag = d), f = "insensitive", l && ((0, V2.ensureObject)(a, "spaces", "insensitive"), a.spaces.insensitive.before = l, l = ""), u && ((0, V2.ensureObject)(a, "raws", "spaces", "insensitive"), a.raws.spaces.insensitive.before = u, u = "")) : (a.value || a.value === "") && (f = "value", a.value += d, a.raws.value && (a.raws.value += d));
            }
            p = false;
            break;
          case _.str:
            if (!a.attribute || !a.operator)
              return this.error("Expected an attribute followed by an operator preceding the string.", { index: c[k.FIELDS.START_POS] });
            var E = (0, Ql.unescapeValue)(d), R = E.unescaped, L = E.quoteMark;
            a.value = R, a.quoteMark = L, f = "value", (0, V2.ensureObject)(a, "raws"), a.raws.value = d, p = false;
            break;
          case _.equals:
            if (!a.attribute)
              return this.expected("attribute", c[k.FIELDS.START_POS], d);
            if (a.value)
              return this.error('Unexpected "=" found; an operator was already defined.', { index: c[k.FIELDS.START_POS] });
            a.operator = a.operator ? a.operator + d : d, f = "operator", p = false;
            break;
          case _.comment:
            if (f)
              if (p || h && h[k.FIELDS.TYPE] === _.space || f === "insensitive") {
                var B = (0, V2.getProp)(a, "spaces", f, "after") || "", Q = (0, V2.getProp)(a, "raws", "spaces", f, "after") || B;
                (0, V2.ensureObject)(a, "raws", "spaces", f), a.raws.spaces[f].after = Q + d;
              } else {
                var K = a[f] || "", $e = (0, V2.getProp)(a, "raws", f) || K;
                (0, V2.ensureObject)(a, "raws"), a.raws[f] = $e + d;
              }
            else
              u = u + d;
            break;
          default:
            return this.error('Unexpected "' + d + '" found.', { index: c[k.FIELDS.START_POS] });
        }
        o2++;
      }
      rt(a, "attribute"), rt(a, "namespace"), this.newNode(new Ql.default(a)), this.position++;
    }, e.parseWhitespaceEquivalentTokens = function(n) {
      n < 0 && (n = this.tokens.length);
      var i = this.position, s = [], a = "", o2 = void 0;
      do
        if (ns[this.currToken[k.FIELDS.TYPE]])
          this.options.lossy || (a += this.content());
        else if (this.currToken[k.FIELDS.TYPE] === _.comment) {
          var l = {};
          a && (l.before = a, a = ""), o2 = new Hl.default({ value: this.content(), source: tt(this.currToken), sourceIndex: this.currToken[k.FIELDS.START_POS], spaces: l }), s.push(o2);
        }
      while (++this.position < n);
      if (a) {
        if (o2)
          o2.spaces.after = a;
        else if (!this.options.lossy) {
          var u = this.tokens[i], f = this.tokens[this.position - 1];
          s.push(new Ki.default({ value: "", source: We(u[k.FIELDS.START_LINE], u[k.FIELDS.START_COL], f[k.FIELDS.END_LINE], f[k.FIELDS.END_COL]), sourceIndex: u[k.FIELDS.START_POS], spaces: { before: a, after: "" } }));
        }
      }
      return s;
    }, e.convertWhitespaceNodesToSpace = function(n, i) {
      var s = this;
      i === void 0 && (i = false);
      var a = "", o2 = "";
      n.forEach(function(u) {
        var f = s.lossySpace(u.spaces.before, i), p = s.lossySpace(u.rawSpaceBefore, i);
        a += f + s.lossySpace(u.spaces.after, i && f.length === 0), o2 += f + u.value + s.lossySpace(u.rawSpaceAfter, i && p.length === 0);
      }), o2 === a && (o2 = void 0);
      var l = { space: a, rawSpace: o2 };
      return l;
    }, e.isNamedCombinator = function(n) {
      return n === void 0 && (n = this.position), this.tokens[n + 0] && this.tokens[n + 0][k.FIELDS.TYPE] === _.slash && this.tokens[n + 1] && this.tokens[n + 1][k.FIELDS.TYPE] === _.word && this.tokens[n + 2] && this.tokens[n + 2][k.FIELDS.TYPE] === _.slash;
    }, e.namedCombinator = function() {
      if (this.isNamedCombinator()) {
        var n = this.content(this.tokens[this.position + 1]), i = (0, V2.unesc)(n).toLowerCase(), s = {};
        i !== n && (s.value = "/" + n + "/");
        var a = new Zi.default({ value: "/" + i + "/", source: We(this.currToken[k.FIELDS.START_LINE], this.currToken[k.FIELDS.START_COL], this.tokens[this.position + 2][k.FIELDS.END_LINE], this.tokens[this.position + 2][k.FIELDS.END_COL]), sourceIndex: this.currToken[k.FIELDS.START_POS], raws: s });
        return this.position = this.position + 3, a;
      } else
        this.unexpected();
    }, e.combinator = function() {
      var n = this;
      if (this.content() === "|")
        return this.namespace();
      var i = this.locateNextMeaningfulToken(this.position);
      if (i < 0 || this.tokens[i][k.FIELDS.TYPE] === _.comma) {
        var s = this.parseWhitespaceEquivalentTokens(i);
        if (s.length > 0) {
          var a = this.current.last;
          if (a) {
            var o2 = this.convertWhitespaceNodesToSpace(s), l = o2.space, u = o2.rawSpace;
            u !== void 0 && (a.rawSpaceAfter += u), a.spaces.after += l;
          } else
            s.forEach(function(C) {
              return n.newNode(C);
            });
        }
        return;
      }
      var f = this.currToken, p = void 0;
      i > this.position && (p = this.parseWhitespaceEquivalentTokens(i));
      var c;
      if (this.isNamedCombinator() ? c = this.namedCombinator() : this.currToken[k.FIELDS.TYPE] === _.combinator ? (c = new Zi.default({ value: this.content(), source: tt(this.currToken), sourceIndex: this.currToken[k.FIELDS.START_POS] }), this.position++) : ns[this.currToken[k.FIELDS.TYPE]] || p || this.unexpected(), c) {
        if (p) {
          var d = this.convertWhitespaceNodesToSpace(p), h = d.space, y = d.rawSpace;
          c.spaces.before = h, c.rawSpaceBefore = y;
        }
      } else {
        var m = this.convertWhitespaceNodesToSpace(p, true), g = m.space, w = m.rawSpace;
        w || (w = g);
        var b = {}, v = { spaces: {} };
        g.endsWith(" ") && w.endsWith(" ") ? (b.before = g.slice(0, g.length - 1), v.spaces.before = w.slice(0, w.length - 1)) : g.startsWith(" ") && w.startsWith(" ") ? (b.after = g.slice(1), v.spaces.after = w.slice(1)) : v.value = w, c = new Zi.default({ value: " ", source: ts(f, this.tokens[this.position - 1]), sourceIndex: f[k.FIELDS.START_POS], spaces: b, raws: v });
      }
      return this.currToken && this.currToken[k.FIELDS.TYPE] === _.space && (c.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(c);
    }, e.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = true, this.position++;
        return;
      }
      this.current._inferEndPosition();
      var n = new Xi.default({ source: { start: Xl(this.tokens[this.position + 1]) } });
      this.current.parent.append(n), this.current = n, this.position++;
    }, e.comment = function() {
      var n = this.currToken;
      this.newNode(new Hl.default({ value: this.content(), source: tt(n), sourceIndex: n[k.FIELDS.START_POS] })), this.position++;
    }, e.error = function(n, i) {
      throw this.root.error(n, i);
    }, e.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.", { index: this.currToken[k.FIELDS.START_POS] });
    }, e.missingParenthesis = function() {
      return this.expected("opening parenthesis", this.currToken[k.FIELDS.START_POS]);
    }, e.missingSquareBracket = function() {
      return this.expected("opening square bracket", this.currToken[k.FIELDS.START_POS]);
    }, e.unexpected = function() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[k.FIELDS.START_POS]);
    }, e.namespace = function() {
      var n = this.prevToken && this.content(this.prevToken) || true;
      if (this.nextToken[k.FIELDS.TYPE] === _.word)
        return this.position++, this.word(n);
      if (this.nextToken[k.FIELDS.TYPE] === _.asterisk)
        return this.position++, this.universal(n);
    }, e.nesting = function() {
      if (this.nextToken) {
        var n = this.content(this.nextToken);
        if (n === "|") {
          this.position++;
          return;
        }
      }
      var i = this.currToken;
      this.newNode(new iy.default({ value: this.content(), source: tt(i), sourceIndex: i[k.FIELDS.START_POS] })), this.position++;
    }, e.parentheses = function() {
      var n = this.current.last, i = 1;
      if (this.position++, n && n.type === ay.PSEUDO) {
        var s = new Xi.default({ source: { start: Xl(this.tokens[this.position - 1]) } }), a = this.current;
        for (n.append(s), this.current = s; this.position < this.tokens.length && i; )
          this.currToken[k.FIELDS.TYPE] === _.openParenthesis && i++, this.currToken[k.FIELDS.TYPE] === _.closeParenthesis && i--, i ? this.parse() : (this.current.source.end = Kl(this.currToken), this.current.parent.source.end = Kl(this.currToken), this.position++);
        this.current = a;
      } else {
        for (var o2 = this.currToken, l = "(", u; this.position < this.tokens.length && i; )
          this.currToken[k.FIELDS.TYPE] === _.openParenthesis && i++, this.currToken[k.FIELDS.TYPE] === _.closeParenthesis && i--, u = this.currToken, l += this.parseParenthesisToken(this.currToken), this.position++;
        n ? n.appendToPropertyAndEscape("value", l, l) : this.newNode(new Ki.default({ value: l, source: We(o2[k.FIELDS.START_LINE], o2[k.FIELDS.START_COL], u[k.FIELDS.END_LINE], u[k.FIELDS.END_COL]), sourceIndex: o2[k.FIELDS.START_POS] }));
      }
      if (i)
        return this.expected("closing parenthesis", this.currToken[k.FIELDS.START_POS]);
    }, e.pseudo = function() {
      for (var n = this, i = "", s = this.currToken; this.currToken && this.currToken[k.FIELDS.TYPE] === _.colon; )
        i += this.content(), this.position++;
      if (!this.currToken)
        return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      if (this.currToken[k.FIELDS.TYPE] === _.word)
        this.splitWord(false, function(a, o2) {
          i += a, n.newNode(new ry.default({ value: i, source: ts(s, n.currToken), sourceIndex: s[k.FIELDS.START_POS] })), o2 > 1 && n.nextToken && n.nextToken[k.FIELDS.TYPE] === _.openParenthesis && n.error("Misplaced parenthesis.", { index: n.nextToken[k.FIELDS.START_POS] });
        });
      else
        return this.expected(["pseudo-class", "pseudo-element"], this.currToken[k.FIELDS.START_POS]);
    }, e.space = function() {
      var n = this.content();
      this.position === 0 || this.prevToken[k.FIELDS.TYPE] === _.comma || this.prevToken[k.FIELDS.TYPE] === _.openParenthesis || this.current.nodes.every(function(i) {
        return i.type === "comment";
      }) ? (this.spaces = this.optionalSpace(n), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[k.FIELDS.TYPE] === _.comma || this.nextToken[k.FIELDS.TYPE] === _.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(n), this.position++) : this.combinator();
    }, e.string = function() {
      var n = this.currToken;
      this.newNode(new Ki.default({ value: this.content(), source: tt(n), sourceIndex: n[k.FIELDS.START_POS] })), this.position++;
    }, e.universal = function(n) {
      var i = this.nextToken;
      if (i && this.content(i) === "|")
        return this.position++, this.namespace();
      var s = this.currToken;
      this.newNode(new ny.default({ value: this.content(), source: tt(s), sourceIndex: s[k.FIELDS.START_POS] }), n), this.position++;
    }, e.splitWord = function(n, i) {
      for (var s = this, a = this.nextToken, o2 = this.content(); a && ~[_.dollar, _.caret, _.equals, _.word].indexOf(a[k.FIELDS.TYPE]); ) {
        this.position++;
        var l = this.content();
        if (o2 += l, l.lastIndexOf("\\") === l.length - 1) {
          var u = this.nextToken;
          u && u[k.FIELDS.TYPE] === _.space && (o2 += this.requiredSpace(this.content(u)), this.position++);
        }
        a = this.nextToken;
      }
      var f = rs(o2, ".").filter(function(h) {
        var y = o2[h - 1] === "\\", m = /^\d+\.\d+%$/.test(o2);
        return !y && !m;
      }), p = rs(o2, "#").filter(function(h) {
        return o2[h - 1] !== "\\";
      }), c = rs(o2, "#{");
      c.length && (p = p.filter(function(h) {
        return !~c.indexOf(h);
      }));
      var d = (0, sy.default)(uy([0].concat(f, p)));
      d.forEach(function(h, y) {
        var m = d[y + 1] || o2.length, g = o2.slice(h, m);
        if (y === 0 && i)
          return i.call(s, g, d.length);
        var w, b = s.currToken, v = b[k.FIELDS.START_POS] + d[y], C = We(b[1], b[2] + h, b[3], b[2] + (m - 1));
        if (~f.indexOf(h)) {
          var x = { value: g.slice(1), source: C, sourceIndex: v };
          w = new Zg.default(rt(x, "value"));
        } else if (~p.indexOf(h)) {
          var O = { value: g.slice(1), source: C, sourceIndex: v };
          w = new ey.default(rt(O, "value"));
        } else {
          var E = { value: g, source: C, sourceIndex: v };
          rt(E, "value"), w = new ty.default(E);
        }
        s.newNode(w, n), n = null;
      }), this.position++;
    }, e.word = function(n) {
      var i = this.nextToken;
      return i && this.content(i) === "|" ? (this.position++, this.namespace()) : this.splitWord(n);
    }, e.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(true);
      return this.current._inferEndPosition(), this.root;
    }, e.parse = function(n) {
      switch (this.currToken[k.FIELDS.TYPE]) {
        case _.space:
          this.space();
          break;
        case _.comment:
          this.comment();
          break;
        case _.openParenthesis:
          this.parentheses();
          break;
        case _.closeParenthesis:
          n && this.missingParenthesis();
          break;
        case _.openSquare:
          this.attribute();
          break;
        case _.dollar:
        case _.caret:
        case _.equals:
        case _.word:
          this.word();
          break;
        case _.colon:
          this.pseudo();
          break;
        case _.comma:
          this.comma();
          break;
        case _.asterisk:
          this.universal();
          break;
        case _.ampersand:
          this.nesting();
          break;
        case _.slash:
        case _.combinator:
          this.combinator();
          break;
        case _.str:
          this.string();
          break;
        case _.closeSquare:
          this.missingSquareBracket();
        case _.semicolon:
          this.missingBackslash();
        default:
          this.unexpected();
      }
    }, e.expected = function(n, i, s) {
      if (Array.isArray(n)) {
        var a = n.pop();
        n = n.join(", ") + " or " + a;
      }
      var o2 = /^[aeiou]/.test(n[0]) ? "an" : "a";
      return s ? this.error("Expected " + o2 + " " + n + ', found "' + s + '" instead.', { index: i }) : this.error("Expected " + o2 + " " + n + ".", { index: i });
    }, e.requiredSpace = function(n) {
      return this.options.lossy ? " " : n;
    }, e.optionalSpace = function(n) {
      return this.options.lossy ? "" : n;
    }, e.lossySpace = function(n, i) {
      return this.options.lossy ? i ? " " : "" : n;
    }, e.parseParenthesisToken = function(n) {
      var i = this.content(n);
      return n[k.FIELDS.TYPE] === _.space ? this.requiredSpace(i) : i;
    }, e.newNode = function(n, i) {
      return i && (/^ +$/.test(i) && (this.options.lossy || (this.spaces = (this.spaces || "") + i), i = true), n.namespace = i, rt(n, "namespace")), this.spaces && (n.spaces.before = this.spaces, this.spaces = ""), this.current.append(n);
    }, e.content = function(n) {
      return n === void 0 && (n = this.currToken), this.css.slice(n[k.FIELDS.START_POS], n[k.FIELDS.END_POS]);
    }, e.locateNextMeaningfulToken = function(n) {
      n === void 0 && (n = this.position + 1);
      for (var i = n; i < this.tokens.length; )
        if (ly[this.tokens[i][k.FIELDS.TYPE]]) {
          i++;
          continue;
        } else
          return i;
      return -1;
    }, oy(t, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), t;
  }();
  er.default = fy;
  eu.exports = er.default;
});
var nu = S((tr, ru) => {
  "use strict";
  tr.__esModule = true;
  tr.default = void 0;
  var cy = py(tu());
  function py(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var dy = function() {
    function t(r, n) {
      this.func = r || function() {
      }, this.funcRes = null, this.options = n;
    }
    var e = t.prototype;
    return e._shouldUpdateSelector = function(n, i) {
      i === void 0 && (i = {});
      var s = Object.assign({}, this.options, i);
      return s.updateSelector === false ? false : typeof n != "string";
    }, e._isLossy = function(n) {
      n === void 0 && (n = {});
      var i = Object.assign({}, this.options, n);
      return i.lossless === false;
    }, e._root = function(n, i) {
      i === void 0 && (i = {});
      var s = new cy.default(n, this._parseOptions(i));
      return s.root;
    }, e._parseOptions = function(n) {
      return { lossy: this._isLossy(n) };
    }, e._run = function(n, i) {
      var s = this;
      return i === void 0 && (i = {}), new Promise(function(a, o2) {
        try {
          var l = s._root(n, i);
          Promise.resolve(s.func(l)).then(function(u) {
            var f = void 0;
            return s._shouldUpdateSelector(n, i) && (f = l.toString(), n.selector = f), { transform: u, root: l, string: f };
          }).then(a, o2);
        } catch (u) {
          o2(u);
          return;
        }
      });
    }, e._runSync = function(n, i) {
      i === void 0 && (i = {});
      var s = this._root(n, i), a = this.func(s);
      if (a && typeof a.then == "function")
        throw new Error("Selector processor returned a promise to a synchronous call.");
      var o2 = void 0;
      return i.updateSelector && typeof n != "string" && (o2 = s.toString(), n.selector = o2), { transform: a, root: s, string: o2 };
    }, e.ast = function(n, i) {
      return this._run(n, i).then(function(s) {
        return s.root;
      });
    }, e.astSync = function(n, i) {
      return this._runSync(n, i).root;
    }, e.transform = function(n, i) {
      return this._run(n, i).then(function(s) {
        return s.transform;
      });
    }, e.transformSync = function(n, i) {
      return this._runSync(n, i).transform;
    }, e.process = function(n, i) {
      return this._run(n, i).then(function(s) {
        return s.string || s.root.toString();
      });
    }, e.processSync = function(n, i) {
      var s = this._runSync(n, i);
      return s.string || s.root.toString();
    }, t;
  }();
  tr.default = dy;
  ru.exports = tr.default;
});
var iu = S((j) => {
  "use strict";
  j.__esModule = true;
  j.universal = j.tag = j.string = j.selector = j.root = j.pseudo = j.nesting = j.id = j.comment = j.combinator = j.className = j.attribute = void 0;
  var hy = ue(zi()), my = ue(Ci()), gy = ue(Gi()), yy = ue(Ai()), wy = ue(_i()), vy = ue(Hi()), by = ue(Li()), xy = ue(vi()), Sy = ue(xi()), ky = ue(Di()), Cy = ue(Ri()), Ey = ue(Wi());
  function ue(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var Ay = function(e) {
    return new hy.default(e);
  };
  j.attribute = Ay;
  var Oy = function(e) {
    return new my.default(e);
  };
  j.className = Oy;
  var _y = function(e) {
    return new gy.default(e);
  };
  j.combinator = _y;
  var Ty = function(e) {
    return new yy.default(e);
  };
  j.comment = Ty;
  var Py = function(e) {
    return new wy.default(e);
  };
  j.id = Py;
  var Ry = function(e) {
    return new vy.default(e);
  };
  j.nesting = Ry;
  var Iy = function(e) {
    return new by.default(e);
  };
  j.pseudo = Iy;
  var Dy = function(e) {
    return new xy.default(e);
  };
  j.root = Dy;
  var My = function(e) {
    return new Sy.default(e);
  };
  j.selector = My;
  var Ly = function(e) {
    return new ky.default(e);
  };
  j.string = Ly;
  var Fy = function(e) {
    return new Cy.default(e);
  };
  j.tag = Fy;
  var Ny = function(e) {
    return new Ey.default(e);
  };
  j.universal = Ny;
});
var lu = S((M) => {
  "use strict";
  M.__esModule = true;
  M.isNode = is;
  M.isPseudoElement = ou;
  M.isPseudoClass = Hy;
  M.isContainer = Qy;
  M.isNamespace = Jy;
  M.isUniversal = M.isTag = M.isString = M.isSelector = M.isRoot = M.isPseudo = M.isNesting = M.isIdentifier = M.isComment = M.isCombinator = M.isClassName = M.isAttribute = void 0;
  var W = J(), Z, qy = (Z = {}, Z[W.ATTRIBUTE] = true, Z[W.CLASS] = true, Z[W.COMBINATOR] = true, Z[W.COMMENT] = true, Z[W.ID] = true, Z[W.NESTING] = true, Z[W.PSEUDO] = true, Z[W.ROOT] = true, Z[W.SELECTOR] = true, Z[W.STRING] = true, Z[W.TAG] = true, Z[W.UNIVERSAL] = true, Z);
  function is(t) {
    return typeof t == "object" && qy[t.type];
  }
  function fe(t, e) {
    return is(e) && e.type === t;
  }
  var su = fe.bind(null, W.ATTRIBUTE);
  M.isAttribute = su;
  var $y = fe.bind(null, W.CLASS);
  M.isClassName = $y;
  var Uy = fe.bind(null, W.COMBINATOR);
  M.isCombinator = Uy;
  var jy = fe.bind(null, W.COMMENT);
  M.isComment = jy;
  var zy = fe.bind(null, W.ID);
  M.isIdentifier = zy;
  var Vy = fe.bind(null, W.NESTING);
  M.isNesting = Vy;
  var ss = fe.bind(null, W.PSEUDO);
  M.isPseudo = ss;
  var Wy = fe.bind(null, W.ROOT);
  M.isRoot = Wy;
  var By = fe.bind(null, W.SELECTOR);
  M.isSelector = By;
  var Gy = fe.bind(null, W.STRING);
  M.isString = Gy;
  var au = fe.bind(null, W.TAG);
  M.isTag = au;
  var Yy = fe.bind(null, W.UNIVERSAL);
  M.isUniversal = Yy;
  function ou(t) {
    return ss(t) && t.value && (t.value.startsWith("::") || t.value.toLowerCase() === ":before" || t.value.toLowerCase() === ":after" || t.value.toLowerCase() === ":first-letter" || t.value.toLowerCase() === ":first-line");
  }
  function Hy(t) {
    return ss(t) && !ou(t);
  }
  function Qy(t) {
    return !!(is(t) && t.walk);
  }
  function Jy(t) {
    return su(t) || au(t);
  }
});
var uu = S((de) => {
  "use strict";
  de.__esModule = true;
  var as = J();
  Object.keys(as).forEach(function(t) {
    t === "default" || t === "__esModule" || t in de && de[t] === as[t] || (de[t] = as[t]);
  });
  var os = iu();
  Object.keys(os).forEach(function(t) {
    t === "default" || t === "__esModule" || t in de && de[t] === os[t] || (de[t] = os[t]);
  });
  var ls = lu();
  Object.keys(ls).forEach(function(t) {
    t === "default" || t === "__esModule" || t in de && de[t] === ls[t] || (de[t] = ls[t]);
  });
});
var Ae = S((rr, cu) => {
  "use strict";
  rr.__esModule = true;
  rr.default = void 0;
  var Xy = ew(nu()), Ky = Zy(uu());
  function fu() {
    if (typeof WeakMap != "function")
      return null;
    var t = /* @__PURE__ */ new WeakMap();
    return fu = function() {
      return t;
    }, t;
  }
  function Zy(t) {
    if (t && t.__esModule)
      return t;
    if (t === null || typeof t != "object" && typeof t != "function")
      return { default: t };
    var e = fu();
    if (e && e.has(t))
      return e.get(t);
    var r = {}, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var i in t)
      if (Object.prototype.hasOwnProperty.call(t, i)) {
        var s = n ? Object.getOwnPropertyDescriptor(t, i) : null;
        s && (s.get || s.set) ? Object.defineProperty(r, i, s) : r[i] = t[i];
      }
    return r.default = t, e && e.set(t, r), r;
  }
  function ew(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var us = function(e) {
    return new Xy.default(e);
  };
  Object.assign(us, Ky);
  delete us.__esModule;
  var tw = us;
  rr.default = tw;
  cu.exports = rr.default;
});
var wu = S((Dx, hs) => {
  var { Rule: du, AtRule: rw } = Ze(), hu = Ae();
  function ps(t, e) {
    let r;
    try {
      hu((n) => {
        r = n;
      }).processSync(t);
    } catch (n) {
      throw t.includes(":") ? e ? e.error("Missed semicolon") : n : e ? e.error(n.message) : n;
    }
    return r.at(0);
  }
  function mu(t, e) {
    let r = false;
    return t.each((n) => {
      if (n.type === "nesting") {
        let i = e.clone({});
        n.value !== "&" ? n.replaceWith(ps(n.value.replace("&", i.toString()))) : n.replaceWith(i), r = true;
      } else
        "nodes" in n && n.nodes && mu(n, e) && (r = true);
    }), r;
  }
  function gu(t, e) {
    let r = [];
    return t.selectors.forEach((n) => {
      let i = ps(n, t);
      e.selectors.forEach((s) => {
        if (!s)
          return;
        let a = ps(s, e);
        mu(a, i) || (a.prepend(hu.combinator({ value: " " })), a.prepend(i.clone({}))), r.push(a.toString());
      });
    }), r;
  }
  function Kr(t, e) {
    let r = t.prev();
    for (e.after(t); r && r.type === "comment"; ) {
      let n = r.prev();
      e.after(r), r = n;
    }
    return t;
  }
  function nw(t) {
    return function e(r, n, i, s = i) {
      let a = [];
      if (n.each((o2) => {
        o2.type === "rule" && i ? s && (o2.selectors = gu(r, o2)) : o2.type === "atrule" && o2.nodes ? t[o2.name] ? e(r, o2, s) : n[ds] !== false && a.push(o2) : a.push(o2);
      }), i && a.length) {
        let o2 = r.clone({ nodes: [] });
        for (let l of a)
          o2.append(l);
        n.prepend(o2);
      }
    };
  }
  function fs(t, e, r) {
    let n = new du({ selector: t, nodes: [] });
    return n.append(e), r.after(n), n;
  }
  function pu(t, e) {
    let r = {};
    for (let n of t)
      r[n] = true;
    if (e)
      for (let n of e)
        r[n.replace(/^@/, "")] = true;
    return r;
  }
  function iw(t) {
    t = t.trim();
    let e = t.match(/^\((.*)\)$/);
    if (!e)
      return { type: "basic", selector: t };
    let r = e[1].match(/^(with(?:out)?):(.+)$/);
    if (r) {
      let n = r[1] === "with", i = Object.fromEntries(r[2].trim().split(/\s+/).map((a) => [a, true]));
      if (n && i.all)
        return { type: "noop" };
      let s = (a) => !!i[a];
      return i.all ? s = () => true : n && (s = (a) => a === "all" ? false : !i[a]), { type: "withrules", escapes: s };
    }
    return { type: "unknown" };
  }
  function sw(t) {
    let e = [], r = t.parent;
    for (; r && r instanceof rw; )
      e.push(r), r = r.parent;
    return e;
  }
  function aw(t) {
    let e = t[yu];
    if (!e)
      t.after(t.nodes);
    else {
      let r = t.nodes, n, i = -1, s, a, o2, l = sw(t);
      if (l.forEach((u, f) => {
        if (e(u.name))
          n = u, i = f, a = o2;
        else {
          let p = o2;
          o2 = u.clone({ nodes: [] }), p && o2.append(p), s = s || o2;
        }
      }), n ? a ? (s.append(r), n.after(a)) : n.after(r) : t.after(r), t.next() && n) {
        let u;
        l.slice(0, i + 1).forEach((f, p, c) => {
          let d = u;
          u = f.clone({ nodes: [] }), d && u.append(d);
          let h = [], m = (c[p - 1] || t).next();
          for (; m; )
            h.push(m), m = m.next();
          u.append(h);
        }), u && (a || r[r.length - 1]).after(u);
      }
    }
    t.remove();
  }
  var ds = Symbol("rootRuleMergeSel"), yu = Symbol("rootRuleEscapes");
  function ow(t) {
    let { params: e } = t, { type: r, selector: n, escapes: i } = iw(e);
    if (r === "unknown")
      throw t.error(`Unknown @${t.name} parameter ${JSON.stringify(e)}`);
    if (r === "basic" && n) {
      let s = new du({ selector: n, nodes: t.nodes });
      t.removeAll(), t.append(s);
    }
    t[yu] = i, t[ds] = i ? !i("all") : r === "noop";
  }
  var cs = Symbol("hasRootRule");
  hs.exports = (t = {}) => {
    let e = pu(["media", "supports", "layer"], t.bubble), r = nw(e), n = pu(["document", "font-face", "keyframes", "-webkit-keyframes", "-moz-keyframes"], t.unwrap), i = (t.rootRuleName || "at-root").replace(/^@/, ""), s = t.preserveEmpty;
    return { postcssPlugin: "postcss-nested", Once(a) {
      a.walkAtRules(i, (o2) => {
        ow(o2), a[cs] = true;
      });
    }, Rule(a) {
      let o2 = false, l = a, u = false, f = [];
      a.each((p) => {
        p.type === "rule" ? (f.length && (l = fs(a.selector, f, l), f = []), u = true, o2 = true, p.selectors = gu(a, p), l = Kr(p, l)) : p.type === "atrule" ? (f.length && (l = fs(a.selector, f, l), f = []), p.name === i ? (o2 = true, r(a, p, true, p[ds]), l = Kr(p, l)) : e[p.name] ? (u = true, o2 = true, r(a, p, true), l = Kr(p, l)) : n[p.name] ? (u = true, o2 = true, r(a, p, false), l = Kr(p, l)) : u && f.push(p)) : p.type === "decl" && u && f.push(p);
      }), f.length && (l = fs(a.selector, f, l)), o2 && s !== true && (a.raws.semicolon = true, a.nodes.length === 0 && a.remove());
    }, RootExit(a) {
      a[cs] && (a.walkAtRules(i, aw), a[cs] = false);
    } };
  };
  hs.exports.postcss = true;
});
var Su = S((Mx, xu) => {
  "use strict";
  var vu = /-(\w|$)/g, bu = function(e, r) {
    return r.toUpperCase();
  }, lw = function(e) {
    return e = e.toLowerCase(), e === "float" ? "cssFloat" : e.charCodeAt(0) === 45 && e.charCodeAt(1) === 109 && e.charCodeAt(2) === 115 && e.charCodeAt(3) === 45 ? e.substr(1).replace(vu, bu) : e.replace(vu, bu);
  };
  xu.exports = lw;
});
var ys = S((Lx, ku) => {
  var uw = Su(), fw = { boxFlex: true, boxFlexGroup: true, columnCount: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, strokeDashoffset: true, strokeOpacity: true, strokeWidth: true };
  function ms(t) {
    return typeof t.nodes > "u" ? true : gs(t);
  }
  function gs(t) {
    let e, r = {};
    return t.each((n) => {
      if (n.type === "atrule")
        e = "@" + n.name, n.params && (e += " " + n.params), typeof r[e] > "u" ? r[e] = ms(n) : Array.isArray(r[e]) ? r[e].push(ms(n)) : r[e] = [r[e], ms(n)];
      else if (n.type === "rule") {
        let i = gs(n);
        if (r[n.selector])
          for (let s in i)
            r[n.selector][s] = i[s];
        else
          r[n.selector] = i;
      } else if (n.type === "decl") {
        n.prop[0] === "-" && n.prop[1] === "-" ? e = n.prop : e = uw(n.prop);
        let i = n.value;
        !isNaN(n.value) && fw[e] && (i = parseFloat(n.value)), n.important && (i += " !important"), typeof r[e] > "u" ? r[e] = i : Array.isArray(r[e]) ? r[e].push(i) : r[e] = [r[e], i];
      }
    }), r;
  }
  ku.exports = gs;
});
var Zr = S((Fx, Ou) => {
  var nr = Ze(), Cu = /\s*!important\s*$/i, cw = { "box-flex": true, "box-flex-group": true, "column-count": true, flex: true, "flex-grow": true, "flex-positive": true, "flex-shrink": true, "flex-negative": true, "font-weight": true, "line-clamp": true, "line-height": true, opacity: true, order: true, orphans: true, "tab-size": true, widows: true, "z-index": true, zoom: true, "fill-opacity": true, "stroke-dashoffset": true, "stroke-opacity": true, "stroke-width": true };
  function pw(t) {
    return t.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
  }
  function Eu(t, e, r) {
    r === false || r === null || (e.startsWith("--") || (e = pw(e)), typeof r == "number" && (r === 0 || cw[e] ? r = r.toString() : r += "px"), e === "css-float" && (e = "float"), Cu.test(r) ? (r = r.replace(Cu, ""), t.push(nr.decl({ prop: e, value: r, important: true }))) : t.push(nr.decl({ prop: e, value: r })));
  }
  function Au(t, e, r) {
    let n = nr.atRule({ name: e[1], params: e[3] || "" });
    typeof r == "object" && (n.nodes = [], ws(r, n)), t.push(n);
  }
  function ws(t, e) {
    let r, n, i;
    for (r in t)
      if (n = t[r], !(n === null || typeof n > "u"))
        if (r[0] === "@") {
          let s = r.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
          if (Array.isArray(n))
            for (let a of n)
              Au(e, s, a);
          else
            Au(e, s, n);
        } else if (Array.isArray(n))
          for (let s of n)
            Eu(e, r, s);
        else
          typeof n == "object" ? (i = nr.rule({ selector: r }), ws(n, i), e.push(i)) : Eu(e, r, n);
  }
  Ou.exports = function(t) {
    let e = nr.root();
    return ws(t, e), e;
  };
});
var vs = S((Nx, _u) => {
  var dw = ys();
  _u.exports = function(e) {
    return console && console.warn && e.warnings().forEach((r) => {
      let n = r.plugin || "PostCSS";
      console.warn(n + ": " + r.text);
    }), dw(e.root);
  };
});
var Pu = S((qx, Tu) => {
  var hw = Ze(), mw = vs(), gw = Zr();
  Tu.exports = function(e) {
    let r = hw(e);
    return async (n) => {
      let i = await r.process(n, { parser: gw, from: void 0 });
      return mw(i);
    };
  };
});
var Iu = S(($x, Ru) => {
  var yw = Ze(), ww = vs(), vw = Zr();
  Ru.exports = function(t) {
    let e = yw(t);
    return (r) => {
      let n = e.process(r, { parser: vw, from: void 0 });
      return ww(n);
    };
  };
});
var Mu = S((Ux, Du) => {
  var bw = ys(), xw = Zr(), Sw = Pu(), kw = Iu();
  Du.exports = { objectify: bw, parse: xw, async: Sw, sync: kw };
});
var qu = S((Kx, Nu) => {
  "use strict";
  Nu.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
});
var Ms = S((Is, Ds) => {
  (function(t, e) {
    typeof Is == "object" && typeof Ds < "u" ? Ds.exports = function(r, n, i, s, a) {
      for (n = n.split ? n.split(".") : n, s = 0; s < n.length; s++)
        r = r ? r[n[s]] : a;
      return r === a ? i : r;
    } : typeof define == "function" && define.amd ? define(function() {
      return function(r, n, i, s, a) {
        for (n = n.split ? n.split(".") : n, s = 0; s < n.length; s++)
          r = r ? r[n[s]] : a;
        return r === a ? i : r;
      };
    }) : t.dlv = function(r, n, i, s, a) {
      for (n = n.split ? n.split(".") : n, s = 0; s < n.length; s++)
        r = r ? r[n[s]] : a;
      return r === a ? i : r;
    };
  })(Is);
});
var Df = {};
dt(Df, { default: () => Lv });
var Lv;
var Mf = Ye(() => {
  Lv = null;
});
var Vf = S((pk, xn) => {
  (function() {
    "use strict";
    function t(n, i, s) {
      if (!n)
        return null;
      t.caseSensitive || (n = n.toLowerCase());
      var a = t.threshold === null ? null : t.threshold * n.length, o2 = t.thresholdAbsolute, l;
      a !== null && o2 !== null ? l = Math.min(a, o2) : a !== null ? l = a : o2 !== null ? l = o2 : l = null;
      var u, f, p, c, d, h = i.length;
      for (d = 0; d < h; d++)
        if (f = i[d], s && (f = f[s]), !!f && (t.caseSensitive ? p = f : p = f.toLowerCase(), c = r(n, p, l), (l === null || c < l) && (l = c, s && t.returnWinningObject ? u = i[d] : u = f, t.returnFirstMatch)))
          return u;
      return u || t.nullResultValue;
    }
    t.threshold = 0.4, t.thresholdAbsolute = 20, t.caseSensitive = false, t.nullResultValue = null, t.returnWinningObject = null, t.returnFirstMatch = false, typeof xn < "u" && xn.exports ? xn.exports = t : window.didYouMean = t;
    var e = Math.pow(2, 32) - 1;
    function r(n, i, s) {
      s = s || s === 0 ? s : e;
      var a = n.length, o2 = i.length;
      if (a === 0)
        return Math.min(s + 1, o2);
      if (o2 === 0)
        return Math.min(s + 1, a);
      if (Math.abs(a - o2) > s)
        return s + 1;
      var l = [], u, f, p, c, d;
      for (u = 0; u <= o2; u++)
        l[u] = [u];
      for (f = 0; f <= a; f++)
        l[0][f] = f;
      for (u = 1; u <= o2; u++) {
        for (p = e, c = 1, u > s && (c = u - s), d = o2 + 1, d > s + u && (d = s + u), f = 1; f <= a; f++)
          f < c || f > d ? l[u][f] = s + 1 : i.charAt(u - 1) === n.charAt(f - 1) ? l[u][f] = l[u - 1][f - 1] : l[u][f] = Math.min(l[u - 1][f - 1] + 1, Math.min(l[u][f - 1] + 1, l[u - 1][f] + 1)), l[u][f] < p && (p = l[u][f]);
        if (p > s)
          return s + 1;
      }
      return l[o2][a];
    }
  })();
});
var Bf = S((dk, Wf) => {
  var Hs = "(".charCodeAt(0), Qs = ")".charCodeAt(0), Sn = "'".charCodeAt(0), Js = '"'.charCodeAt(0), Xs = "\\".charCodeAt(0), ft = "/".charCodeAt(0), Ks = ",".charCodeAt(0), Zs = ":".charCodeAt(0), kn = "*".charCodeAt(0), Yv = "u".charCodeAt(0), Hv = "U".charCodeAt(0), Qv = "+".charCodeAt(0), Jv = /^[a-f0-9?-]+$/i;
  Wf.exports = function(t) {
    for (var e = [], r = t, n, i, s, a, o2, l, u, f, p = 0, c = r.charCodeAt(p), d = r.length, h = [{ nodes: e }], y = 0, m, g = "", w = "", b = ""; p < d; )
      if (c <= 32) {
        n = p;
        do
          n += 1, c = r.charCodeAt(n);
        while (c <= 32);
        a = r.slice(p, n), s = e[e.length - 1], c === Qs && y ? b = a : s && s.type === "div" ? (s.after = a, s.sourceEndIndex += a.length) : c === Ks || c === Zs || c === ft && r.charCodeAt(n + 1) !== kn && (!m || m && m.type === "function" && m.value !== "calc") ? w = a : e.push({ type: "space", sourceIndex: p, sourceEndIndex: n, value: a }), p = n;
      } else if (c === Sn || c === Js) {
        n = p, i = c === Sn ? "'" : '"', a = { type: "string", sourceIndex: p, quote: i };
        do
          if (o2 = false, n = r.indexOf(i, n + 1), ~n)
            for (l = n; r.charCodeAt(l - 1) === Xs; )
              l -= 1, o2 = !o2;
          else
            r += i, n = r.length - 1, a.unclosed = true;
        while (o2);
        a.value = r.slice(p + 1, n), a.sourceEndIndex = a.unclosed ? n : n + 1, e.push(a), p = n + 1, c = r.charCodeAt(p);
      } else if (c === ft && r.charCodeAt(p + 1) === kn)
        n = r.indexOf("*/", p), a = { type: "comment", sourceIndex: p, sourceEndIndex: n + 2 }, n === -1 && (a.unclosed = true, n = r.length, a.sourceEndIndex = n), a.value = r.slice(p + 2, n), e.push(a), p = n + 2, c = r.charCodeAt(p);
      else if ((c === ft || c === kn) && m && m.type === "function" && m.value === "calc")
        a = r[p], e.push({ type: "word", sourceIndex: p - w.length, sourceEndIndex: p + a.length, value: a }), p += 1, c = r.charCodeAt(p);
      else if (c === ft || c === Ks || c === Zs)
        a = r[p], e.push({ type: "div", sourceIndex: p - w.length, sourceEndIndex: p + a.length, value: a, before: w, after: "" }), w = "", p += 1, c = r.charCodeAt(p);
      else if (Hs === c) {
        n = p;
        do
          n += 1, c = r.charCodeAt(n);
        while (c <= 32);
        if (f = p, a = { type: "function", sourceIndex: p - g.length, value: g, before: r.slice(f + 1, n) }, p = n, g === "url" && c !== Sn && c !== Js) {
          n -= 1;
          do
            if (o2 = false, n = r.indexOf(")", n + 1), ~n)
              for (l = n; r.charCodeAt(l - 1) === Xs; )
                l -= 1, o2 = !o2;
            else
              r += ")", n = r.length - 1, a.unclosed = true;
          while (o2);
          u = n;
          do
            u -= 1, c = r.charCodeAt(u);
          while (c <= 32);
          f < u ? (p !== u + 1 ? a.nodes = [{ type: "word", sourceIndex: p, sourceEndIndex: u + 1, value: r.slice(p, u + 1) }] : a.nodes = [], a.unclosed && u + 1 !== n ? (a.after = "", a.nodes.push({ type: "space", sourceIndex: u + 1, sourceEndIndex: n, value: r.slice(u + 1, n) })) : (a.after = r.slice(u + 1, n), a.sourceEndIndex = n)) : (a.after = "", a.nodes = []), p = n + 1, a.sourceEndIndex = a.unclosed ? n : p, c = r.charCodeAt(p), e.push(a);
        } else
          y += 1, a.after = "", a.sourceEndIndex = p + 1, e.push(a), h.push(a), e = a.nodes = [], m = a;
        g = "";
      } else if (Qs === c && y)
        p += 1, c = r.charCodeAt(p), m.after = b, m.sourceEndIndex += b.length, b = "", y -= 1, h[h.length - 1].sourceEndIndex = p, h.pop(), m = h[y], e = m.nodes;
      else {
        n = p;
        do
          c === Xs && (n += 1), n += 1, c = r.charCodeAt(n);
        while (n < d && !(c <= 32 || c === Sn || c === Js || c === Ks || c === Zs || c === ft || c === Hs || c === kn && m && m.type === "function" && m.value === "calc" || c === ft && m.type === "function" && m.value === "calc" || c === Qs && y));
        a = r.slice(p, n), Hs === c ? g = a : (Yv === a.charCodeAt(0) || Hv === a.charCodeAt(0)) && Qv === a.charCodeAt(1) && Jv.test(a.slice(2)) ? e.push({ type: "unicode-range", sourceIndex: p, sourceEndIndex: n, value: a }) : e.push({ type: "word", sourceIndex: p, sourceEndIndex: n, value: a }), p = n;
      }
    for (p = h.length - 1; p; p -= 1)
      h[p].unclosed = true, h[p].sourceEndIndex = r.length;
    return h[0].nodes;
  };
});
var Yf = S((hk, Gf) => {
  Gf.exports = function t(e, r, n) {
    var i, s, a, o2;
    for (i = 0, s = e.length; i < s; i += 1)
      a = e[i], n || (o2 = r(a, i, e)), o2 !== false && a.type === "function" && Array.isArray(a.nodes) && t(a.nodes, r, n), n && r(a, i, e);
  };
});
var Xf = S((mk, Jf) => {
  function Hf(t, e) {
    var r = t.type, n = t.value, i, s;
    return e && (s = e(t)) !== void 0 ? s : r === "word" || r === "space" ? n : r === "string" ? (i = t.quote || "", i + n + (t.unclosed ? "" : i)) : r === "comment" ? "/*" + n + (t.unclosed ? "" : "*/") : r === "div" ? (t.before || "") + n + (t.after || "") : Array.isArray(t.nodes) ? (i = Qf(t.nodes, e), r !== "function" ? i : n + "(" + (t.before || "") + i + (t.after || "") + (t.unclosed ? "" : ")")) : n;
  }
  function Qf(t, e) {
    var r, n;
    if (Array.isArray(t)) {
      for (r = "", n = t.length - 1; ~n; n -= 1)
        r = Hf(t[n], e) + r;
      return r;
    }
    return Hf(t, e);
  }
  Jf.exports = Qf;
});
var Zf = S((gk, Kf) => {
  var Cn = "-".charCodeAt(0), En = "+".charCodeAt(0), ea = ".".charCodeAt(0), Xv = "e".charCodeAt(0), Kv = "E".charCodeAt(0);
  function Zv(t) {
    var e = t.charCodeAt(0), r;
    if (e === En || e === Cn) {
      if (r = t.charCodeAt(1), r >= 48 && r <= 57)
        return true;
      var n = t.charCodeAt(2);
      return r === ea && n >= 48 && n <= 57;
    }
    return e === ea ? (r = t.charCodeAt(1), r >= 48 && r <= 57) : e >= 48 && e <= 57;
  }
  Kf.exports = function(t) {
    var e = 0, r = t.length, n, i, s;
    if (r === 0 || !Zv(t))
      return false;
    for (n = t.charCodeAt(e), (n === En || n === Cn) && e++; e < r && (n = t.charCodeAt(e), !(n < 48 || n > 57)); )
      e += 1;
    if (n = t.charCodeAt(e), i = t.charCodeAt(e + 1), n === ea && i >= 48 && i <= 57)
      for (e += 2; e < r && (n = t.charCodeAt(e), !(n < 48 || n > 57)); )
        e += 1;
    if (n = t.charCodeAt(e), i = t.charCodeAt(e + 1), s = t.charCodeAt(e + 2), (n === Xv || n === Kv) && (i >= 48 && i <= 57 || (i === En || i === Cn) && s >= 48 && s <= 57))
      for (e += i === En || i === Cn ? 3 : 2; e < r && (n = t.charCodeAt(e), !(n < 48 || n > 57)); )
        e += 1;
    return { number: t.slice(0, e), unit: t.slice(e) };
  };
});
var nc = S((yk, rc) => {
  var e0 = Bf(), ec = Yf(), tc = Xf();
  function qe(t) {
    return this instanceof qe ? (this.nodes = e0(t), this) : new qe(t);
  }
  qe.prototype.toString = function() {
    return Array.isArray(this.nodes) ? tc(this.nodes) : "";
  };
  qe.prototype.walk = function(t, e) {
    return ec(this.nodes, t, e), this;
  };
  qe.unit = Zf();
  qe.walk = ec;
  qe.stringify = tc;
  rc.exports = qe;
});
var Tc = S((OC, _c) => {
  "use strict";
  var Pn = Object.prototype.hasOwnProperty, Oc = Object.prototype.toString, xc = Object.defineProperty, Sc = Object.getOwnPropertyDescriptor, kc = function(e) {
    return typeof Array.isArray == "function" ? Array.isArray(e) : Oc.call(e) === "[object Array]";
  }, Cc = function(e) {
    if (!e || Oc.call(e) !== "[object Object]")
      return false;
    var r = Pn.call(e, "constructor"), n = e.constructor && e.constructor.prototype && Pn.call(e.constructor.prototype, "isPrototypeOf");
    if (e.constructor && !r && !n)
      return false;
    var i;
    for (i in e)
      ;
    return typeof i > "u" || Pn.call(e, i);
  }, Ec = function(e, r) {
    xc && r.name === "__proto__" ? xc(e, r.name, { enumerable: true, configurable: true, value: r.newValue, writable: true }) : e[r.name] = r.newValue;
  }, Ac = function(e, r) {
    if (r === "__proto__")
      if (Pn.call(e, r)) {
        if (Sc)
          return Sc(e, r).value;
      } else
        return;
    return e[r];
  };
  _c.exports = function t() {
    var e, r, n, i, s, a, o2 = arguments[0], l = 1, u = arguments.length, f = false;
    for (typeof o2 == "boolean" && (f = o2, o2 = arguments[1] || {}, l = 2), (o2 == null || typeof o2 != "object" && typeof o2 != "function") && (o2 = {}); l < u; ++l)
      if (e = arguments[l], e != null)
        for (r in e)
          n = Ac(o2, r), i = Ac(e, r), o2 !== i && (f && i && (Cc(i) || (s = kc(i))) ? (s ? (s = false, a = n && kc(n) ? n : []) : a = n && Cc(n) ? n : {}, Ec(o2, { name: r, newValue: t(f, a, i) })) : typeof i < "u" && Ec(o2, { name: r, newValue: i }));
    return o2;
  };
});
var Rn = S((_C, Pc) => {
  var da = function(t, e) {
    var r = new t.constructor();
    return Object.keys(t).forEach(function(n) {
      if (!!t.hasOwnProperty(n)) {
        var i = t[n], s = typeof i;
        n === "parent" && s === "object" ? e && (r[n] = e) : n === "source" ? r[n] = i : i instanceof Array ? n === "nodes" ? r[n] = [] : r[n] = i.map(function(a) {
          da(a, r);
        }) : n !== "before" && n !== "after" && n !== "between" && n !== "semicolon" && (s === "object" && (i = da(i)), r[n] = i);
      }
    }), r;
  };
  Pc.exports = da;
});
var Lc = S((TC, Mc) => {
  "use strict";
  Mc.exports = Ic;
  function Ic(t, e, r) {
    t instanceof RegExp && (t = Rc(t, r)), e instanceof RegExp && (e = Rc(e, r));
    var n = Dc(t, e, r);
    return n && { start: n[0], end: n[1], pre: r.slice(0, n[0]), body: r.slice(n[0] + t.length, n[1]), post: r.slice(n[1] + e.length) };
  }
  function Rc(t, e) {
    var r = e.match(t);
    return r ? r[0] : null;
  }
  Ic.range = Dc;
  function Dc(t, e, r) {
    var n, i, s, a, o2, l = r.indexOf(t), u = r.indexOf(e, l + 1), f = l;
    if (l >= 0 && u > 0) {
      if (t === e)
        return [l, u];
      for (n = [], s = r.length; f >= 0 && !o2; )
        f == l ? (n.push(f), l = r.indexOf(t, f + 1)) : n.length == 1 ? o2 = [n.pop(), u] : (i = n.pop(), i < s && (s = i, a = u), u = r.indexOf(e, f + 1)), f = l < u && l >= 0 ? l : u;
      n.length && (o2 = [s, a]);
    }
    return o2;
  }
});
var Nc = S((PC, Fc) => {
  var C0 = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?![><+~\s]).)+)(?:(?:(?:\s(?!>>))|(?:\t(?!>>))|(?:\s?>>\s?))(?!\s+))(?![><+~][\s]+?))/, E0 = function(t) {
    return t.split(C0).filter(function(e) {
      return e.length > 0;
    }).map(function(e) {
      return e.trim().replace(/\s*?>>\s*?/g, "");
    });
  };
  Fc.exports = E0;
});
var dr = S((RC, qc) => {
  var A0 = Nc(), O0 = function(t, e) {
    e = e || false;
    for (var r = [[]], n = e ? t : t.parent; n; ) {
      var i = (n.selectors || []).map(function(a) {
        return { value: a, type: "selector" };
      });
      n.type === "atrule" && (i = [].concat(n.params).map(function(a) {
        return { value: "@" + n.name + " " + a, type: "atrule" };
      }));
      var s = (i.length > 0 ? i : [1]).map(function() {
        return r.map(function(a) {
          return a.slice(0);
        });
      });
      i.forEach(function(a, o2) {
        s[o2] = s[o2].map(function(l) {
          var u = [a.value];
          return a.type === "selector" && (u = A0(a.value)), l.unshift.apply(l, u), l;
        });
      }), r = [], s.forEach(function(a) {
        r = r.concat(a);
      }), n = n.parent;
    }
    return r;
  };
  qc.exports = O0;
});
var Uc = S((IC, $c) => {
  "use strict";
  var _0 = /[|\\{}()[\]^$+*?.]/g;
  $c.exports = function(t) {
    if (typeof t != "string")
      throw new TypeError("Expected a string");
    return t.replace(_0, "\\$&");
  };
});
var zc = S((DC, jc) => {
  var T0 = { "*": true, ":root": true, html: true }, P0 = function(t) {
    return !!T0[t];
  };
  jc.exports = P0;
});
var Wc = S((MC, Vc) => {
  var R0 = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?!>>|<|\+|~|\s).)+)(?:(?:(?:>(?!>))|(?:\s?>(?!>)\s?))(?!\s+))(?!(?:>>|<|\+|~)[\s]+?))/, I0 = function(t) {
    return t.split(R0).filter(function(e) {
      return e.length > 0;
    }).map(function(e) {
      return e.trim().replace(/\s*?>\s*?/g, "");
    });
  };
  Vc.exports = I0;
});
var ha = S((LC, Xc) => {
  var D0 = Uc(), Bc = zc(), Gc = Wc(), M0 = /^@.*/, Hc = /([^\s:]+)((?::|::)[^\s]*?)(\s+|$)/;
  function Qc(t, e) {
    var r, n, i = e.some(function(s) {
      return t.some(function(a) {
        r = null;
        var o2 = true;
        for (n = 0; n < s.length; n++) {
          for (var l = s[n], u = r || 0, f = -1, p = a.slice(u), c = 0; c < p.length; c++) {
            var d = p[c], h = u + c;
            if (new RegExp(D0(l) + "$").test(d)) {
              f = h;
              break;
            }
            if (Bc(l) || Bc(d)) {
              f = h;
              break;
            }
            var y = Gc(d);
            if (y.length > 1) {
              var m = [].concat([y]), g = [].concat([s.slice(n).reduce(function(v, C) {
                return v.concat(Gc(C));
              }, [])]), w = Qc(m, g);
              (w.doesMatchScope || n + 1 < s.length) && (f = h, n += w.scopePieceIndex - 1);
              break;
            }
          }
          var b = f >= u;
          if (r = f + 1, o2 = o2 && b, !o2)
            break;
        }
        return o2;
      });
    });
    return { doesMatchScope: i, nodeScopePieceIndex: r - 1, scopePieceIndex: n };
  }
  var Yc = function(t) {
    return t.map(function(e) {
      return e.map(function(r) {
        return M0.test(r) ? r : r.replace(new RegExp(Hc.source, "g"), function(n, i, s, a) {
          return i + a;
        });
      });
    });
  }, Jc = function(t, e, r) {
    return t = Yc(t), r && (e = Yc(e)), Qc(t, e).doesMatchScope;
  };
  Jc.RE_PSEUDO_SELECTOR = Hc;
  Xc.exports = Jc;
});
var ma = S((FC, Zc) => {
  var L0 = ha(), Kc = dr(), F0 = function(t, e, r) {
    var n = Kc(t, true), i = Kc(e, true);
    return L0(n, i, r);
  };
  Zc.exports = F0;
});
var ga = S((NC, tp) => {
  var ep = function(t, e, r) {
    r = r || [];
    var n = false;
    return t && (r = t.reduce(function(i, s) {
      var a = !!e[s], o2 = a ? i.some(function(l) {
        return e[s].some(function(u) {
          return l === u;
        });
      }) : false;
      return n = n || o2, a && !n && (i = i.concat(e[s]), (e[s] || []).forEach(function(l) {
        var u = ep(l.variablesUsed, e, i);
        i = u.deps, n = n || u.hasCircularOrSelfReference;
      })), i;
    }, r)), { deps: r, hasCircularOrSelfReference: n };
  };
  tp.exports = ep;
});
var ya = S((qC, rp) => {
  var N0 = dr(), q0 = function(t, e) {
    for (var r, n = e; n.parent && !r; ) {
      var i = N0(n.clone(), true);
      i.some(function(s) {
        return s.some(function(a) {
          return a === t ? (r = n, true) : false;
        });
      }), n = n.parent;
    }
    return r;
  };
  rp.exports = q0;
});
var wa = S(($C, ip) => {
  var np = Rn(), $0 = function(t, e, r) {
    r = r || function() {
      return true;
    };
    for (var n = [], i = t, s = false; i && !s; )
      i.type === "decl" ? n.push(i.clone()) : n.push(np(i)), s = r(i), i = i.parent;
    for (var a = [], o2 = e; o2; )
      a.push(np(o2)), o2 = o2.parent;
    return a.forEach(function(l, u, f) {
      u + 1 < f.length && (l.parent = f[u + 1]);
    }), n.forEach(function(l, u, f) {
      u + 1 < f.length ? l.parent = f[u + 1] : (a.slice(-1)[0].parent = i, l.parent = a[0]);
    }), n[0];
  };
  ip.exports = $0;
});
var va = S((UC, ap) => {
  var U0 = Lc(), j0 = dr(), sp = ma(), z0 = ga(), V0 = ya(), W0 = wa(), B0 = /var\(\s*(--[^,\s)]+)/;
  function G0(t) {
    return String(t);
  }
  function In(t) {
    var e = U0("(", ")", t);
    if (e) {
      if (/(?:^|[^\w-])var$/.test(e.pre))
        return { pre: e.pre.slice(0, -3), body: e.body, post: e.post };
      var r = In(e.body);
      if (r)
        return { pre: e.pre + "(" + r.pre, body: r.body, post: r.post + ")" + e.post };
      var n = In(e.post);
      if (n)
        return { pre: e.pre + "(" + e.body + ")" + n.pre, body: n.body, post: n.post };
    }
  }
  var Dn = function(t, e, r, n) {
    for (var i = n ? "	" : "", s = void 0, a = G0(t.value), o2 = [], l = {}, u = a; s = In(u); ) {
      var f = s.body.split(","), p = f[0].trim();
      l[p] = true, u = (s.pre || "") + s.body.replace(p, "") + (s.post || "");
    }
    u = void 0;
    for (var c = Object.keys(l), d = false; s = In(a); ) {
      var h = void 0, f = s.body.split(","), p = f[0].trim(), y = f.length > 1 ? f.slice(1).join(",").trim() : void 0;
      (e[p] || []).forEach(function(O) {
        var E = O.parent.type === "root" || O.parent.selectors[0] === ":root", R = sp(t.parent, O.parent), L = sp(t.parent, O.parent, r);
        L && (!(h || {}).isImportant || O.isImportant) && (h = O);
      });
      var m = (h || {}).calculatedInPlaceValue || function() {
        var O = y;
        if (y) {
          var E = t.clone({ parent: t.parent, value: y });
          O = Dn(E, e, false, true).value;
        }
        return O;
      }();
      if (h !== void 0 && !z0(c, e).hasCircularOrSelfReference) {
        var g = j0(t.parent.parent, true), w = g[0].slice(-1)[0], b = V0(w, h.decl.parent), v = W0(h.decl, t.parent.parent, function(O) {
          return O === b;
        });
        m = Dn(v, e, false, true).value;
      }
      d = m === void 0, d && o2.push(["variable " + p + " is undefined and used without a fallback", { node: t }]), a = (s.pre || "") + m + (s.post || "");
    }
    return { value: d ? void 0 : a, variablesUsed: c, warnings: o2 };
  };
  Dn.RE_VAR_FUNC = B0;
  ap.exports = Dn;
});
var fp = S((jC, up) => {
  var op = va(), Y0 = dr(), H0 = ga(), lp = ha(), Q0 = ma(), Mn = Rn(), J0 = ya(), X0 = wa();
  function K0(t, e, r, n) {
    t.forEach(function(i) {
      H0(t, e).deps.forEach(function(s) {
        var a;
        if (s.isUnderAtRule) {
          var o2 = Y0(s.parent, true), l = o2[0].slice(-1)[0], u = J0(l, r.parent), f = s.parent.parent;
          a = X0(r, f, function(h) {
            return h === u;
          });
        } else if (lp.RE_PSEUDO_SELECTOR.test(s.parent.selector)) {
          var p = Mn(r.parent);
          p.parent = r.parent.parent, a = r.clone(), p.append(a);
          var c = s.parent.selector.match(new RegExp(lp.RE_PSEUDO_SELECTOR.source + "$")), d = c ? c[2] : "";
          p.selector += d;
        }
        a && Q0(a, s.parent, true) && n(a, s);
      });
    });
  }
  function Z0(t, e, r, n, i) {
    r = (typeof r == "function" ? r(t) : r) || false, n = n || false;
    var s = function(l) {
      return i && i(l), l;
    }, a = s(op(t, e)), o2;
    K0(a.variablesUsed, e, t, function(l, u) {
      var f = Mn(t.parent), p = t.clone();
      f.append(p);
      let c;
      if (typeof r == "function" ? c = r(t) : c = r, c === true && p.cloneAfter(), p.value = s(op(l, e, true)).value, u.isUnderAtRule) {
        var d = Mn(u.parent.parent);
        d.append(f);
        for (var h = d, y = u.parent.parent; y.parent.type === "atrule"; ) {
          var m = Mn(y.parent);
          m.append(h), h = m, y = y.parent;
        }
        t.parent.parent.insertAfter(n && o2 || t.parent, h), o2 = h;
      } else
        f.selector = l.parent.selector, t.parent.parent.insertAfter(n && o2 || t.parent, f);
    }), r === true && t.value !== a.value && t.cloneAfter(), a.value === void 0 && (a.value = "undefined"), t.value = a.value;
  }
  up.exports = Z0;
});
var hp = S((zC, ba) => {
  var cp = Tc(), eb = Rn(), pp = va(), tb = fp(), dp = /(--(.+))/;
  function rb(t, e) {
    t.walkDecls(function(r) {
      dp.test(r.prop) && e(r);
    });
  }
  function nb(t) {
    for (var e = t; e && e.nodes.length <= 0; ) {
      var r = e.type !== "root" ? e : null;
      r ? (e = r.parent, r.remove()) : e = null;
    }
  }
  var ib = { preserve: false, variables: {}, preserveInjectedVariables: true, preserveAtRulesOrder: false };
  ba.exports = (t = {}) => {
    var e = cp({}, ib, t);
    return { postcssPlugin: "postcss-css-variables", Once(r, { decl: n, result: i, rule: s }) {
      var a = [], o2 = [], l = {};
      l = cp(l, Object.keys(e.variables).reduce(function(p, c) {
        var d = e.variables[c];
        c = c.slice(0, 2) === "--" ? c : "--" + c;
        var h = (d || {}).value || d, y = (d || {}).isImportant || false, m = s({ selector: ":root" });
        r.root().prepend(m);
        var g = n({ prop: c, value: h, important: y });
        return m.append(g), e.preserveInjectedVariables || o2.push(g), p[c] = (p[c] || []).concat({ decl: g, prop: c, calculatedInPlaceValue: h, isImportant: y, variablesUsed: [], parent: m, isUnderAtRule: false }), p;
      }, {}));
      var u = function(p) {
        var c = [].concat(p.warnings);
        return c.forEach(function(d) {
          d = [].concat(d), i.warn.apply(i, d);
        }), p;
      };
      rb(r, function(p) {
        var c = p.parent, d = u(pp(p, l));
        p.parent.selectors.forEach(function(y) {
          var m = eb(p.parent);
          m.selector = y, m.parent = p.parent.parent;
          var g = p.clone();
          m.append(g);
          var w = p.prop;
          l[w] = (l[w] || []).concat({ decl: g, prop: w, calculatedInPlaceValue: d.value, isImportant: p.important || false, variablesUsed: d.variablesUsed, parent: m, isUnderAtRule: m.parent.type === "atrule" });
        });
        let h;
        typeof e.preserve == "function" ? h = e.preserve(p) : h = e.preserve, h ? h === "computed" && (p.value = d.value) : p.remove(), c.nodes.length <= 0 && a.push(c);
      });
      var f = [];
      r.walk(function(p) {
        if (p.nodes !== void 0) {
          var c = p.nodes.some(function(d) {
            if (d.type === "decl") {
              var h = d;
              if (pp.RE_VAR_FUNC.test(h.value) && !dp.test(h.prop))
                return true;
            }
            return false;
          });
          c && f.push(p);
        }
      }), f.forEach(function(p) {
        var c = [].concat(p);
        p.type === "rule" && p.selectors.length > 1 && (c = p.selectors.reverse().map(function(d) {
          var h = p.cloneAfter();
          return h.selector = d, h;
        }), p.remove()), c.forEach(function(d) {
          d.nodes.slice(0).forEach(function(h) {
            if (h.type === "decl") {
              var y = h;
              tb(y, l, e.preserve, e.preserveAtRulesOrder, u);
            }
          });
        });
      }), a.forEach(nb), o2.forEach(function(p) {
        p.remove();
      });
    } };
  };
  ba.exports.postcss = true;
});
var _a2 = (t) => ({ extractCSS(e, r = false) {
  let n = /(?:[\s\r\n]*)?(?<prop>[\w-]+)\s*:\s*(?<value>[^;\r\n]+)/gm, i, s = {};
  for (; (i = n.exec(e)) !== null; ) {
    let { prop: a, value: o2 } = i.groups;
    s[a] = o2;
  }
  return Object.entries(s).reduce((a, [o2, l]) => a + `${r ? "	" : ""}${o2}: ${l}; 
\r`, "");
}, merge() {
  let e = new RegExp("(?<=\\.)[^{]+\\s*\\{(?<content>[^{}]*(?:(?<=;)\\s*\\n\\r?[^{}]*)*)\\s*\\}", "gm"), r, n = "";
  for (; (r = e.exec(t)) !== null; ) {
    let { content: o2 } = r.groups;
    n += o2;
  }
  let i = this.extractCSS(n), s = /(?<media>@media\s*\([^\)]*\))\s*\{(?<content>[^\}]*)\}/gm, a;
  for (; (a = s.exec(t)) !== null; ) {
    let { media: o2, content: l } = a.groups;
    i += `
\r${o2} {
\r${this.extractCSS(l, true)}}
\r`;
  }
  return t = i, this;
}, removeUndefined() {
  let e = /^[^{}]*(?:[.#][a-zA-Z0-9_-]+)[^{]*{[^}]*\b(?:[a-z-]+):\s*undefined\s*;?[^}]*}/gm;
  return t = t.replace(e, ""), this;
}, combineMediaQueries() {
  let e = new RegExp("@media\\s*(?<conditions>\\([^)]+\\))\\s*{(?<content>(?:[^{}]+|{(?:[^{}]+|{[^{}]*})*})+)}", "gs"), r = /* @__PURE__ */ new Map(), n = (s) => s.replace(e, (a, o2, l) => {
    var f;
    let u = (f = r.get(o2)) != null ? f : "";
    return r.set(o2, u + n(l.trim())), n(l), "";
  }), i = [];
  return i.push(n(t)), i.push(...Array.from(r, ([s, a]) => `@media${s}{${a}}`)), t = i.join(""), this;
}, minify() {
  return t = t.replace(/\/\*[\s\S]*?\*\//gm, "").replace(/;\s+/gm, ";").replace(/:\s+/gm, ":").replace(/\)\s*{/gm, "){").replace(/\s+\(/gm, "(").replace(/{\s+/gm, "{").replace(/}\s+/gm, "}").replace(/\s*{/gm, "{").replace(/;?\s*}/gm, "}"), this;
}, fixRGB() {
  let e = /rgb\(\s*(?<red>\d+)\s*(?<green>\d+)\s*(?<blue>\d+)(?:\s*\/\s*(?<alpha>[\d%.]+))?\s*\)/gm, r;
  for (; (r = e.exec(t)) !== null; ) {
    let [n] = r, { red: i, green: s, blue: a, alpha: o2 = 1 } = r.groups;
    t = t.replace(n, `rgb(${i},${s},${a}${o2 === "1" ? "" : `,${o2}`})`);
  }
  return this;
}, removeMediaQueries() {
  return t = t.replace(/@media[^\{]+\{[^@]+\}/g, ""), this;
}, get() {
  return t;
} });
function Fn() {
}
var D = { info: Fn, warn: Fn, risk: Fn };
function Nn(t) {
  let e = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
  if (t.walkAtRules((i) => {
    i.name === "apply" && n.add(i), i.name === "import" && (i.params === '"tailwindcss/base"' || i.params === "'tailwindcss/base'" ? (i.name = "tailwind", i.params = "base") : i.params === '"tailwindcss/components"' || i.params === "'tailwindcss/components'" ? (i.name = "tailwind", i.params = "components") : i.params === '"tailwindcss/utilities"' || i.params === "'tailwindcss/utilities'" ? (i.name = "tailwind", i.params = "utilities") : (i.params === '"tailwindcss/screens"' || i.params === "'tailwindcss/screens'" || i.params === '"tailwindcss/variants"' || i.params === "'tailwindcss/variants'") && (i.name = "tailwind", i.params = "variants")), i.name === "tailwind" && (i.params === "screens" && (i.params = "variants"), e.add(i.params)), ["layer", "responsive", "variants"].includes(i.name) && (["responsive", "variants"].includes(i.name) && D.warn(`${i.name}-at-rule-deprecated`, [`The \`@${i.name}\` directive has been deprecated in Tailwind CSS v3.0.`, "Use `@layer utilities` or `@layer components` instead.", "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"]), r.add(i));
  }), !e.has("base") || !e.has("components") || !e.has("utilities")) {
    for (let i of r)
      if (i.name === "layer" && ["base", "components", "utilities"].includes(i.params)) {
        if (!e.has(i.params))
          throw i.error(`\`@layer ${i.params}\` is used but no matching \`@tailwind ${i.params}\` directive is present.`);
      } else if (i.name === "responsive") {
        if (!e.has("utilities"))
          throw i.error("`@responsive` is used but `@tailwind utilities` is missing.");
      } else if (i.name === "variants" && !e.has("utilities"))
        throw i.error("`@variants` is used but `@tailwind utilities` is missing.");
  }
  return { tailwindDirectives: e, applyDirectives: n };
}
yr();
var Nf = Y(Da());
var La = "3.2.7";
var $n = { name: "tailwindcss", version: La, description: "A utility-first CSS framework for rapidly building custom user interfaces.", license: "MIT", main: "lib/index.js", types: "types/index.d.ts", repository: "https://github.com/tailwindlabs/tailwindcss.git", bugs: "https://github.com/tailwindlabs/tailwindcss/issues", homepage: "https://tailwindcss.com", bin: { tailwind: "lib/cli.js", tailwindcss: "lib/cli.js" }, tailwindcss: { engine: "stable" }, scripts: { prebuild: "npm run generate && rimraf lib", build: "swc src --out-dir lib --copy-files", postbuild: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false", "rebuild-fixtures": "npm run build && node -r @swc/register scripts/rebuildFixtures.js", style: "eslint .", pretest: "npm run generate", test: "jest", "test:integrations": "npm run test --prefix ./integrations", "install:integrations": "node scripts/install-integrations.js", "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js", "generate:types": "node -r @swc/register scripts/generate-types.js", generate: "npm run generate:plugin-list && npm run generate:types", "release-channel": "node ./scripts/release-channel.js", "release-notes": "node ./scripts/release-notes.js", prepublishOnly: "npm install --force && npm run build" }, files: ["src/*", "cli/*", "lib/*", "peers/*", "scripts/*.js", "stubs/*.stub.js", "nesting/*", "types/**/*", "*.d.ts", "*.css", "*.js"], devDependencies: { "@swc/cli": "0.1.59", "@swc/core": "1.3.24", "@swc/jest": "0.2.24", "@swc/register": "0.1.10", autoprefixer: "^10.4.13", browserslist: "^4.21.4", concurrently: "^7.5.0", cssnano: "^5.1.14", esbuild: "^0.16.10", eslint: "^8.31.0", "eslint-config-prettier": "^8.6.0", "eslint-plugin-prettier": "^4.2.1", jest: "^28.1.3", "jest-diff": "^28.1.3", lightningcss: "^1.18.0", prettier: "^2.8.1", rimraf: "^3.0.0", "source-map-js": "^1.0.2", turbo: "^1.6.3" }, peerDependencies: { postcss: "^8.0.9" }, dependencies: { arg: "^5.0.2", chokidar: "^3.5.3", "color-name": "^1.1.4", detective: "^5.2.1", didyoumean: "^1.2.2", dlv: "^1.1.3", "fast-glob": "^3.2.12", "glob-parent": "^6.0.2", "is-glob": "^4.0.3", lilconfig: "^2.0.6", micromatch: "^4.0.5", "normalize-path": "^3.0.0", "object-hash": "^3.0.0", picocolors: "^1.0.0", postcss: "^8.0.9", "postcss-import": "^14.1.0", "postcss-js": "^4.0.0", "postcss-load-config": "^3.1.4", "postcss-nested": "6.0.0", "postcss-selector-parser": "^6.0.11", "postcss-value-parser": "^4.2.0", "quick-lru": "^5.1.1", resolve: "^1.22.1" }, browserslist: ["> 1%", "not edge <= 18", "not ie 11", "not op_mini all"], jest: { testTimeout: 3e4, setupFilesAfterEnv: ["<rootDir>/jest/customMatchers.js"], testPathIgnorePatterns: ["/node_modules/", "/integrations/", "/standalone-cli/", "\\.test\\.skip\\.js$"], transformIgnorePatterns: ["node_modules/(?!lightningcss)"], transform: { "\\.js$": "@swc/jest", "\\.ts$": "@swc/jest" } }, engines: { node: ">=12.13.0" } };
var Tp = $n.tailwindcss.engine === "oxide";
var Un = { NODE_ENV: "production", DEBUG: Rp(void 0), ENGINE: $n.tailwindcss.engine, OXIDE: Pp(void 0, Tp) };
var jn = /* @__PURE__ */ new Map();
var ke = new String("*");
var mt = Symbol("__NONE__");
function Pp(t, e) {
  return t === void 0 ? e : !(t === "0" || t === "false");
}
function Rp(t) {
  if (t === void 0)
    return false;
  if (t === "true" || t === "1")
    return true;
  if (t === "false" || t === "0")
    return false;
  if (t === "*")
    return true;
  let e = t.split(",").map((r) => r.split(":")[0]);
  return e.includes("-tailwindcss") ? false : !!e.includes("tailwindcss");
}
var $ = Y(Ze(), 1);
var I2 = $.default;
var Kb = $.default.stringify;
var Zb = $.default.fromJSON;
var ex = $.default.plugin;
var tx = $.default.parse;
var rx = $.default.list;
var nx = $.default.document;
var ix = $.default.comment;
var sx = $.default.atRule;
var ax = $.default.rule;
var ox = $.default.decl;
var lx = $.default.root;
var ux = $.default.CssSyntaxError;
var fx = $.default.Declaration;
var cx = $.default.Container;
var px = $.default.Processor;
var dx = $.default.Document;
var hx = $.default.Comment;
var mx = $.default.Warning;
var gx = $.default.AtRule;
var yx = $.default.Result;
var wx = $.default.Input;
var vx = $.default.Rule;
var bx = $.default.Root;
var xx = $.default.Node;
var yn = Y(Ae());
var Lu = Y(wu());
var nt = Y(Mu(), 1);
var en = nt.default;
var jx = nt.default.objectify;
var zx = nt.default.parse;
var Vx = nt.default.async;
var Wx = nt.default.sync;
function it(t) {
  return Array.isArray(t) ? t.flatMap((e) => I2([(0, Lu.default)({ bubble: ["screen"] })]).process(e, { parser: en }).root.nodes) : it([t]);
}
function X(t) {
  if (Object.prototype.toString.call(t) !== "[object Object]")
    return false;
  let e = Object.getPrototypeOf(t);
  return e === null || e === Object.prototype;
}
var Fu = Y(Ae());
function st(t, e, r = false) {
  if (t === "")
    return e;
  let n = typeof e == "string" ? (0, Fu.default)().astSync(e) : e;
  return n.walkClasses((i) => {
    let s = i.value, a = r && s.startsWith("-");
    i.value = a ? `-${t}${s.slice(1)}` : `${t}${s}`;
  }), typeof e == "string" ? n.toString() : n;
}
function Be(t) {
  return t.replace(/\\,/g, "\\2c ");
}
var bs = Y(qu());
var Cw = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
var Ew = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
var Re = /(?:\d+|\d*\.\d+)%?/;
var tn = /(?:\s*,\s*|\s+)/;
var $u = /\s*[,/]\s*/;
var Ie = /var\(--(?:[^ )]*?)\)/;
var Aw = new RegExp(`^(rgba?)\\(\\s*(${Re.source}|${Ie.source})(?:${tn.source}(${Re.source}|${Ie.source}))?(?:${tn.source}(${Re.source}|${Ie.source}))?(?:${$u.source}(${Re.source}|${Ie.source}))?\\s*\\)$`);
var Ow = new RegExp(`^(hsla?)\\(\\s*((?:${Re.source})(?:deg|rad|grad|turn)?|${Ie.source})(?:${tn.source}(${Re.source}|${Ie.source}))?(?:${tn.source}(${Re.source}|${Ie.source}))?(?:${$u.source}(${Re.source}|${Ie.source}))?\\s*\\)$`);
function ir(t, { loose: e = false } = {}) {
  var s, a, o2;
  if (typeof t != "string")
    return null;
  if (t = t.trim(), t === "transparent")
    return { mode: "rgb", color: ["0", "0", "0"], alpha: "0" };
  if (t in bs.default)
    return { mode: "rgb", color: bs.default[t].map((l) => l.toString()) };
  let r = t.replace(Ew, (l, u, f, p, c) => ["#", u, u, f, f, p, p, c ? c + c : ""].join("")).match(Cw);
  if (r !== null)
    return { mode: "rgb", color: [parseInt(r[1], 16), parseInt(r[2], 16), parseInt(r[3], 16)].map((l) => l.toString()), alpha: r[4] ? (parseInt(r[4], 16) / 255).toString() : void 0 };
  let n = (s = t.match(Aw)) != null ? s : t.match(Ow);
  if (n === null)
    return null;
  let i = [n[2], n[3], n[4]].filter(Boolean).map((l) => l.toString());
  return i.length === 2 && i[0].startsWith("var(") ? { mode: n[1], color: [i[0]], alpha: i[1] } : !e && i.length !== 3 || i.length < 3 && !i.some((l) => /^var\(.*?\)$/.test(l)) ? null : { mode: n[1], color: i, alpha: (o2 = (a = n[5]) == null ? void 0 : a.toString) == null ? void 0 : o2.call(a) };
}
function xs({ mode: t, color: e, alpha: r }) {
  let n = r !== void 0;
  return t === "rgba" || t === "hsla" ? `${t}(${e.join(", ")}${n ? `, ${r}` : ""})` : `${t}(${e.join(" ")}${n ? ` / ${r}` : ""})`;
}
function ve(t, e, r) {
  if (typeof t == "function")
    return t({ opacityValue: e });
  let n = ir(t, { loose: true });
  return n === null ? r : xs({ ...n, alpha: e });
}
function ee({ color: t, property: e, variable: r }) {
  let n = [].concat(e);
  if (typeof t == "function")
    return { [r]: "1", ...Object.fromEntries(n.map((s) => [s, t({ opacityVariable: r, opacityValue: `var(${r})` })])) };
  let i = ir(t);
  return i === null ? Object.fromEntries(n.map((s) => [s, t])) : i.alpha !== void 0 ? Object.fromEntries(n.map((s) => [s, t])) : { [r]: "1", ...Object.fromEntries(n.map((s) => [s, xs({ ...i, alpha: `var(${r})` })])) };
}
function te(t, e) {
  let r = [], n = [], i = 0;
  for (let s = 0; s < t.length; s++) {
    let a = t[s];
    r.length === 0 && a === e[0] && (e.length === 1 || t.slice(s, s + e.length) === e) && (n.push(t.slice(i, s)), i = s + e.length), a === "(" || a === "[" || a === "{" ? r.push(a) : (a === ")" && r[r.length - 1] === "(" || a === "]" && r[r.length - 1] === "[" || a === "}" && r[r.length - 1] === "{") && r.pop();
  }
  return n.push(t.slice(i)), n;
}
var _w = /* @__PURE__ */ new Set(["inset", "inherit", "initial", "revert", "unset"]);
var Tw = /\ +(?![^(]*\))/g;
var Uu = /^-?(\d+|\.\d+)(.*?)$/g;
function rn(t) {
  return te(t, ",").map((r) => {
    let n = r.trim(), i = { raw: n }, s = n.split(Tw), a = /* @__PURE__ */ new Set();
    for (let o2 of s)
      Uu.lastIndex = 0, !a.has("KEYWORD") && _w.has(o2) ? (i.keyword = o2, a.add("KEYWORD")) : Uu.test(o2) ? a.has("X") ? a.has("Y") ? a.has("BLUR") ? a.has("SPREAD") || (i.spread = o2, a.add("SPREAD")) : (i.blur = o2, a.add("BLUR")) : (i.y = o2, a.add("Y")) : (i.x = o2, a.add("X")) : i.color ? (i.unknown || (i.unknown = []), i.unknown.push(o2)) : i.color = o2;
    return i.valid = i.x !== void 0 && i.y !== void 0, i;
  });
}
function ju(t) {
  return t.map((e) => e.valid ? [e.keyword, e.x, e.y, e.blur, e.spread, e.color].filter(Boolean).join(" ") : e.raw).join(", ");
}
var Pw = ["min", "max", "clamp", "calc"];
function Ss(t) {
  return Pw.some((e) => new RegExp(`^${e}\\(.*\\)`).test(t));
}
var zu = "--tw-placeholder";
var Rw = new RegExp(zu, "g");
function z(t, e = true) {
  return t.includes("url(") ? t.split(/(url\(.*?\))/g).filter(Boolean).map((r) => /^url\(.*?\)$/.test(r) ? r : z(r, false)).join("") : (t = t.replace(/([^\\])_+/g, (r, n) => n + " ".repeat(r.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), e && (t = t.trim()), t = t.replace(/(calc|min|max|clamp)\(.+\)/g, (r) => {
    let n = [];
    return r.replace(/var\((--.+?)[,)]/g, (i, s) => (n.push(s), i.replace(s, zu))).replace(/(-?\d*\.?\d(?!\b-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(Rw, () => n.shift());
  }), t);
}
function ks(t) {
  return t.startsWith("url(");
}
function Cs(t) {
  return !isNaN(Number(t)) || Ss(t);
}
function sr(t) {
  return t.endsWith("%") && Cs(t.slice(0, -1)) || Ss(t);
}
var Iw = ["cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "rlh", "vw", "vh", "vmin", "vmax", "vb", "vi", "svw", "svh", "lvw", "lvh", "dvw", "dvh", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"];
var Dw = `(?:${Iw.join("|")})`;
function ar(t) {
  return t === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${Dw}$`).test(t) || Ss(t);
}
var Mw = /* @__PURE__ */ new Set(["thin", "medium", "thick"]);
function Vu(t) {
  return Mw.has(t);
}
function Wu(t) {
  let e = rn(z(t));
  for (let r of e)
    if (!r.valid)
      return false;
  return true;
}
function Bu(t) {
  let e = 0;
  return te(t, "_").every((n) => (n = z(n), n.startsWith("var(") ? true : ir(n, { loose: true }) !== null ? (e++, true) : false)) ? e > 0 : false;
}
function Gu(t) {
  let e = 0;
  return te(t, ",").every((n) => (n = z(n), n.startsWith("var(") ? true : ks(n) || Fw(n) || ["element(", "image(", "cross-fade(", "image-set("].some((i) => n.startsWith(i)) ? (e++, true) : false)) ? e > 0 : false;
}
var Lw = /* @__PURE__ */ new Set(["linear-gradient", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "conic-gradient"]);
function Fw(t) {
  t = z(t);
  for (let e of Lw)
    if (t.startsWith(`${e}(`))
      return true;
  return false;
}
var Nw = /* @__PURE__ */ new Set(["center", "top", "right", "bottom", "left"]);
function Yu(t) {
  let e = 0;
  return te(t, "_").every((n) => (n = z(n), n.startsWith("var(") ? true : Nw.has(n) || ar(n) || sr(n) ? (e++, true) : false)) ? e > 0 : false;
}
function Hu(t) {
  let e = 0;
  return te(t, ",").every((n) => (n = z(n), n.startsWith("var(") ? true : n.includes(" ") && !/(['"])([^"']+)\1/g.test(n) || /^\d/g.test(n) ? false : (e++, true))) ? e > 0 : false;
}
var qw = /* @__PURE__ */ new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]);
function Qu(t) {
  return qw.has(t);
}
var $w = /* @__PURE__ */ new Set(["xx-small", "x-small", "small", "medium", "large", "x-large", "x-large", "xxx-large"]);
function Ju(t) {
  return $w.has(t);
}
var Uw = /* @__PURE__ */ new Set(["larger", "smaller"]);
function Xu(t) {
  return Uw.has(t);
}
function De(t) {
  if (t = `${t}`, t === "0")
    return "0";
  if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(t))
    return t.replace(/^[+-]?/, (r) => r === "-" ? "" : "-");
  let e = ["var", "calc", "min", "max", "clamp"];
  for (let r of e)
    if (t.includes(`${r}(`))
      return `calc(${t} * -1)`;
}
function Ku(t) {
  let e = ["cover", "contain"];
  return te(t, ",").every((r) => {
    let n = te(r, "_").filter(Boolean);
    return n.length === 1 && e.includes(n[0]) ? true : n.length !== 1 && n.length !== 2 ? false : n.every((i) => ar(i) || sr(i) || i === "auto");
  });
}
Vn();
var Zu = { optimizeUniversalDefaults: false, generalizedModifiers: true };
var nn = { future: ["hoverOnlyWhenSupported", "respectDefaultRingColorOpacity", "disableColorOpacityUtilitiesByDefault", "relativeContentPathsByDefault"], experimental: ["optimizeUniversalDefaults", "generalizedModifiers"] };
function G(t, e) {
  var r, n, i, s, a, o2;
  return nn.future.includes(e) ? t.future === "all" || ((i = (n = (r = t == null ? void 0 : t.future) == null ? void 0 : r[e]) != null ? n : Zu[e]) != null ? i : false) : nn.experimental.includes(e) ? t.experimental === "all" || ((o2 = (a = (s = t == null ? void 0 : t.experimental) == null ? void 0 : s[e]) != null ? a : Zu[e]) != null ? o2 : false) : false;
}
function tf(t) {
  if (false) {
    let e = ef(t).map((r) => zn.yellow(r)).join(", ");
    D.warn("experimental-flags-enabled", [`You have enabled experimental features: ${e}`, "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."]);
  }
}
function nf(t, e) {
  t.walkClasses((r) => {
    r.value = e(r.value), r.raws && r.raws.value && (r.raws.value = Be(r.raws.value));
  });
}
function sf(t, e) {
  if (!Me(t))
    return;
  let r = t.slice(1, -1);
  if (!!e(r))
    return z(r);
}
function jw(t, e = {}, r) {
  let n = e[t];
  if (n !== void 0)
    return De(n);
  if (Me(t)) {
    let i = sf(t, r);
    return i === void 0 ? void 0 : De(i);
  }
}
function sn(t, e = {}, { validate: r = () => true } = {}) {
  var i;
  let n = (i = e.values) == null ? void 0 : i[t];
  return n !== void 0 ? n : e.supportsNegativeValues && t.startsWith("-") ? jw(t.slice(1), e.values, r) : sf(t, r);
}
function Me(t) {
  return t.startsWith("[") && t.endsWith("]");
}
function af(t) {
  let e = t.lastIndexOf("/");
  return e === -1 || e === t.length - 1 ? [t, void 0] : Me(t) && !t.includes("]/[") ? [t, void 0] : [t.slice(0, e), t.slice(e + 1)];
}
function at(t) {
  if (typeof t == "string" && t.includes("<alpha-value>")) {
    let e = t;
    return ({ opacityValue: r = 1 }) => e.replace("<alpha-value>", r);
  }
  return t;
}
function zw(t, e = {}, { tailwindConfig: r = {} } = {}) {
  var s, a, o2, l, u, f;
  if (((s = e.values) == null ? void 0 : s[t]) !== void 0)
    return at((a = e.values) == null ? void 0 : a[t]);
  let [n, i] = af(t);
  if (i !== void 0) {
    let p = (l = (o2 = e.values) == null ? void 0 : o2[n]) != null ? l : Me(n) ? n.slice(1, -1) : void 0;
    return p === void 0 ? void 0 : (p = at(p), Me(i) ? ve(p, i.slice(1, -1)) : ((f = (u = r.theme) == null ? void 0 : u.opacity) == null ? void 0 : f[i]) === void 0 ? void 0 : ve(p, r.theme.opacity[i]));
  }
  return sn(t, e, { validate: Bu });
}
function Vw(t, e = {}) {
  var r;
  return (r = e.values) == null ? void 0 : r[t];
}
function oe(t) {
  return (e, r) => sn(e, r, { validate: t });
}
var Es = { any: sn, color: zw, url: oe(ks), image: oe(Gu), length: oe(ar), percentage: oe(sr), position: oe(Yu), lookup: Vw, "generic-name": oe(Qu), "family-name": oe(Hu), number: oe(Cs), "line-width": oe(Vu), "absolute-size": oe(Ju), "relative-size": oe(Xu), shadow: oe(Wu), size: oe(Ku) };
var rf = Object.keys(Es);
function Ww(t, e) {
  let r = t.indexOf(e);
  return r === -1 ? [void 0, t] : [t.slice(0, r), t.slice(r + 1)];
}
function As(t, e, r, n) {
  if (r.values && e in r.values)
    for (let { type: s } of t != null ? t : []) {
      let a = Es[s](e, r, { tailwindConfig: n });
      if (a !== void 0)
        return [a, s, null];
    }
  if (Me(e)) {
    let s = e.slice(1, -1), [a, o2] = Ww(s, ":");
    if (!/^[\w-_]+$/g.test(a))
      o2 = s;
    else if (a !== void 0 && !rf.includes(a))
      return [];
    if (o2.length > 0 && rf.includes(a))
      return [sn(`[${o2}]`, r), a, null];
  }
  let i = Os(t, e, r, n);
  for (let s of i)
    return s;
  return [];
}
function* Os(t, e, r, n) {
  var l, u;
  let i = G(n, "generalizedModifiers"), [s, a] = af(e);
  if (i && r.modifiers != null && (r.modifiers === "any" || typeof r.modifiers == "object" && (a && Me(a) || a in r.modifiers)) || (s = e, a = void 0), a !== void 0 && s === "" && (s = "DEFAULT"), a !== void 0 && typeof r.modifiers == "object") {
    let f = (u = (l = r.modifiers) == null ? void 0 : l[a]) != null ? u : null;
    f !== null ? a = f : Me(a) && (a = a.slice(1, -1));
  }
  for (let { type: f } of t != null ? t : []) {
    let p = Es[f](s, r, { tailwindConfig: n });
    p !== void 0 && (yield [p, f, a != null ? a : null]);
  }
}
var be = Y(Ae());
var uf = Y(Ur());
var of = Y(Ae());
function re(t) {
  var r, n;
  let e = of.default.className();
  return e.value = t, Be((n = (r = e == null ? void 0 : e.raws) == null ? void 0 : r.value) != null ? n : e.value);
}
var _s = ":merge";
function ot(t, { context: e, candidate: r }) {
  var a;
  let n = (a = e == null ? void 0 : e.tailwindConfig.prefix) != null ? a : "", i = t.map((o2) => {
    let l = (0, be.default)().astSync(o2.format);
    return { ...o2, ast: o2.isArbitraryVariant ? l : st(n, l) };
  }), s = be.default.root({ nodes: [be.default.selector({ nodes: [be.default.className({ value: re(r) })] })] });
  for (let { ast: o2 } of i)
    [s, o2] = Gw(s, o2), o2.walkNesting((l) => l.replaceWith(...s.nodes[0].nodes)), s = o2;
  return s;
}
function lf(t) {
  let e = [];
  for (; t.prev() && t.prev().type !== "combinator"; )
    t = t.prev();
  for (; t && t.type !== "combinator"; )
    e.push(t), t = t.next();
  return e;
}
function Bw(t) {
  return t.sort((e, r) => e.type === "tag" && r.type === "class" ? -1 : e.type === "class" && r.type === "tag" ? 1 : e.type === "class" && r.type === "pseudo" && r.value.startsWith("::") ? -1 : e.type === "pseudo" && e.value.startsWith("::") && r.type === "class" ? 1 : t.index(e) - t.index(r)), t;
}
function Ps(t, e) {
  let r = false;
  t.walk((n) => {
    if (n.type === "class" && n.value === e)
      return r = true, false;
  }), r || t.remove();
}
function an(t, e, { context: r, candidate: n, base: i }) {
  var f, p;
  let s = (p = (f = r == null ? void 0 : r.tailwindConfig) == null ? void 0 : f.separator) != null ? p : ":";
  i = i != null ? i : n.split(new RegExp(`\\${s}(?![^[]*\\])`)).pop();
  let a = (0, be.default)().astSync(t);
  a.walkClasses((c) => {
    c.raws && c.value.includes(i) && (c.raws.value = re((0, uf.default)(c.raws.value)));
  }), a.each((c) => Ps(c, i));
  let o2 = Array.isArray(e) ? ot(e, { context: r, candidate: n }) : e;
  if (o2 === null)
    return a.toString();
  let l = be.default.comment({ value: "/*__simple__*/" }), u = be.default.comment({ value: "/*__simple__*/" });
  return a.walkClasses((c) => {
    if (c.value !== i)
      return;
    let d = c.parent, h = o2.nodes[0].nodes;
    if (d.nodes.length === 1) {
      c.replaceWith(...h);
      return;
    }
    let y = lf(c);
    d.insertBefore(y[0], l), d.insertAfter(y[y.length - 1], u);
    for (let g of h)
      d.insertBefore(y[0], g.clone());
    c.remove(), y = lf(l);
    let m = d.index(l);
    d.nodes.splice(m, y.length, ...Bw(be.default.selector({ nodes: y })).nodes), l.remove(), u.remove();
  }), a.walkPseudos((c) => {
    c.value === _s && c.replaceWith(c.nodes);
  }), a.each((c) => {
    let d = ff(c);
    d.length > 0 && c.nodes.push(d.sort(Qw));
  }), a.toString();
}
function Gw(t, e) {
  let r = [];
  return t.walkPseudos((n) => {
    n.value === _s && r.push({ pseudo: n, value: n.nodes[0].toString() });
  }), e.walkPseudos((n) => {
    if (n.value !== _s)
      return;
    let i = n.nodes[0].toString(), s = r.find((u) => u.value === i);
    if (!s)
      return;
    let a = [], o2 = n.next();
    for (; o2 && o2.type !== "combinator"; )
      a.push(o2), o2 = o2.next();
    let l = o2;
    s.pseudo.parent.insertAfter(s.pseudo, be.default.selector({ nodes: a.map((u) => u.clone()) })), n.remove(), a.forEach((u) => u.remove()), l && l.type === "combinator" && l.remove();
  }), [t, e];
}
var Yw = [":before", ":after", ":first-line", ":first-letter"];
var Hw = ["::file-selector-button", "::-webkit-scrollbar", "::-webkit-scrollbar-button", "::-webkit-scrollbar-thumb", "::-webkit-scrollbar-track", "::-webkit-scrollbar-track-piece", "::-webkit-scrollbar-corner", "::-webkit-resizer"];
function ff(t) {
  let e = [];
  for (let r of t.nodes)
    Ts(r) && (e.push(r), t.removeChild(r)), r != null && r.nodes && e.push(...ff(r));
  return e;
}
function Qw(t, e) {
  return t.type !== "pseudo" && e.type !== "pseudo" || t.type === "combinator" ^ e.type === "combinator" ? 0 : t.type === "pseudo" ^ e.type === "pseudo" ? (t.type === "pseudo") - (e.type === "pseudo") : Ts(t) - Ts(e);
}
function Ts(t) {
  return t.type !== "pseudo" || Hw.includes(t.value) ? false : t.value.startsWith("::") || Yw.includes(t.value);
}
function Rs(t) {
  return Be(`.${re(t)}`);
}
function on(t, e) {
  return Rs(or(t, e));
}
function or(t, e) {
  return e === "DEFAULT" ? t : e === "-" || e === "-DEFAULT" ? `-${t}` : e.startsWith("-") ? `-${t}${e}` : e.startsWith("/") ? `${t}${e}` : `${t}-${e}`;
}
var Sf = Y(Ms());
var $s = Y(Ae());
function Oe(t) {
  return ["fontSize", "outline"].includes(t) ? (e) => (typeof e == "function" && (e = e({})), Array.isArray(e) && (e = e[0]), e) : t === "fontFamily" ? (e) => {
    typeof e == "function" && (e = e({}));
    let r = Array.isArray(e) && X(e[1]) ? e[0] : e;
    return Array.isArray(r) ? r.join(", ") : r;
  } : ["boxShadow", "transitionProperty", "transitionDuration", "transitionDelay", "transitionTimingFunction", "backgroundImage", "backgroundSize", "backgroundColor", "cursor", "animation"].includes(t) ? (e) => (typeof e == "function" && (e = e({})), Array.isArray(e) && (e = e.join(", ")), e) : ["gridTemplateColumns", "gridTemplateRows", "objectPosition"].includes(t) ? (e) => (typeof e == "function" && (e = e({})), typeof e == "string" && (e = I2.list.comma(e).join(" ")), e) : (e, r = {}) => (typeof e == "function" && (e = e(r)), e);
}
yr();
kt();
function T(t, e = [[t, [t]]], { filterDefault: r = false, ...n } = {}) {
  let i = Oe(t);
  return function({ matchUtilities: s, theme: a }) {
    var o2;
    for (let l of e) {
      let u = Array.isArray(l[0]) ? l : [l];
      s(u.reduce((f, [p, c]) => Object.assign(f, { [p]: (d) => c.reduce((h, y) => Array.isArray(y) ? Object.assign(h, { [y[0]]: y[1] }) : Object.assign(h, { [y]: i(d) }), {}) }), {}), { ...n, values: r ? Object.fromEntries(Object.entries((o2 = a(t)) != null ? o2 : {}).filter(([f]) => f !== "DEFAULT")) : a(t) });
    }
  };
}
function Le(t) {
  return t = Array.isArray(t) ? t : [t], t.map((e) => {
    let r = e.values.map((n) => n.raw !== void 0 ? n.raw : [n.min && `(min-width: ${n.min})`, n.max && `(max-width: ${n.max})`].filter(Boolean).join(" and "));
    return e.not ? `not all and ${r}` : r;
  }).join(", ");
}
var Jw = /* @__PURE__ */ new Set(["normal", "reverse", "alternate", "alternate-reverse"]);
var Xw = /* @__PURE__ */ new Set(["running", "paused"]);
var Kw = /* @__PURE__ */ new Set(["none", "forwards", "backwards", "both"]);
var Zw = /* @__PURE__ */ new Set(["infinite"]);
var ev = /* @__PURE__ */ new Set(["linear", "ease", "ease-in", "ease-out", "ease-in-out", "step-start", "step-end"]);
var tv = ["cubic-bezier", "steps"];
var rv = /\,(?![^(]*\))/g;
var nv = /\ +(?![^(]*\))/g;
var cf = /^(-?[\d.]+m?s)$/;
var iv = /^(\d+)$/;
function Ls(t) {
  return t.split(rv).map((r) => {
    let n = r.trim(), i = { value: n }, s = n.split(nv), a = /* @__PURE__ */ new Set();
    for (let o2 of s)
      !a.has("DIRECTIONS") && Jw.has(o2) ? (i.direction = o2, a.add("DIRECTIONS")) : !a.has("PLAY_STATES") && Xw.has(o2) ? (i.playState = o2, a.add("PLAY_STATES")) : !a.has("FILL_MODES") && Kw.has(o2) ? (i.fillMode = o2, a.add("FILL_MODES")) : !a.has("ITERATION_COUNTS") && (Zw.has(o2) || iv.test(o2)) ? (i.iterationCount = o2, a.add("ITERATION_COUNTS")) : !a.has("TIMING_FUNCTION") && ev.has(o2) || !a.has("TIMING_FUNCTION") && tv.some((l) => o2.startsWith(`${l}(`)) ? (i.timingFunction = o2, a.add("TIMING_FUNCTION")) : !a.has("DURATION") && cf.test(o2) ? (i.duration = o2, a.add("DURATION")) : !a.has("DELAY") && cf.test(o2) ? (i.delay = o2, a.add("DELAY")) : a.has("NAME") ? (i.unknown || (i.unknown = []), i.unknown.push(o2)) : (i.name = o2, a.add("NAME"));
    return i;
  });
}
var pf = (t) => Object.assign({}, ...Object.entries(t != null ? t : {}).flatMap(([e, r]) => typeof r == "object" ? Object.entries(pf(r)).map(([n, i]) => ({ [e + (n === "DEFAULT" ? "" : `-${n}`)]: i })) : [{ [`${e}`]: r }]));
var H = pf;
function N(t) {
  return typeof t == "function" ? t({}) : t;
}
function Fe(t, e = true) {
  return Array.isArray(t) ? t.map((r) => {
    if (e && Array.isArray(r))
      throw new Error("The tuple syntax is not supported for `screens`.");
    if (typeof r == "string")
      return { name: r.toString(), not: false, values: [{ min: r, max: void 0 }] };
    let [n, i] = r;
    return n = n.toString(), typeof i == "string" ? { name: n, not: false, values: [{ min: i, max: void 0 }] } : Array.isArray(i) ? { name: n, not: false, values: i.map((s) => df(s)) } : { name: n, not: false, values: [df(i)] };
  }) : Fe(Object.entries(t != null ? t : {}), false);
}
function ln(t) {
  return t.values.length !== 1 ? { result: false, reason: "multiple-values" } : t.values[0].raw !== void 0 ? { result: false, reason: "raw-values" } : t.values[0].min !== void 0 && t.values[0].max !== void 0 ? { result: false, reason: "min-and-max" } : { result: true, reason: null };
}
function hf(t, e, r) {
  let n = un(e, t), i = un(r, t), s = ln(n), a = ln(i);
  if (s.reason === "multiple-values" || a.reason === "multiple-values")
    throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
  if (s.reason === "raw-values" || a.reason === "raw-values")
    throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
  if (s.reason === "min-and-max" || a.reason === "min-and-max")
    throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
  let { min: o2, max: l } = n.values[0], { min: u, max: f } = i.values[0];
  e.not && ([o2, l] = [l, o2]), r.not && ([u, f] = [f, u]), o2 = o2 === void 0 ? o2 : parseFloat(o2), l = l === void 0 ? l : parseFloat(l), u = u === void 0 ? u : parseFloat(u), f = f === void 0 ? f : parseFloat(f);
  let [p, c] = t === "min" ? [o2, u] : [f, l];
  return p - c;
}
function un(t, e) {
  return typeof t == "object" ? t : { name: "arbitrary-screen", values: [{ [e]: t }] };
}
function df({ "min-width": t, min: e = t, max: r, raw: n } = {}) {
  return { min: e, max: r, raw: n };
}
function fn(t, e) {
  t.walkDecls((r) => {
    if (e.includes(r.prop)) {
      r.remove();
      return;
    }
    for (let n of e)
      r.value.includes(`/ var(${n})`) && (r.value = r.value.replace(`/ var(${n})`, ""));
  });
}
var ne = { pseudoElementVariants: ({ addVariant: t }) => {
  t("first-letter", "&::first-letter"), t("first-line", "&::first-line"), t("marker", [({ container: e }) => (fn(e, ["--tw-text-opacity"]), "& *::marker"), ({ container: e }) => (fn(e, ["--tw-text-opacity"]), "&::marker")]), t("selection", ["& *::selection", "&::selection"]), t("file", "&::file-selector-button"), t("placeholder", "&::placeholder"), t("backdrop", "&::backdrop"), t("before", ({ container: e }) => (e.walkRules((r) => {
    let n = false;
    r.walkDecls("content", () => {
      n = true;
    }), n || r.prepend(I2.decl({ prop: "content", value: "var(--tw-content)" }));
  }), "&::before")), t("after", ({ container: e }) => (e.walkRules((r) => {
    let n = false;
    r.walkDecls("content", () => {
      n = true;
    }), n || r.prepend(I2.decl({ prop: "content", value: "var(--tw-content)" }));
  }), "&::after"));
}, pseudoClassVariants: ({ addVariant: t, matchVariant: e, config: r }) => {
  let n = [["first", "&:first-child"], ["last", "&:last-child"], ["only", "&:only-child"], ["odd", "&:nth-child(odd)"], ["even", "&:nth-child(even)"], "first-of-type", "last-of-type", "only-of-type", ["visited", ({ container: s }) => (fn(s, ["--tw-text-opacity", "--tw-border-opacity", "--tw-bg-opacity"]), "&:visited")], "target", ["open", "&[open]"], "default", "checked", "indeterminate", "placeholder-shown", "autofill", "optional", "required", "valid", "invalid", "in-range", "out-of-range", "read-only", "empty", "focus-within", ["hover", G(r(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"], "focus", "focus-visible", "active", "enabled", "disabled"].map((s) => Array.isArray(s) ? s : [s, `&:${s}`]);
  for (let [s, a] of n)
    t(s, (o2) => typeof a == "function" ? a(o2) : a);
  let i = { group: (s, { modifier: a }) => a ? [`:merge(.group\\/${re(a)})`, " &"] : [":merge(.group)", " &"], peer: (s, { modifier: a }) => a ? [`:merge(.peer\\/${re(a)})`, " ~ &"] : [":merge(.peer)", " ~ &"] };
  for (let [s, a] of Object.entries(i))
    e(s, (o2 = "", l) => {
      let u = z(typeof o2 == "function" ? o2(l) : o2);
      u.includes("&") || (u = "&" + u);
      let [f, p] = a("", l), c = null, d = null, h = 0;
      for (let y = 0; y < u.length; ++y) {
        let m = u[y];
        m === "&" ? c = y : m === "'" || m === '"' ? h += 1 : c !== null && m === " " && !h && (d = y);
      }
      return c !== null && d === null && (d = u.length), u.slice(0, c) + f + u.slice(c + 1, d) + p + u.slice(d);
    }, { values: Object.fromEntries(n) });
}, directionVariants: ({ addVariant: t }) => {
  t("ltr", () => (D.warn("rtl-experimental", ["The RTL features in Tailwind CSS are currently in preview.", "Preview features are not covered by semver, and may be improved in breaking ways at any time."]), '[dir="ltr"] &')), t("rtl", () => (D.warn("rtl-experimental", ["The RTL features in Tailwind CSS are currently in preview.", "Preview features are not covered by semver, and may be improved in breaking ways at any time."]), '[dir="rtl"] &'));
}, reducedMotionVariants: ({ addVariant: t }) => {
  t("motion-safe", "@media (prefers-reduced-motion: no-preference)"), t("motion-reduce", "@media (prefers-reduced-motion: reduce)");
}, darkVariants: ({ config: t, addVariant: e }) => {
  let [r, n = ".dark"] = [].concat(t("darkMode", "media"));
  r === false && (r = "media", D.warn("darkmode-false", ["The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.", "Change `darkMode` to `media` or remove it entirely.", "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"])), r === "class" ? e("dark", `${n} &`) : r === "media" && e("dark", "@media (prefers-color-scheme: dark)");
}, printVariant: ({ addVariant: t }) => {
  t("print", "@media print");
}, screenVariants: ({ theme: t, addVariant: e, matchVariant: r }) => {
  var g;
  let n = (g = t("screens")) != null ? g : {}, i = Object.values(n).every((w) => typeof w == "string"), s = Fe(t("screens")), a = /* @__PURE__ */ new Set([]);
  function o2(w) {
    var b, v;
    return (v = (b = w.match(/(\D+)$/)) == null ? void 0 : b[1]) != null ? v : "(none)";
  }
  function l(w) {
    w !== void 0 && a.add(o2(w));
  }
  function u(w) {
    return l(w), a.size === 1;
  }
  for (let w of s)
    for (let b of w.values)
      l(b.min), l(b.max);
  let f = a.size <= 1;
  function p(w) {
    return Object.fromEntries(s.filter((b) => ln(b).result).map((b) => {
      let { min: v, max: C } = b.values[0];
      if (w === "min" && v !== void 0)
        return b;
      if (w === "min" && C !== void 0)
        return { ...b, not: !b.not };
      if (w === "max" && C !== void 0)
        return b;
      if (w === "max" && v !== void 0)
        return { ...b, not: !b.not };
    }).map((b) => [b.name, b]));
  }
  function c(w) {
    return (b, v) => hf(w, b.value, v.value);
  }
  let d = c("max"), h = c("min");
  function y(w) {
    return (b) => {
      if (i)
        if (f) {
          if (typeof b == "string" && !u(b))
            return D.warn("minmax-have-mixed-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
        } else
          return D.warn("mixed-screen-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
      else
        return D.warn("complex-screen-config", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."]), [];
      return [`@media ${Le(un(b, w))}`];
    };
  }
  r("max", y("max"), { sort: d, values: i ? p("max") : {} });
  let m = "min-screens";
  for (let w of s)
    e(w.name, `@media ${Le(w)}`, { id: m, sort: i && f ? h : void 0, value: w });
  r("min", y("min"), { id: m, sort: h });
}, supportsVariants: ({ matchVariant: t, theme: e }) => {
  var r;
  t("supports", (n = "") => {
    let i = z(n), s = /^\w*\s*\(/.test(i);
    return i = s ? i.replace(/\b(and|or|not)\b/g, " $1 ") : i, s ? `@supports ${i}` : (i.includes(":") || (i = `${i}: var(--tw)`), i.startsWith("(") && i.endsWith(")") || (i = `(${i})`), `@supports ${i}`);
  }, { values: (r = e("supports")) != null ? r : {} });
}, ariaVariants: ({ matchVariant: t, theme: e }) => {
  var r, n, i;
  t("aria", (s) => `&[aria-${z(s)}]`, { values: (r = e("aria")) != null ? r : {} }), t("group-aria", (s, { modifier: a }) => a ? `:merge(.group\\/${a})[aria-${z(s)}] &` : `:merge(.group)[aria-${z(s)}] &`, { values: (n = e("aria")) != null ? n : {} }), t("peer-aria", (s, { modifier: a }) => a ? `:merge(.peer\\/${a})[aria-${z(s)}] ~ &` : `:merge(.peer)[aria-${z(s)}] ~ &`, { values: (i = e("aria")) != null ? i : {} });
}, dataVariants: ({ matchVariant: t, theme: e }) => {
  var r, n, i;
  t("data", (s) => `&[data-${z(s)}]`, { values: (r = e("data")) != null ? r : {} }), t("group-data", (s, { modifier: a }) => a ? `:merge(.group\\/${a})[data-${z(s)}] &` : `:merge(.group)[data-${z(s)}] &`, { values: (n = e("data")) != null ? n : {} }), t("peer-data", (s, { modifier: a }) => a ? `:merge(.peer\\/${a})[data-${z(s)}] ~ &` : `:merge(.peer)[data-${z(s)}] ~ &`, { values: (i = e("data")) != null ? i : {} });
}, orientationVariants: ({ addVariant: t }) => {
  t("portrait", "@media (orientation: portrait)"), t("landscape", "@media (orientation: landscape)");
}, prefersContrastVariants: ({ addVariant: t }) => {
  t("contrast-more", "@media (prefers-contrast: more)"), t("contrast-less", "@media (prefers-contrast: less)");
} };
var he = ["translate(var(--tw-translate-x), var(--tw-translate-y))", "rotate(var(--tw-rotate))", "skewX(var(--tw-skew-x))", "skewY(var(--tw-skew-y))", "scaleX(var(--tw-scale-x))", "scaleY(var(--tw-scale-y))"].join(" ");
var xe = ["var(--tw-blur)", "var(--tw-brightness)", "var(--tw-contrast)", "var(--tw-grayscale)", "var(--tw-hue-rotate)", "var(--tw-invert)", "var(--tw-saturate)", "var(--tw-sepia)", "var(--tw-drop-shadow)"].join(" ");
var Se = ["var(--tw-backdrop-blur)", "var(--tw-backdrop-brightness)", "var(--tw-backdrop-contrast)", "var(--tw-backdrop-grayscale)", "var(--tw-backdrop-hue-rotate)", "var(--tw-backdrop-invert)", "var(--tw-backdrop-opacity)", "var(--tw-backdrop-saturate)", "var(--tw-backdrop-sepia)"].join(" ");
var mf = { preflight: ({ addBase: t }) => {
  let e = I2.parse(ht.readFileSync(Qn("/", "./css/preflight.css"), "utf8"));
  t([I2.comment({ text: `! tailwindcss v${La} | MIT License | https://tailwindcss.com` }), ...e.nodes]);
}, container: (() => {
  function t(r = []) {
    return r.flatMap((n) => n.values.map((i) => i.min)).filter((n) => n !== void 0);
  }
  function e(r, n, i) {
    if (typeof i > "u")
      return [];
    if (!(typeof i == "object" && i !== null))
      return [{ screen: "DEFAULT", minWidth: 0, padding: i }];
    let s = [];
    i.DEFAULT && s.push({ screen: "DEFAULT", minWidth: 0, padding: i.DEFAULT });
    for (let a of r)
      for (let o2 of n)
        for (let { min: l } of o2.values)
          l === a && s.push({ minWidth: a, padding: i[o2.name] });
    return s;
  }
  return function({ addComponents: r, theme: n }) {
    let i = Fe(n("container.screens", n("screens"))), s = t(i), a = e(s, i, n("container.padding")), o2 = (u) => {
      let f = a.find((p) => p.minWidth === u);
      return f ? { paddingRight: f.padding, paddingLeft: f.padding } : {};
    }, l = Array.from(new Set(s.slice().sort((u, f) => parseInt(u) - parseInt(f)))).map((u) => ({ [`@media (min-width: ${u})`]: { ".container": { "max-width": u, ...o2(u) } } }));
    r([{ ".container": Object.assign({ width: "100%" }, n("container.center", false) ? { marginRight: "auto", marginLeft: "auto" } : {}, o2(0)) }, ...l]);
  };
})(), accessibility: ({ addUtilities: t }) => {
  t({ ".sr-only": { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" }, ".not-sr-only": { position: "static", width: "auto", height: "auto", padding: "0", margin: "0", overflow: "visible", clip: "auto", whiteSpace: "normal" } });
}, pointerEvents: ({ addUtilities: t }) => {
  t({ ".pointer-events-none": { "pointer-events": "none" }, ".pointer-events-auto": { "pointer-events": "auto" } });
}, visibility: ({ addUtilities: t }) => {
  t({ ".visible": { visibility: "visible" }, ".invisible": { visibility: "hidden" }, ".collapse": { visibility: "collapse" } });
}, position: ({ addUtilities: t }) => {
  t({ ".static": { position: "static" }, ".fixed": { position: "fixed" }, ".absolute": { position: "absolute" }, ".relative": { position: "relative" }, ".sticky": { position: "sticky" } });
}, inset: T("inset", [["inset", ["top", "right", "bottom", "left"]], [["inset-x", ["left", "right"]], ["inset-y", ["top", "bottom"]]], [["top", ["top"]], ["right", ["right"]], ["bottom", ["bottom"]], ["left", ["left"]]]], { supportsNegativeValues: true }), isolation: ({ addUtilities: t }) => {
  t({ ".isolate": { isolation: "isolate" }, ".isolation-auto": { isolation: "auto" } });
}, zIndex: T("zIndex", [["z", ["zIndex"]]], { supportsNegativeValues: true }), order: T("order", void 0, { supportsNegativeValues: true }), gridColumn: T("gridColumn", [["col", ["gridColumn"]]]), gridColumnStart: T("gridColumnStart", [["col-start", ["gridColumnStart"]]]), gridColumnEnd: T("gridColumnEnd", [["col-end", ["gridColumnEnd"]]]), gridRow: T("gridRow", [["row", ["gridRow"]]]), gridRowStart: T("gridRowStart", [["row-start", ["gridRowStart"]]]), gridRowEnd: T("gridRowEnd", [["row-end", ["gridRowEnd"]]]), float: ({ addUtilities: t }) => {
  t({ ".float-right": { float: "right" }, ".float-left": { float: "left" }, ".float-none": { float: "none" } });
}, clear: ({ addUtilities: t }) => {
  t({ ".clear-left": { clear: "left" }, ".clear-right": { clear: "right" }, ".clear-both": { clear: "both" }, ".clear-none": { clear: "none" } });
}, margin: T("margin", [["m", ["margin"]], [["mx", ["margin-left", "margin-right"]], ["my", ["margin-top", "margin-bottom"]]], [["mt", ["margin-top"]], ["mr", ["margin-right"]], ["mb", ["margin-bottom"]], ["ml", ["margin-left"]]]], { supportsNegativeValues: true }), boxSizing: ({ addUtilities: t }) => {
  t({ ".box-border": { "box-sizing": "border-box" }, ".box-content": { "box-sizing": "content-box" } });
}, display: ({ addUtilities: t }) => {
  t({ ".block": { display: "block" }, ".inline-block": { display: "inline-block" }, ".inline": { display: "inline" }, ".flex": { display: "flex" }, ".inline-flex": { display: "inline-flex" }, ".table": { display: "table" }, ".inline-table": { display: "inline-table" }, ".table-caption": { display: "table-caption" }, ".table-cell": { display: "table-cell" }, ".table-column": { display: "table-column" }, ".table-column-group": { display: "table-column-group" }, ".table-footer-group": { display: "table-footer-group" }, ".table-header-group": { display: "table-header-group" }, ".table-row-group": { display: "table-row-group" }, ".table-row": { display: "table-row" }, ".flow-root": { display: "flow-root" }, ".grid": { display: "grid" }, ".inline-grid": { display: "inline-grid" }, ".contents": { display: "contents" }, ".list-item": { display: "list-item" }, ".hidden": { display: "none" } });
}, aspectRatio: T("aspectRatio", [["aspect", ["aspect-ratio"]]]), height: T("height", [["h", ["height"]]]), maxHeight: T("maxHeight", [["max-h", ["maxHeight"]]]), minHeight: T("minHeight", [["min-h", ["minHeight"]]]), width: T("width", [["w", ["width"]]]), minWidth: T("minWidth", [["min-w", ["minWidth"]]]), maxWidth: T("maxWidth", [["max-w", ["maxWidth"]]]), flex: T("flex"), flexShrink: T("flexShrink", [["flex-shrink", ["flex-shrink"]], ["shrink", ["flex-shrink"]]]), flexGrow: T("flexGrow", [["flex-grow", ["flex-grow"]], ["grow", ["flex-grow"]]]), flexBasis: T("flexBasis", [["basis", ["flex-basis"]]]), tableLayout: ({ addUtilities: t }) => {
  t({ ".table-auto": { "table-layout": "auto" }, ".table-fixed": { "table-layout": "fixed" } });
}, borderCollapse: ({ addUtilities: t }) => {
  t({ ".border-collapse": { "border-collapse": "collapse" }, ".border-separate": { "border-collapse": "separate" } });
}, borderSpacing: ({ addDefaults: t, matchUtilities: e, theme: r }) => {
  t("border-spacing", { "--tw-border-spacing-x": 0, "--tw-border-spacing-y": 0 }), e({ "border-spacing": (n) => ({ "--tw-border-spacing-x": n, "--tw-border-spacing-y": n, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-x": (n) => ({ "--tw-border-spacing-x": n, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-y": (n) => ({ "--tw-border-spacing-y": n, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }) }, { values: r("borderSpacing") });
}, transformOrigin: T("transformOrigin", [["origin", ["transformOrigin"]]]), translate: T("translate", [[["translate-x", [["@defaults transform", {}], "--tw-translate-x", ["transform", he]]], ["translate-y", [["@defaults transform", {}], "--tw-translate-y", ["transform", he]]]]], { supportsNegativeValues: true }), rotate: T("rotate", [["rotate", [["@defaults transform", {}], "--tw-rotate", ["transform", he]]]], { supportsNegativeValues: true }), skew: T("skew", [[["skew-x", [["@defaults transform", {}], "--tw-skew-x", ["transform", he]]], ["skew-y", [["@defaults transform", {}], "--tw-skew-y", ["transform", he]]]]], { supportsNegativeValues: true }), scale: T("scale", [["scale", [["@defaults transform", {}], "--tw-scale-x", "--tw-scale-y", ["transform", he]]], [["scale-x", [["@defaults transform", {}], "--tw-scale-x", ["transform", he]]], ["scale-y", [["@defaults transform", {}], "--tw-scale-y", ["transform", he]]]]], { supportsNegativeValues: true }), transform: ({ addDefaults: t, addUtilities: e }) => {
  t("transform", { "--tw-translate-x": "0", "--tw-translate-y": "0", "--tw-rotate": "0", "--tw-skew-x": "0", "--tw-skew-y": "0", "--tw-scale-x": "1", "--tw-scale-y": "1" }), e({ ".transform": { "@defaults transform": {}, transform: he }, ".transform-cpu": { transform: he }, ".transform-gpu": { transform: he.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)") }, ".transform-none": { transform: "none" } });
}, animation: ({ matchUtilities: t, theme: e, config: r }) => {
  var s;
  let n = (a) => `${r("prefix")}${re(a)}`, i = Object.fromEntries(Object.entries((s = e("keyframes")) != null ? s : {}).map(([a, o2]) => [a, { [`@keyframes ${n(a)}`]: o2 }]));
  t({ animate: (a) => {
    let o2 = Ls(a);
    return [...o2.flatMap((l) => i[l.name]), { animation: o2.map(({ name: l, value: u }) => l === void 0 || i[l] === void 0 ? u : u.replace(l, n(l))).join(", ") }];
  } }, { values: e("animation") });
}, cursor: T("cursor"), touchAction: ({ addDefaults: t, addUtilities: e }) => {
  t("touch-action", { "--tw-pan-x": " ", "--tw-pan-y": " ", "--tw-pinch-zoom": " " });
  let r = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
  e({ ".touch-auto": { "touch-action": "auto" }, ".touch-none": { "touch-action": "none" }, ".touch-pan-x": { "@defaults touch-action": {}, "--tw-pan-x": "pan-x", "touch-action": r }, ".touch-pan-left": { "@defaults touch-action": {}, "--tw-pan-x": "pan-left", "touch-action": r }, ".touch-pan-right": { "@defaults touch-action": {}, "--tw-pan-x": "pan-right", "touch-action": r }, ".touch-pan-y": { "@defaults touch-action": {}, "--tw-pan-y": "pan-y", "touch-action": r }, ".touch-pan-up": { "@defaults touch-action": {}, "--tw-pan-y": "pan-up", "touch-action": r }, ".touch-pan-down": { "@defaults touch-action": {}, "--tw-pan-y": "pan-down", "touch-action": r }, ".touch-pinch-zoom": { "@defaults touch-action": {}, "--tw-pinch-zoom": "pinch-zoom", "touch-action": r }, ".touch-manipulation": { "touch-action": "manipulation" } });
}, userSelect: ({ addUtilities: t }) => {
  t({ ".select-none": { "user-select": "none" }, ".select-text": { "user-select": "text" }, ".select-all": { "user-select": "all" }, ".select-auto": { "user-select": "auto" } });
}, resize: ({ addUtilities: t }) => {
  t({ ".resize-none": { resize: "none" }, ".resize-y": { resize: "vertical" }, ".resize-x": { resize: "horizontal" }, ".resize": { resize: "both" } });
}, scrollSnapType: ({ addDefaults: t, addUtilities: e }) => {
  t("scroll-snap-type", { "--tw-scroll-snap-strictness": "proximity" }), e({ ".snap-none": { "scroll-snap-type": "none" }, ".snap-x": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "x var(--tw-scroll-snap-strictness)" }, ".snap-y": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "y var(--tw-scroll-snap-strictness)" }, ".snap-both": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "both var(--tw-scroll-snap-strictness)" }, ".snap-mandatory": { "--tw-scroll-snap-strictness": "mandatory" }, ".snap-proximity": { "--tw-scroll-snap-strictness": "proximity" } });
}, scrollSnapAlign: ({ addUtilities: t }) => {
  t({ ".snap-start": { "scroll-snap-align": "start" }, ".snap-end": { "scroll-snap-align": "end" }, ".snap-center": { "scroll-snap-align": "center" }, ".snap-align-none": { "scroll-snap-align": "none" } });
}, scrollSnapStop: ({ addUtilities: t }) => {
  t({ ".snap-normal": { "scroll-snap-stop": "normal" }, ".snap-always": { "scroll-snap-stop": "always" } });
}, scrollMargin: T("scrollMargin", [["scroll-m", ["scroll-margin"]], [["scroll-mx", ["scroll-margin-left", "scroll-margin-right"]], ["scroll-my", ["scroll-margin-top", "scroll-margin-bottom"]]], [["scroll-mt", ["scroll-margin-top"]], ["scroll-mr", ["scroll-margin-right"]], ["scroll-mb", ["scroll-margin-bottom"]], ["scroll-ml", ["scroll-margin-left"]]]], { supportsNegativeValues: true }), scrollPadding: T("scrollPadding", [["scroll-p", ["scroll-padding"]], [["scroll-px", ["scroll-padding-left", "scroll-padding-right"]], ["scroll-py", ["scroll-padding-top", "scroll-padding-bottom"]]], [["scroll-pt", ["scroll-padding-top"]], ["scroll-pr", ["scroll-padding-right"]], ["scroll-pb", ["scroll-padding-bottom"]], ["scroll-pl", ["scroll-padding-left"]]]]), listStylePosition: ({ addUtilities: t }) => {
  t({ ".list-inside": { "list-style-position": "inside" }, ".list-outside": { "list-style-position": "outside" } });
}, listStyleType: T("listStyleType", [["list", ["listStyleType"]]]), appearance: ({ addUtilities: t }) => {
  t({ ".appearance-none": { appearance: "none" } });
}, columns: T("columns", [["columns", ["columns"]]]), breakBefore: ({ addUtilities: t }) => {
  t({ ".break-before-auto": { "break-before": "auto" }, ".break-before-avoid": { "break-before": "avoid" }, ".break-before-all": { "break-before": "all" }, ".break-before-avoid-page": { "break-before": "avoid-page" }, ".break-before-page": { "break-before": "page" }, ".break-before-left": { "break-before": "left" }, ".break-before-right": { "break-before": "right" }, ".break-before-column": { "break-before": "column" } });
}, breakInside: ({ addUtilities: t }) => {
  t({ ".break-inside-auto": { "break-inside": "auto" }, ".break-inside-avoid": { "break-inside": "avoid" }, ".break-inside-avoid-page": { "break-inside": "avoid-page" }, ".break-inside-avoid-column": { "break-inside": "avoid-column" } });
}, breakAfter: ({ addUtilities: t }) => {
  t({ ".break-after-auto": { "break-after": "auto" }, ".break-after-avoid": { "break-after": "avoid" }, ".break-after-all": { "break-after": "all" }, ".break-after-avoid-page": { "break-after": "avoid-page" }, ".break-after-page": { "break-after": "page" }, ".break-after-left": { "break-after": "left" }, ".break-after-right": { "break-after": "right" }, ".break-after-column": { "break-after": "column" } });
}, gridAutoColumns: T("gridAutoColumns", [["auto-cols", ["gridAutoColumns"]]]), gridAutoFlow: ({ addUtilities: t }) => {
  t({ ".grid-flow-row": { gridAutoFlow: "row" }, ".grid-flow-col": { gridAutoFlow: "column" }, ".grid-flow-dense": { gridAutoFlow: "dense" }, ".grid-flow-row-dense": { gridAutoFlow: "row dense" }, ".grid-flow-col-dense": { gridAutoFlow: "column dense" } });
}, gridAutoRows: T("gridAutoRows", [["auto-rows", ["gridAutoRows"]]]), gridTemplateColumns: T("gridTemplateColumns", [["grid-cols", ["gridTemplateColumns"]]]), gridTemplateRows: T("gridTemplateRows", [["grid-rows", ["gridTemplateRows"]]]), flexDirection: ({ addUtilities: t }) => {
  t({ ".flex-row": { "flex-direction": "row" }, ".flex-row-reverse": { "flex-direction": "row-reverse" }, ".flex-col": { "flex-direction": "column" }, ".flex-col-reverse": { "flex-direction": "column-reverse" } });
}, flexWrap: ({ addUtilities: t }) => {
  t({ ".flex-wrap": { "flex-wrap": "wrap" }, ".flex-wrap-reverse": { "flex-wrap": "wrap-reverse" }, ".flex-nowrap": { "flex-wrap": "nowrap" } });
}, placeContent: ({ addUtilities: t }) => {
  t({ ".place-content-center": { "place-content": "center" }, ".place-content-start": { "place-content": "start" }, ".place-content-end": { "place-content": "end" }, ".place-content-between": { "place-content": "space-between" }, ".place-content-around": { "place-content": "space-around" }, ".place-content-evenly": { "place-content": "space-evenly" }, ".place-content-baseline": { "place-content": "baseline" }, ".place-content-stretch": { "place-content": "stretch" } });
}, placeItems: ({ addUtilities: t }) => {
  t({ ".place-items-start": { "place-items": "start" }, ".place-items-end": { "place-items": "end" }, ".place-items-center": { "place-items": "center" }, ".place-items-baseline": { "place-items": "baseline" }, ".place-items-stretch": { "place-items": "stretch" } });
}, alignContent: ({ addUtilities: t }) => {
  t({ ".content-center": { "align-content": "center" }, ".content-start": { "align-content": "flex-start" }, ".content-end": { "align-content": "flex-end" }, ".content-between": { "align-content": "space-between" }, ".content-around": { "align-content": "space-around" }, ".content-evenly": { "align-content": "space-evenly" }, ".content-baseline": { "align-content": "baseline" } });
}, alignItems: ({ addUtilities: t }) => {
  t({ ".items-start": { "align-items": "flex-start" }, ".items-end": { "align-items": "flex-end" }, ".items-center": { "align-items": "center" }, ".items-baseline": { "align-items": "baseline" }, ".items-stretch": { "align-items": "stretch" } });
}, justifyContent: ({ addUtilities: t }) => {
  t({ ".justify-start": { "justify-content": "flex-start" }, ".justify-end": { "justify-content": "flex-end" }, ".justify-center": { "justify-content": "center" }, ".justify-between": { "justify-content": "space-between" }, ".justify-around": { "justify-content": "space-around" }, ".justify-evenly": { "justify-content": "space-evenly" } });
}, justifyItems: ({ addUtilities: t }) => {
  t({ ".justify-items-start": { "justify-items": "start" }, ".justify-items-end": { "justify-items": "end" }, ".justify-items-center": { "justify-items": "center" }, ".justify-items-stretch": { "justify-items": "stretch" } });
}, gap: T("gap", [["gap", ["gap"]], [["gap-x", ["columnGap"]], ["gap-y", ["rowGap"]]]]), space: ({ matchUtilities: t, addUtilities: e, theme: r }) => {
  t({ "space-x": (n) => (n = n === "0" ? "0px" : n, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "0", "margin-right": `calc(${n} * var(--tw-space-x-reverse))`, "margin-left": `calc(${n} * calc(1 - var(--tw-space-x-reverse)))` } }), "space-y": (n) => (n = n === "0" ? "0px" : n, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "0", "margin-top": `calc(${n} * calc(1 - var(--tw-space-y-reverse)))`, "margin-bottom": `calc(${n} * var(--tw-space-y-reverse))` } }) }, { values: r("space"), supportsNegativeValues: true }), e({ ".space-y-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "1" }, ".space-x-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "1" } });
}, divideWidth: ({ matchUtilities: t, addUtilities: e, theme: r }) => {
  t({ "divide-x": (n) => (n = n === "0" ? "0px" : n, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "0", "border-right-width": `calc(${n} * var(--tw-divide-x-reverse))`, "border-left-width": `calc(${n} * calc(1 - var(--tw-divide-x-reverse)))` } }), "divide-y": (n) => (n = n === "0" ? "0px" : n, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "0", "border-top-width": `calc(${n} * calc(1 - var(--tw-divide-y-reverse)))`, "border-bottom-width": `calc(${n} * var(--tw-divide-y-reverse))` } }) }, { values: r("divideWidth"), type: ["line-width", "length", "any"] }), e({ ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "1" }, ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "1" } });
}, divideStyle: ({ addUtilities: t }) => {
  t({ ".divide-solid > :not([hidden]) ~ :not([hidden])": { "border-style": "solid" }, ".divide-dashed > :not([hidden]) ~ :not([hidden])": { "border-style": "dashed" }, ".divide-dotted > :not([hidden]) ~ :not([hidden])": { "border-style": "dotted" }, ".divide-double > :not([hidden]) ~ :not([hidden])": { "border-style": "double" }, ".divide-none > :not([hidden]) ~ :not([hidden])": { "border-style": "none" } });
}, divideColor: ({ matchUtilities: t, theme: e, corePlugins: r }) => {
  t({ divide: (n) => r("divideOpacity") ? { ["& > :not([hidden]) ~ :not([hidden])"]: ee({ color: n, property: "border-color", variable: "--tw-divide-opacity" }) } : { ["& > :not([hidden]) ~ :not([hidden])"]: { "border-color": N(n) } } }, { values: (({ DEFAULT: n, ...i }) => i)(H(e("divideColor"))), type: ["color", "any"] });
}, divideOpacity: ({ matchUtilities: t, theme: e }) => {
  t({ "divide-opacity": (r) => ({ ["& > :not([hidden]) ~ :not([hidden])"]: { "--tw-divide-opacity": r } }) }, { values: e("divideOpacity") });
}, placeSelf: ({ addUtilities: t }) => {
  t({ ".place-self-auto": { "place-self": "auto" }, ".place-self-start": { "place-self": "start" }, ".place-self-end": { "place-self": "end" }, ".place-self-center": { "place-self": "center" }, ".place-self-stretch": { "place-self": "stretch" } });
}, alignSelf: ({ addUtilities: t }) => {
  t({ ".self-auto": { "align-self": "auto" }, ".self-start": { "align-self": "flex-start" }, ".self-end": { "align-self": "flex-end" }, ".self-center": { "align-self": "center" }, ".self-stretch": { "align-self": "stretch" }, ".self-baseline": { "align-self": "baseline" } });
}, justifySelf: ({ addUtilities: t }) => {
  t({ ".justify-self-auto": { "justify-self": "auto" }, ".justify-self-start": { "justify-self": "start" }, ".justify-self-end": { "justify-self": "end" }, ".justify-self-center": { "justify-self": "center" }, ".justify-self-stretch": { "justify-self": "stretch" } });
}, overflow: ({ addUtilities: t }) => {
  t({ ".overflow-auto": { overflow: "auto" }, ".overflow-hidden": { overflow: "hidden" }, ".overflow-clip": { overflow: "clip" }, ".overflow-visible": { overflow: "visible" }, ".overflow-scroll": { overflow: "scroll" }, ".overflow-x-auto": { "overflow-x": "auto" }, ".overflow-y-auto": { "overflow-y": "auto" }, ".overflow-x-hidden": { "overflow-x": "hidden" }, ".overflow-y-hidden": { "overflow-y": "hidden" }, ".overflow-x-clip": { "overflow-x": "clip" }, ".overflow-y-clip": { "overflow-y": "clip" }, ".overflow-x-visible": { "overflow-x": "visible" }, ".overflow-y-visible": { "overflow-y": "visible" }, ".overflow-x-scroll": { "overflow-x": "scroll" }, ".overflow-y-scroll": { "overflow-y": "scroll" } });
}, overscrollBehavior: ({ addUtilities: t }) => {
  t({ ".overscroll-auto": { "overscroll-behavior": "auto" }, ".overscroll-contain": { "overscroll-behavior": "contain" }, ".overscroll-none": { "overscroll-behavior": "none" }, ".overscroll-y-auto": { "overscroll-behavior-y": "auto" }, ".overscroll-y-contain": { "overscroll-behavior-y": "contain" }, ".overscroll-y-none": { "overscroll-behavior-y": "none" }, ".overscroll-x-auto": { "overscroll-behavior-x": "auto" }, ".overscroll-x-contain": { "overscroll-behavior-x": "contain" }, ".overscroll-x-none": { "overscroll-behavior-x": "none" } });
}, scrollBehavior: ({ addUtilities: t }) => {
  t({ ".scroll-auto": { "scroll-behavior": "auto" }, ".scroll-smooth": { "scroll-behavior": "smooth" } });
}, textOverflow: ({ addUtilities: t }) => {
  t({ ".truncate": { overflow: "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }, ".overflow-ellipsis": { "text-overflow": "ellipsis" }, ".text-ellipsis": { "text-overflow": "ellipsis" }, ".text-clip": { "text-overflow": "clip" } });
}, whitespace: ({ addUtilities: t }) => {
  t({ ".whitespace-normal": { "white-space": "normal" }, ".whitespace-nowrap": { "white-space": "nowrap" }, ".whitespace-pre": { "white-space": "pre" }, ".whitespace-pre-line": { "white-space": "pre-line" }, ".whitespace-pre-wrap": { "white-space": "pre-wrap" } });
}, wordBreak: ({ addUtilities: t }) => {
  t({ ".break-normal": { "overflow-wrap": "normal", "word-break": "normal" }, ".break-words": { "overflow-wrap": "break-word" }, ".break-all": { "word-break": "break-all" }, ".break-keep": { "word-break": "keep-all" } });
}, borderRadius: T("borderRadius", [["rounded", ["border-radius"]], [["rounded-t", ["border-top-left-radius", "border-top-right-radius"]], ["rounded-r", ["border-top-right-radius", "border-bottom-right-radius"]], ["rounded-b", ["border-bottom-right-radius", "border-bottom-left-radius"]], ["rounded-l", ["border-top-left-radius", "border-bottom-left-radius"]]], [["rounded-tl", ["border-top-left-radius"]], ["rounded-tr", ["border-top-right-radius"]], ["rounded-br", ["border-bottom-right-radius"]], ["rounded-bl", ["border-bottom-left-radius"]]]]), borderWidth: T("borderWidth", [["border", [["@defaults border-width", {}], "border-width"]], [["border-x", [["@defaults border-width", {}], "border-left-width", "border-right-width"]], ["border-y", [["@defaults border-width", {}], "border-top-width", "border-bottom-width"]]], [["border-t", [["@defaults border-width", {}], "border-top-width"]], ["border-r", [["@defaults border-width", {}], "border-right-width"]], ["border-b", [["@defaults border-width", {}], "border-bottom-width"]], ["border-l", [["@defaults border-width", {}], "border-left-width"]]]], { type: ["line-width", "length"] }), borderStyle: ({ addUtilities: t }) => {
  t({ ".border-solid": { "border-style": "solid" }, ".border-dashed": { "border-style": "dashed" }, ".border-dotted": { "border-style": "dotted" }, ".border-double": { "border-style": "double" }, ".border-hidden": { "border-style": "hidden" }, ".border-none": { "border-style": "none" } });
}, borderColor: ({ matchUtilities: t, theme: e, corePlugins: r }) => {
  t({ border: (n) => r("borderOpacity") ? ee({ color: n, property: "border-color", variable: "--tw-border-opacity" }) : { "border-color": N(n) } }, { values: (({ DEFAULT: n, ...i }) => i)(H(e("borderColor"))), type: ["color", "any"] }), t({ "border-x": (n) => r("borderOpacity") ? ee({ color: n, property: ["border-left-color", "border-right-color"], variable: "--tw-border-opacity" }) : { "border-left-color": N(n), "border-right-color": N(n) }, "border-y": (n) => r("borderOpacity") ? ee({ color: n, property: ["border-top-color", "border-bottom-color"], variable: "--tw-border-opacity" }) : { "border-top-color": N(n), "border-bottom-color": N(n) } }, { values: (({ DEFAULT: n, ...i }) => i)(H(e("borderColor"))), type: ["color", "any"] }), t({ "border-t": (n) => r("borderOpacity") ? ee({ color: n, property: "border-top-color", variable: "--tw-border-opacity" }) : { "border-top-color": N(n) }, "border-r": (n) => r("borderOpacity") ? ee({ color: n, property: "border-right-color", variable: "--tw-border-opacity" }) : { "border-right-color": N(n) }, "border-b": (n) => r("borderOpacity") ? ee({ color: n, property: "border-bottom-color", variable: "--tw-border-opacity" }) : { "border-bottom-color": N(n) }, "border-l": (n) => r("borderOpacity") ? ee({ color: n, property: "border-left-color", variable: "--tw-border-opacity" }) : { "border-left-color": N(n) } }, { values: (({ DEFAULT: n, ...i }) => i)(H(e("borderColor"))), type: ["color", "any"] });
}, borderOpacity: T("borderOpacity", [["border-opacity", ["--tw-border-opacity"]]]), backgroundColor: ({ matchUtilities: t, theme: e, corePlugins: r }) => {
  t({ bg: (n) => r("backgroundOpacity") ? ee({ color: n, property: "background-color", variable: "--tw-bg-opacity" }) : { "background-color": N(n) } }, { values: H(e("backgroundColor")), type: ["color", "any"] });
}, backgroundOpacity: T("backgroundOpacity", [["bg-opacity", ["--tw-bg-opacity"]]]), backgroundImage: T("backgroundImage", [["bg", ["background-image"]]], { type: ["lookup", "image", "url"] }), gradientColorStops: (() => {
  function t(e) {
    return ve(e, 0, "rgb(255 255 255 / 0)");
  }
  return function({ matchUtilities: e, theme: r }) {
    let n = { values: H(r("gradientColorStops")), type: ["color", "any"] };
    e({ from: (i) => {
      let s = t(i);
      return { "--tw-gradient-from": N(i, "from"), "--tw-gradient-to": s, "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)" };
    } }, n), e({ via: (i) => ({ "--tw-gradient-to": t(i), "--tw-gradient-stops": `var(--tw-gradient-from), ${N(i, "via")}, var(--tw-gradient-to)` }) }, n), e({ to: (i) => ({ "--tw-gradient-to": N(i, "to") }) }, n);
  };
})(), boxDecorationBreak: ({ addUtilities: t }) => {
  t({ ".decoration-slice": { "box-decoration-break": "slice" }, ".decoration-clone": { "box-decoration-break": "clone" }, ".box-decoration-slice": { "box-decoration-break": "slice" }, ".box-decoration-clone": { "box-decoration-break": "clone" } });
}, backgroundSize: T("backgroundSize", [["bg", ["background-size"]]], { type: ["lookup", "length", "percentage", "size"] }), backgroundAttachment: ({ addUtilities: t }) => {
  t({ ".bg-fixed": { "background-attachment": "fixed" }, ".bg-local": { "background-attachment": "local" }, ".bg-scroll": { "background-attachment": "scroll" } });
}, backgroundClip: ({ addUtilities: t }) => {
  t({ ".bg-clip-border": { "background-clip": "border-box" }, ".bg-clip-padding": { "background-clip": "padding-box" }, ".bg-clip-content": { "background-clip": "content-box" }, ".bg-clip-text": { "background-clip": "text" } });
}, backgroundPosition: T("backgroundPosition", [["bg", ["background-position"]]], { type: ["lookup", ["position", { preferOnConflict: true }]] }), backgroundRepeat: ({ addUtilities: t }) => {
  t({ ".bg-repeat": { "background-repeat": "repeat" }, ".bg-no-repeat": { "background-repeat": "no-repeat" }, ".bg-repeat-x": { "background-repeat": "repeat-x" }, ".bg-repeat-y": { "background-repeat": "repeat-y" }, ".bg-repeat-round": { "background-repeat": "round" }, ".bg-repeat-space": { "background-repeat": "space" } });
}, backgroundOrigin: ({ addUtilities: t }) => {
  t({ ".bg-origin-border": { "background-origin": "border-box" }, ".bg-origin-padding": { "background-origin": "padding-box" }, ".bg-origin-content": { "background-origin": "content-box" } });
}, fill: ({ matchUtilities: t, theme: e }) => {
  t({ fill: (r) => ({ fill: N(r) }) }, { values: H(e("fill")), type: ["color", "any"] });
}, stroke: ({ matchUtilities: t, theme: e }) => {
  t({ stroke: (r) => ({ stroke: N(r) }) }, { values: H(e("stroke")), type: ["color", "url", "any"] });
}, strokeWidth: T("strokeWidth", [["stroke", ["stroke-width"]]], { type: ["length", "number", "percentage"] }), objectFit: ({ addUtilities: t }) => {
  t({ ".object-contain": { "object-fit": "contain" }, ".object-cover": { "object-fit": "cover" }, ".object-fill": { "object-fit": "fill" }, ".object-none": { "object-fit": "none" }, ".object-scale-down": { "object-fit": "scale-down" } });
}, objectPosition: T("objectPosition", [["object", ["object-position"]]]), padding: T("padding", [["p", ["padding"]], [["px", ["padding-left", "padding-right"]], ["py", ["padding-top", "padding-bottom"]]], [["pt", ["padding-top"]], ["pr", ["padding-right"]], ["pb", ["padding-bottom"]], ["pl", ["padding-left"]]]]), textAlign: ({ addUtilities: t }) => {
  t({ ".text-left": { "text-align": "left" }, ".text-center": { "text-align": "center" }, ".text-right": { "text-align": "right" }, ".text-justify": { "text-align": "justify" }, ".text-start": { "text-align": "start" }, ".text-end": { "text-align": "end" } });
}, textIndent: T("textIndent", [["indent", ["text-indent"]]], { supportsNegativeValues: true }), verticalAlign: ({ addUtilities: t, matchUtilities: e }) => {
  t({ ".align-baseline": { "vertical-align": "baseline" }, ".align-top": { "vertical-align": "top" }, ".align-middle": { "vertical-align": "middle" }, ".align-bottom": { "vertical-align": "bottom" }, ".align-text-top": { "vertical-align": "text-top" }, ".align-text-bottom": { "vertical-align": "text-bottom" }, ".align-sub": { "vertical-align": "sub" }, ".align-super": { "vertical-align": "super" } }), e({ align: (r) => ({ "vertical-align": r }) });
}, fontFamily: ({ matchUtilities: t, theme: e }) => {
  t({ font: (r) => {
    let [n, i = {}] = Array.isArray(r) && X(r[1]) ? r : [r], { fontFeatureSettings: s } = i;
    return { "font-family": Array.isArray(n) ? n.join(", ") : n, ...s === void 0 ? {} : { "font-feature-settings": s } };
  } }, { values: e("fontFamily"), type: ["lookup", "generic-name", "family-name"] });
}, fontSize: ({ matchUtilities: t, theme: e }) => {
  t({ text: (r) => {
    let [n, i] = Array.isArray(r) ? r : [r], { lineHeight: s, letterSpacing: a, fontWeight: o2 } = X(i) ? i : { lineHeight: i };
    return { "font-size": n, ...s === void 0 ? {} : { "line-height": s }, ...a === void 0 ? {} : { "letter-spacing": a }, ...o2 === void 0 ? {} : { "font-weight": o2 } };
  } }, { values: e("fontSize"), type: ["absolute-size", "relative-size", "length", "percentage"] });
}, fontWeight: T("fontWeight", [["font", ["fontWeight"]]], { type: ["lookup", "number", "any"] }), textTransform: ({ addUtilities: t }) => {
  t({ ".uppercase": { "text-transform": "uppercase" }, ".lowercase": { "text-transform": "lowercase" }, ".capitalize": { "text-transform": "capitalize" }, ".normal-case": { "text-transform": "none" } });
}, fontStyle: ({ addUtilities: t }) => {
  t({ ".italic": { "font-style": "italic" }, ".not-italic": { "font-style": "normal" } });
}, fontVariantNumeric: ({ addDefaults: t, addUtilities: e }) => {
  let r = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
  t("font-variant-numeric", { "--tw-ordinal": " ", "--tw-slashed-zero": " ", "--tw-numeric-figure": " ", "--tw-numeric-spacing": " ", "--tw-numeric-fraction": " " }), e({ ".normal-nums": { "font-variant-numeric": "normal" }, ".ordinal": { "@defaults font-variant-numeric": {}, "--tw-ordinal": "ordinal", "font-variant-numeric": r }, ".slashed-zero": { "@defaults font-variant-numeric": {}, "--tw-slashed-zero": "slashed-zero", "font-variant-numeric": r }, ".lining-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "lining-nums", "font-variant-numeric": r }, ".oldstyle-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "oldstyle-nums", "font-variant-numeric": r }, ".proportional-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "proportional-nums", "font-variant-numeric": r }, ".tabular-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "tabular-nums", "font-variant-numeric": r }, ".diagonal-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "diagonal-fractions", "font-variant-numeric": r }, ".stacked-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "stacked-fractions", "font-variant-numeric": r } });
}, lineHeight: T("lineHeight", [["leading", ["lineHeight"]]]), letterSpacing: T("letterSpacing", [["tracking", ["letterSpacing"]]], { supportsNegativeValues: true }), textColor: ({ matchUtilities: t, theme: e, corePlugins: r }) => {
  t({ text: (n) => r("textOpacity") ? ee({ color: n, property: "color", variable: "--tw-text-opacity" }) : { color: N(n) } }, { values: H(e("textColor")), type: ["color", "any"] });
}, textOpacity: T("textOpacity", [["text-opacity", ["--tw-text-opacity"]]]), textDecoration: ({ addUtilities: t }) => {
  t({ ".underline": { "text-decoration-line": "underline" }, ".overline": { "text-decoration-line": "overline" }, ".line-through": { "text-decoration-line": "line-through" }, ".no-underline": { "text-decoration-line": "none" } });
}, textDecorationColor: ({ matchUtilities: t, theme: e }) => {
  t({ decoration: (r) => ({ "text-decoration-color": N(r) }) }, { values: H(e("textDecorationColor")), type: ["color", "any"] });
}, textDecorationStyle: ({ addUtilities: t }) => {
  t({ ".decoration-solid": { "text-decoration-style": "solid" }, ".decoration-double": { "text-decoration-style": "double" }, ".decoration-dotted": { "text-decoration-style": "dotted" }, ".decoration-dashed": { "text-decoration-style": "dashed" }, ".decoration-wavy": { "text-decoration-style": "wavy" } });
}, textDecorationThickness: T("textDecorationThickness", [["decoration", ["text-decoration-thickness"]]], { type: ["length", "percentage"] }), textUnderlineOffset: T("textUnderlineOffset", [["underline-offset", ["text-underline-offset"]]], { type: ["length", "percentage", "any"] }), fontSmoothing: ({ addUtilities: t }) => {
  t({ ".antialiased": { "-webkit-font-smoothing": "antialiased", "-moz-osx-font-smoothing": "grayscale" }, ".subpixel-antialiased": { "-webkit-font-smoothing": "auto", "-moz-osx-font-smoothing": "auto" } });
}, placeholderColor: ({ matchUtilities: t, theme: e, corePlugins: r }) => {
  t({ placeholder: (n) => r("placeholderOpacity") ? { "&::placeholder": ee({ color: n, property: "color", variable: "--tw-placeholder-opacity" }) } : { "&::placeholder": { color: N(n) } } }, { values: H(e("placeholderColor")), type: ["color", "any"] });
}, placeholderOpacity: ({ matchUtilities: t, theme: e }) => {
  t({ "placeholder-opacity": (r) => ({ ["&::placeholder"]: { "--tw-placeholder-opacity": r } }) }, { values: e("placeholderOpacity") });
}, caretColor: ({ matchUtilities: t, theme: e }) => {
  t({ caret: (r) => ({ "caret-color": N(r) }) }, { values: H(e("caretColor")), type: ["color", "any"] });
}, accentColor: ({ matchUtilities: t, theme: e }) => {
  t({ accent: (r) => ({ "accent-color": N(r) }) }, { values: H(e("accentColor")), type: ["color", "any"] });
}, opacity: T("opacity", [["opacity", ["opacity"]]]), backgroundBlendMode: ({ addUtilities: t }) => {
  t({ ".bg-blend-normal": { "background-blend-mode": "normal" }, ".bg-blend-multiply": { "background-blend-mode": "multiply" }, ".bg-blend-screen": { "background-blend-mode": "screen" }, ".bg-blend-overlay": { "background-blend-mode": "overlay" }, ".bg-blend-darken": { "background-blend-mode": "darken" }, ".bg-blend-lighten": { "background-blend-mode": "lighten" }, ".bg-blend-color-dodge": { "background-blend-mode": "color-dodge" }, ".bg-blend-color-burn": { "background-blend-mode": "color-burn" }, ".bg-blend-hard-light": { "background-blend-mode": "hard-light" }, ".bg-blend-soft-light": { "background-blend-mode": "soft-light" }, ".bg-blend-difference": { "background-blend-mode": "difference" }, ".bg-blend-exclusion": { "background-blend-mode": "exclusion" }, ".bg-blend-hue": { "background-blend-mode": "hue" }, ".bg-blend-saturation": { "background-blend-mode": "saturation" }, ".bg-blend-color": { "background-blend-mode": "color" }, ".bg-blend-luminosity": { "background-blend-mode": "luminosity" } });
}, mixBlendMode: ({ addUtilities: t }) => {
  t({ ".mix-blend-normal": { "mix-blend-mode": "normal" }, ".mix-blend-multiply": { "mix-blend-mode": "multiply" }, ".mix-blend-screen": { "mix-blend-mode": "screen" }, ".mix-blend-overlay": { "mix-blend-mode": "overlay" }, ".mix-blend-darken": { "mix-blend-mode": "darken" }, ".mix-blend-lighten": { "mix-blend-mode": "lighten" }, ".mix-blend-color-dodge": { "mix-blend-mode": "color-dodge" }, ".mix-blend-color-burn": { "mix-blend-mode": "color-burn" }, ".mix-blend-hard-light": { "mix-blend-mode": "hard-light" }, ".mix-blend-soft-light": { "mix-blend-mode": "soft-light" }, ".mix-blend-difference": { "mix-blend-mode": "difference" }, ".mix-blend-exclusion": { "mix-blend-mode": "exclusion" }, ".mix-blend-hue": { "mix-blend-mode": "hue" }, ".mix-blend-saturation": { "mix-blend-mode": "saturation" }, ".mix-blend-color": { "mix-blend-mode": "color" }, ".mix-blend-luminosity": { "mix-blend-mode": "luminosity" }, ".mix-blend-plus-lighter": { "mix-blend-mode": "plus-lighter" } });
}, boxShadow: (() => {
  let t = Oe("boxShadow"), e = ["var(--tw-ring-offset-shadow, 0 0 #0000)", "var(--tw-ring-shadow, 0 0 #0000)", "var(--tw-shadow)"].join(", ");
  return function({ matchUtilities: r, addDefaults: n, theme: i }) {
    n(" box-shadow", { "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), r({ shadow: (s) => {
      s = t(s);
      let a = rn(s);
      for (let o2 of a)
        !o2.valid || (o2.color = "var(--tw-shadow-color)");
      return { "@defaults box-shadow": {}, "--tw-shadow": s === "none" ? "0 0 #0000" : s, "--tw-shadow-colored": s === "none" ? "0 0 #0000" : ju(a), "box-shadow": e };
    } }, { values: i("boxShadow"), type: ["shadow"] });
  };
})(), boxShadowColor: ({ matchUtilities: t, theme: e }) => {
  t({ shadow: (r) => ({ "--tw-shadow-color": N(r), "--tw-shadow": "var(--tw-shadow-colored)" }) }, { values: H(e("boxShadowColor")), type: ["color", "any"] });
}, outlineStyle: ({ addUtilities: t }) => {
  t({ ".outline-none": { outline: "2px solid transparent", "outline-offset": "2px" }, ".outline": { "outline-style": "solid" }, ".outline-dashed": { "outline-style": "dashed" }, ".outline-dotted": { "outline-style": "dotted" }, ".outline-double": { "outline-style": "double" } });
}, outlineWidth: T("outlineWidth", [["outline", ["outline-width"]]], { type: ["length", "number", "percentage"] }), outlineOffset: T("outlineOffset", [["outline-offset", ["outline-offset"]]], { type: ["length", "number", "percentage", "any"], supportsNegativeValues: true }), outlineColor: ({ matchUtilities: t, theme: e }) => {
  t({ outline: (r) => ({ "outline-color": N(r) }) }, { values: H(e("outlineColor")), type: ["color", "any"] });
}, ringWidth: ({ matchUtilities: t, addDefaults: e, addUtilities: r, theme: n, config: i }) => {
  let s = (() => {
    var o2, l;
    if (G(i(), "respectDefaultRingColorOpacity"))
      return n("ringColor.DEFAULT");
    let a = n("ringOpacity.DEFAULT", "0.5");
    return (o2 = n("ringColor")) != null && o2.DEFAULT ? ve((l = n("ringColor")) == null ? void 0 : l.DEFAULT, a, `rgb(147 197 253 / ${a})`) : `rgb(147 197 253 / ${a})`;
  })();
  e("ring-width", { "--tw-ring-inset": " ", "--tw-ring-offset-width": n("ringOffsetWidth.DEFAULT", "0px"), "--tw-ring-offset-color": n("ringOffsetColor.DEFAULT", "#fff"), "--tw-ring-color": s, "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), t({ ring: (a) => ({ "@defaults ring-width": {}, "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)", "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${a} + var(--tw-ring-offset-width)) var(--tw-ring-color)`, "box-shadow": ["var(--tw-ring-offset-shadow)", "var(--tw-ring-shadow)", "var(--tw-shadow, 0 0 #0000)"].join(", ") }) }, { values: n("ringWidth"), type: "length" }), r({ ".ring-inset": { "@defaults ring-width": {}, "--tw-ring-inset": "inset" } });
}, ringColor: ({ matchUtilities: t, theme: e, corePlugins: r }) => {
  t({ ring: (n) => r("ringOpacity") ? ee({ color: n, property: "--tw-ring-color", variable: "--tw-ring-opacity" }) : { "--tw-ring-color": N(n) } }, { values: Object.fromEntries(Object.entries(H(e("ringColor"))).filter(([n]) => n !== "DEFAULT")), type: ["color", "any"] });
}, ringOpacity: (t) => {
  let { config: e } = t;
  return T("ringOpacity", [["ring-opacity", ["--tw-ring-opacity"]]], { filterDefault: !G(e(), "respectDefaultRingColorOpacity") })(t);
}, ringOffsetWidth: T("ringOffsetWidth", [["ring-offset", ["--tw-ring-offset-width"]]], { type: "length" }), ringOffsetColor: ({ matchUtilities: t, theme: e }) => {
  t({ "ring-offset": (r) => ({ "--tw-ring-offset-color": N(r) }) }, { values: H(e("ringOffsetColor")), type: ["color", "any"] });
}, blur: ({ matchUtilities: t, theme: e }) => {
  t({ blur: (r) => ({ "--tw-blur": `blur(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("blur") });
}, brightness: ({ matchUtilities: t, theme: e }) => {
  t({ brightness: (r) => ({ "--tw-brightness": `brightness(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("brightness") });
}, contrast: ({ matchUtilities: t, theme: e }) => {
  t({ contrast: (r) => ({ "--tw-contrast": `contrast(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("contrast") });
}, dropShadow: ({ matchUtilities: t, theme: e }) => {
  t({ "drop-shadow": (r) => ({ "--tw-drop-shadow": Array.isArray(r) ? r.map((n) => `drop-shadow(${n})`).join(" ") : `drop-shadow(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("dropShadow") });
}, grayscale: ({ matchUtilities: t, theme: e }) => {
  t({ grayscale: (r) => ({ "--tw-grayscale": `grayscale(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("grayscale") });
}, hueRotate: ({ matchUtilities: t, theme: e }) => {
  t({ "hue-rotate": (r) => ({ "--tw-hue-rotate": `hue-rotate(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("hueRotate"), supportsNegativeValues: true });
}, invert: ({ matchUtilities: t, theme: e }) => {
  t({ invert: (r) => ({ "--tw-invert": `invert(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("invert") });
}, saturate: ({ matchUtilities: t, theme: e }) => {
  t({ saturate: (r) => ({ "--tw-saturate": `saturate(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("saturate") });
}, sepia: ({ matchUtilities: t, theme: e }) => {
  t({ sepia: (r) => ({ "--tw-sepia": `sepia(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("sepia") });
}, filter: ({ addDefaults: t, addUtilities: e }) => {
  t("filter", { "--tw-blur": " ", "--tw-brightness": " ", "--tw-contrast": " ", "--tw-grayscale": " ", "--tw-hue-rotate": " ", "--tw-invert": " ", "--tw-saturate": " ", "--tw-sepia": " ", "--tw-drop-shadow": " " }), e({ ".filter": { "@defaults filter": {}, filter: xe }, ".filter-none": { filter: "none" } });
}, backdropBlur: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-blur": (r) => ({ "--tw-backdrop-blur": `blur(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropBlur") });
}, backdropBrightness: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-brightness": (r) => ({ "--tw-backdrop-brightness": `brightness(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropBrightness") });
}, backdropContrast: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-contrast": (r) => ({ "--tw-backdrop-contrast": `contrast(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropContrast") });
}, backdropGrayscale: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-grayscale": (r) => ({ "--tw-backdrop-grayscale": `grayscale(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropGrayscale") });
}, backdropHueRotate: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-hue-rotate": (r) => ({ "--tw-backdrop-hue-rotate": `hue-rotate(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropHueRotate"), supportsNegativeValues: true });
}, backdropInvert: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-invert": (r) => ({ "--tw-backdrop-invert": `invert(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropInvert") });
}, backdropOpacity: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-opacity": (r) => ({ "--tw-backdrop-opacity": `opacity(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropOpacity") });
}, backdropSaturate: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-saturate": (r) => ({ "--tw-backdrop-saturate": `saturate(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropSaturate") });
}, backdropSepia: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-sepia": (r) => ({ "--tw-backdrop-sepia": `sepia(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropSepia") });
}, backdropFilter: ({ addDefaults: t, addUtilities: e }) => {
  t("backdrop-filter", { "--tw-backdrop-blur": " ", "--tw-backdrop-brightness": " ", "--tw-backdrop-contrast": " ", "--tw-backdrop-grayscale": " ", "--tw-backdrop-hue-rotate": " ", "--tw-backdrop-invert": " ", "--tw-backdrop-opacity": " ", "--tw-backdrop-saturate": " ", "--tw-backdrop-sepia": " " }), e({ ".backdrop-filter": { "@defaults backdrop-filter": {}, "backdrop-filter": Se }, ".backdrop-filter-none": { "backdrop-filter": "none" } });
}, transitionProperty: ({ matchUtilities: t, theme: e }) => {
  let r = e("transitionTimingFunction.DEFAULT"), n = e("transitionDuration.DEFAULT");
  t({ transition: (i) => ({ "transition-property": i, ...i === "none" ? {} : { "transition-timing-function": r, "transition-duration": n } }) }, { values: e("transitionProperty") });
}, transitionDelay: T("transitionDelay", [["delay", ["transitionDelay"]]]), transitionDuration: T("transitionDuration", [["duration", ["transitionDuration"]]], { filterDefault: true }), transitionTimingFunction: T("transitionTimingFunction", [["ease", ["transitionTimingFunction"]]], { filterDefault: true }), willChange: T("willChange", [["will-change", ["will-change"]]]), content: T("content", [["content", ["--tw-content", ["content", "var(--tw-content)"]]]]) };
function Ne(t) {
  if (Array.isArray(t))
    return t;
  let e = t.split("[").length - 1, r = t.split("]").length - 1;
  if (e !== r)
    throw new Error(`Path is invalid. Has unbalanced brackets: ${t}`);
  return t.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
}
var yf = /* @__PURE__ */ new Map([["{", "}"], ["[", "]"], ["(", ")"]]);
var gf = new Map(Array.from(yf.entries()).map(([t, e]) => [e, t]));
var sv = /* @__PURE__ */ new Set(['"', "'", "`"]);
function lt(t) {
  let e = [], r = false;
  for (let n = 0; n < t.length; n++) {
    let i = t[n];
    if (i === ":" && !r && e.length === 0)
      return false;
    if (sv.has(i) && t[n - 1] !== "\\" && (r = !r), !r && t[n - 1] !== "\\") {
      if (yf.has(i))
        e.push(i);
      else if (gf.has(i)) {
        let s = gf.get(i);
        if (e.length <= 0 || e.pop() !== s)
          return false;
      }
    }
  }
  return !(e.length > 0);
}
function cn(t) {
  return (t > 0n) - (t < 0n);
}
function wf(t, e) {
  let r = 0n, n = 0n;
  for (let [i, s] of e)
    t & i && (r = r | i, n = n | s);
  return t & ~r | n;
}
var pn = class {
  constructor() {
    this.offsets = { defaults: 0n, base: 0n, components: 0n, utilities: 0n, variants: 0n, user: 0n }, this.layerPositions = { defaults: 0n, base: 1n, components: 2n, utilities: 3n, user: 4n, variants: 5n }, this.reservedVariantBits = 0n, this.variantOffsets = /* @__PURE__ */ new Map();
  }
  create(e) {
    return { layer: e, parentLayer: e, arbitrary: 0n, variants: 0n, parallelIndex: 0n, index: this.offsets[e]++, options: [] };
  }
  arbitraryProperty() {
    return { ...this.create("utilities"), arbitrary: 1n };
  }
  forVariant(e, r = 0) {
    let n = this.variantOffsets.get(e);
    if (n === void 0)
      throw new Error(`Cannot find offset for unknown variant ${e}`);
    return { ...this.create("variants"), variants: n << BigInt(r) };
  }
  applyVariantOffset(e, r, n) {
    return n.variant = r.variants, { ...e, layer: "variants", parentLayer: e.layer === "variants" ? e.parentLayer : e.layer, variants: e.variants | r.variants, options: n.sort ? [].concat(n, e.options) : e.options, parallelIndex: vf([e.parallelIndex, r.parallelIndex]) };
  }
  applyParallelOffset(e, r) {
    return { ...e, parallelIndex: BigInt(r) };
  }
  recordVariants(e, r) {
    for (let n of e)
      this.recordVariant(n, r(n));
  }
  recordVariant(e, r = 1) {
    return this.variantOffsets.set(e, 1n << this.reservedVariantBits), this.reservedVariantBits += BigInt(r), { ...this.create("variants"), variants: this.variantOffsets.get(e) };
  }
  compare(e, r) {
    var n;
    if (e.layer !== r.layer)
      return this.layerPositions[e.layer] - this.layerPositions[r.layer];
    if (e.parentLayer !== r.parentLayer)
      return this.layerPositions[e.parentLayer] - this.layerPositions[r.parentLayer];
    for (let i of e.options)
      for (let s of r.options) {
        if (i.id !== s.id || !i.sort || !s.sort)
          continue;
        let a = (n = vf([i.variant, s.variant])) != null ? n : 0n, o2 = ~(a | a - 1n), l = e.variants & o2, u = r.variants & o2;
        if (l !== u)
          continue;
        let f = i.sort({ value: i.value, modifier: i.modifier }, { value: s.value, modifier: s.modifier });
        if (f !== 0)
          return f;
      }
    return e.variants !== r.variants ? e.variants - r.variants : e.parallelIndex !== r.parallelIndex ? e.parallelIndex - r.parallelIndex : e.arbitrary !== r.arbitrary ? e.arbitrary - r.arbitrary : e.index - r.index;
  }
  recalculateVariantOffsets() {
    let e = Array.from(this.variantOffsets.entries()).filter(([i]) => i.startsWith("[")).sort(([i], [s]) => av(i, s)), r = e.map(([, i]) => i).sort((i, s) => cn(i - s));
    return e.map(([, i], s) => [i, r[s]]).filter(([i, s]) => i !== s);
  }
  remapArbitraryVariantOffsets(e) {
    let r = this.recalculateVariantOffsets();
    return r.length === 0 ? e : e.map((n) => {
      let [i, s] = n;
      return i = { ...i, variants: wf(i.variants, r) }, [i, s];
    });
  }
  sort(e) {
    return e = this.remapArbitraryVariantOffsets(e), e.sort(([r], [n]) => cn(this.compare(r, n)));
  }
};
function vf(t) {
  let e = null;
  for (let r of t)
    e = e != null ? e : r, e = e > r ? e : r;
  return e;
}
function av(t, e) {
  let r = t.length, n = e.length, i = r < n ? r : n;
  for (let s = 0; s < i; s++) {
    let a = t.charCodeAt(s) - e.charCodeAt(s);
    if (a !== 0)
      return a;
  }
  return r - n;
}
var Fs = { AddVariant: Symbol.for("ADD_VARIANT"), MatchVariant: Symbol.for("MATCH_VARIANT") };
var qs = { Base: 1 << 0, Dynamic: 1 << 1 };
function Ns(t, e) {
  let r = t.tailwindConfig.prefix;
  return typeof r == "function" ? r(e) : r + e;
}
function bf({ type: t = "any", ...e }) {
  let r = [].concat(t);
  return { ...e, types: r.map((n) => Array.isArray(n) ? { type: n[0], ...n[1] } : { type: n, preferOnConflict: false }) };
}
function ov(t) {
  let e = [], r = "", n = 0;
  for (let i = 0; i < t.length; i++) {
    let s = t[i];
    if (s === "\\")
      r += "\\" + t[++i];
    else if (s === "{")
      ++n, e.push(r.trim()), r = "";
    else if (s === "}") {
      if (--n < 0)
        throw new Error("Your { and } are unbalanced.");
      e.push(r.trim()), r = "";
    } else
      r += s;
  }
  return r.length > 0 && e.push(r.trim()), e = e.filter((i) => i !== ""), e;
}
function lv(t, e, { before: r = [] } = {}) {
  if (r = [].concat(r), r.length <= 0) {
    t.push(e);
    return;
  }
  let n = t.length - 1;
  for (let i of r) {
    let s = t.indexOf(i);
    s !== -1 && (n = Math.min(n, s));
  }
  t.splice(n, 0, e);
}
function kf(t) {
  return Array.isArray(t) ? t.flatMap((e) => !Array.isArray(e) && !X(e) ? e : it(e)) : kf([t]);
}
function xf(t, e) {
  return (0, $s.default)((n) => {
    let i = [];
    return e && e(n), n.walkClasses((s) => {
      i.push(s.value);
    }), i;
  }).transformSync(t);
}
function uv(t, e = { containsNonOnDemandable: false }, r = 0) {
  let n = [];
  if (t.type === "rule") {
    let i = function(s) {
      s.walkPseudos((a) => {
        a.value === ":not" && a.remove();
      });
    };
    for (let s of t.selectors) {
      let a = xf(s, i);
      a.length === 0 && (e.containsNonOnDemandable = true);
      for (let o2 of a)
        n.push(o2);
    }
  } else
    t.type === "atrule" && t.walkRules((i) => {
      for (let s of i.selectors.flatMap((a) => xf(a)))
        n.push(s);
    });
  return r === 0 ? [e.containsNonOnDemandable || n.length === 0, n] : n;
}
function dn(t) {
  return kf(t).flatMap((e) => {
    let r = /* @__PURE__ */ new Map(), [n, i] = uv(e);
    return n && i.unshift(ke), i.map((s) => (r.has(e) || r.set(e, e), [s, r.get(e)]));
  });
}
function hn(t) {
  return t.startsWith("@") || t.includes("&");
}
function lr(t) {
  t = t.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
  let e = ov(t).map((r) => {
    if (!r.startsWith("@"))
      return ({ format: s }) => s(r);
    let [, n, i] = /@(.*?)( .+|[({].*)/g.exec(r);
    return ({ wrap: s }) => s(I2.atRule({ name: n, params: i.trim() }));
  }).reverse();
  return (r) => {
    for (let n of e)
      n(r);
  };
}
function fv(t, e, { variantList: r, variantMap: n, offsets: i, classList: s }) {
  function a(c, d) {
    return c ? (0, Sf.default)(t, c, d) : t;
  }
  function o2(c) {
    return st(t.prefix, c);
  }
  function l(c, d) {
    return c === ke ? ke : d.respectPrefix ? e.tailwindConfig.prefix + c : c;
  }
  function u(c, d, h = {}) {
    let y = Ne(c), m = a(["theme", ...y], d);
    return Oe(y[0])(m, h);
  }
  let f = 0, p = { postcss: I2, prefix: o2, e: re, config: a, theme: u, corePlugins: (c) => Array.isArray(t.corePlugins) ? t.corePlugins.includes(c) : a(["corePlugins", c], true), variants: () => [], addBase(c) {
    for (let [d, h] of dn(c)) {
      let y = l(d, {}), m = i.create("base");
      e.candidateRuleMap.has(y) || e.candidateRuleMap.set(y, []), e.candidateRuleMap.get(y).push([{ sort: m, layer: "base" }, h]);
    }
  }, addDefaults(c, d) {
    let h = { [`@defaults ${c}`]: d };
    for (let [y, m] of dn(h)) {
      let g = l(y, {});
      e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push([{ sort: i.create("defaults"), layer: "defaults" }, m]);
    }
  }, addComponents(c, d) {
    d = Object.assign({}, { preserveSource: false, respectPrefix: true, respectImportant: false }, Array.isArray(d) ? {} : d);
    for (let [y, m] of dn(c)) {
      let g = l(y, d);
      s.add(g), e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push([{ sort: i.create("components"), layer: "components", options: d }, m]);
    }
  }, addUtilities(c, d) {
    d = Object.assign({}, { preserveSource: false, respectPrefix: true, respectImportant: true }, Array.isArray(d) ? {} : d);
    for (let [y, m] of dn(c)) {
      let g = l(y, d);
      s.add(g), e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push([{ sort: i.create("utilities"), layer: "utilities", options: d }, m]);
    }
  }, matchUtilities: function(c, d) {
    d = bf({ ...{ respectPrefix: true, respectImportant: true, modifiers: false }, ...d });
    let y = i.create("utilities");
    for (let m in c) {
      let b = function(C, { isOnlyPlugin: x }) {
        let [O, E, R] = As(d.types, C, d, t);
        if (O === void 0)
          return [];
        if (!d.types.some(({ type: K }) => K === E))
          if (x)
            D.warn([`Unnecessary typehint \`${E}\` in \`${m}-${C}\`.`, `You can safely update it to \`${m}-${C.replace(E + ":", "")}\`.`]);
          else
            return [];
        if (!lt(O))
          return [];
        let L = { get modifier() {
          return d.modifiers || D.warn(`modifier-used-without-options-for-${m}`, ["Your plugin must set `modifiers: true` in its options to support modifiers."]), R;
        } }, B = G(t, "generalizedModifiers");
        return [].concat(B ? w(O, L) : w(O)).filter(Boolean).map((K) => ({ [on(m, C)]: K }));
      }, g = l(m, d), w = c[m];
      s.add([g, d]);
      let v = [{ sort: y, layer: "utilities", options: d }, b];
      e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push(v);
    }
  }, matchComponents: function(c, d) {
    d = bf({ ...{ respectPrefix: true, respectImportant: false, modifiers: false }, ...d });
    let y = i.create("components");
    for (let m in c) {
      let b = function(C, { isOnlyPlugin: x }) {
        let [O, E, R] = As(d.types, C, d, t);
        if (O === void 0)
          return [];
        if (!d.types.some(({ type: K }) => K === E))
          if (x)
            D.warn([`Unnecessary typehint \`${E}\` in \`${m}-${C}\`.`, `You can safely update it to \`${m}-${C.replace(E + ":", "")}\`.`]);
          else
            return [];
        if (!lt(O))
          return [];
        let L = { get modifier() {
          return d.modifiers || D.warn(`modifier-used-without-options-for-${m}`, ["Your plugin must set `modifiers: true` in its options to support modifiers."]), R;
        } }, B = G(t, "generalizedModifiers");
        return [].concat(B ? w(O, L) : w(O)).filter(Boolean).map((K) => ({ [on(m, C)]: K }));
      }, g = l(m, d), w = c[m];
      s.add([g, d]);
      let v = [{ sort: y, layer: "components", options: d }, b];
      e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push(v);
    }
  }, addVariant(c, d, h = {}) {
    d = [].concat(d).map((y) => {
      if (typeof y != "string")
        return (m = {}) => {
          let { args: g, modifySelectors: w, container: b, separator: v, wrap: C, format: x } = m, O = y(Object.assign({ modifySelectors: w, container: b, separator: v }, h.type === Fs.MatchVariant && { args: g, wrap: C, format: x }));
          if (typeof O == "string" && !hn(O))
            throw new Error(`Your custom variant \`${c}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
          return Array.isArray(O) ? O.filter((E) => typeof E == "string").map((E) => lr(E)) : O && typeof O == "string" && lr(O)(m);
        };
      if (!hn(y))
        throw new Error(`Your custom variant \`${c}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
      return lr(y);
    }), lv(r, c, h), n.set(c, d), e.variantOptions.set(c, h);
  }, matchVariant(c, d, h) {
    var b, v, C;
    let y = (b = h == null ? void 0 : h.id) != null ? b : ++f, m = c === "@", g = G(t, "generalizedModifiers");
    for (let [x, O] of Object.entries((v = h == null ? void 0 : h.values) != null ? v : {}))
      x !== "DEFAULT" && p.addVariant(m ? `${c}${x}` : `${c}-${x}`, ({ args: E, container: R }) => d(O, g ? { modifier: E == null ? void 0 : E.modifier, container: R } : { container: R }), { ...h, value: O, id: y, type: Fs.MatchVariant, variantInfo: qs.Base });
    let w = "DEFAULT" in ((C = h == null ? void 0 : h.values) != null ? C : {});
    p.addVariant(c, ({ args: x, container: O }) => {
      var E;
      return (x == null ? void 0 : x.value) === mt && !w ? null : d((x == null ? void 0 : x.value) === mt ? h.values.DEFAULT : (E = x == null ? void 0 : x.value) != null ? E : typeof x == "string" ? x : "", g ? { modifier: x == null ? void 0 : x.modifier, container: O } : { container: O });
    }, { ...h, id: y, type: Fs.MatchVariant, variantInfo: qs.Dynamic });
  } };
  return p;
}
function Cf(t) {
  t.walkAtRules((e) => {
    ["responsive", "variants"].includes(e.name) && (Cf(e), e.before(e.nodes), e.remove());
  });
}
function cv(t) {
  let e = [];
  return t.each((r) => {
    r.type === "atrule" && ["responsive", "variants"].includes(r.name) && (r.name = "layer", r.params = "utilities");
  }), t.walkAtRules("layer", (r) => {
    if (Cf(r), r.params === "base") {
      for (let n of r.nodes)
        e.push(function({ addBase: i }) {
          i(n, { respectPrefix: false });
        });
      r.remove();
    } else if (r.params === "components") {
      for (let n of r.nodes)
        e.push(function({ addComponents: i }) {
          i(n, { respectPrefix: false, preserveSource: true });
        });
      r.remove();
    } else if (r.params === "utilities") {
      for (let n of r.nodes)
        e.push(function({ addUtilities: i }) {
          i(n, { respectPrefix: false, preserveSource: true });
        });
      r.remove();
    }
  }), e;
}
function pv(t, e) {
  let r = Object.entries({ ...ne, ...mf }).map(([o2, l]) => t.tailwindConfig.corePlugins.includes(o2) ? l : null).filter(Boolean), n = t.tailwindConfig.plugins.map((o2) => (o2.__isOptionsFunction && (o2 = o2()), typeof o2 == "function" ? o2 : o2.handler)), i = cv(e), s = [ne.pseudoElementVariants, ne.pseudoClassVariants, ne.ariaVariants, ne.dataVariants], a = [ne.supportsVariants, ne.directionVariants, ne.reducedMotionVariants, ne.prefersContrastVariants, ne.darkVariants, ne.printVariant, ne.screenVariants, ne.orientationVariants];
  return [...r, ...s, ...n, ...a, ...i];
}
function dv(t, e) {
  var f, p, c;
  let r = [], n = /* @__PURE__ */ new Map();
  e.variantMap = n;
  let i = new pn();
  e.offsets = i;
  let s = /* @__PURE__ */ new Set(), a = fv(e.tailwindConfig, e, { variantList: r, variantMap: n, offsets: i, classList: s });
  for (let d of t)
    if (Array.isArray(d))
      for (let h of d)
        h(a);
    else
      d == null || d(a);
  i.recordVariants(r, (d) => n.get(d).length);
  for (let [d, h] of n.entries())
    e.variantMap.set(d, h.map((y, m) => [i.forVariant(d, m), y]));
  let o2 = ((f = e.tailwindConfig.safelist) != null ? f : []).filter(Boolean);
  if (o2.length > 0) {
    let d = [];
    for (let h of o2) {
      if (typeof h == "string") {
        e.changedContent.push({ content: h, extension: "html" });
        continue;
      }
      if (h instanceof RegExp) {
        D.warn("root-regex", ["Regular expressions in `safelist` work differently in Tailwind CSS v3.0.", "Update your `safelist` configuration to eliminate this warning.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
        continue;
      }
      d.push(h);
    }
    if (d.length > 0) {
      let h = /* @__PURE__ */ new Map(), y = e.tailwindConfig.prefix.length, m = d.some((g) => g.pattern.source.includes("!"));
      for (let g of s) {
        let w = Array.isArray(g) ? (() => {
          var O;
          let [b, v] = g, x = Object.keys((O = v == null ? void 0 : v.values) != null ? O : {}).map((E) => or(b, E));
          return v != null && v.supportsNegativeValues && (x = [...x, ...x.map((E) => "-" + E)], x = [...x, ...x.map((E) => E.slice(0, y) + "-" + E.slice(y))]), v.types.some(({ type: E }) => E === "color") && (x = [...x, ...x.flatMap((E) => Object.keys(e.tailwindConfig.theme.opacity).map((R) => `${E}/${R}`))]), m && (v == null ? void 0 : v.respectImportant) && (x = [...x, ...x.map((E) => "!" + E)]), x;
        })() : [g];
        for (let b of w)
          for (let { pattern: v, variants: C = [] } of d)
            if (v.lastIndex = 0, h.has(v) || h.set(v, 0), !!v.test(b)) {
              h.set(v, h.get(v) + 1), e.changedContent.push({ content: b, extension: "html" });
              for (let x of C)
                e.changedContent.push({ content: x + e.tailwindConfig.separator + b, extension: "html" });
            }
      }
      for (let [g, w] of h.entries())
        w === 0 && D.warn([`The safelist pattern \`${g}\` doesn't match any Tailwind CSS classes.`, "Fix this pattern or remove it from your `safelist` configuration.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
    }
  }
  let l = (c = [].concat((p = e.tailwindConfig.darkMode) != null ? p : "media")[1]) != null ? c : "dark", u = [Ns(e, l), Ns(e, "group"), Ns(e, "peer")];
  e.getClassOrder = function(h) {
    let y = new Map(h.map((w) => [w, null])), m = mn(new Set(h), e);
    m = e.offsets.sort(m);
    let g = BigInt(u.length);
    for (let [, w] of m)
      y.set(w.raws.tailwind.candidate, g++);
    return h.map((w) => {
      var C;
      let b = (C = y.get(w)) != null ? C : null, v = u.indexOf(w);
      return b === null && v !== -1 && (b = BigInt(v)), [w, b];
    });
  }, e.getClassList = function(h = {}) {
    var m, g, w, b;
    let y = [];
    for (let v of s)
      if (Array.isArray(v)) {
        let [C, x] = v, O = [], E = Object.keys((m = x == null ? void 0 : x.modifiers) != null ? m : {});
        (g = x == null ? void 0 : x.types) != null && g.some(({ type: B }) => B === "color") && E.push(...Object.keys((w = e.tailwindConfig.theme.opacity) != null ? w : {}));
        let R = { modifiers: E }, L = h.includeMetadata && E.length > 0;
        for (let [B, Q] of Object.entries((b = x == null ? void 0 : x.values) != null ? b : {})) {
          if (Q == null)
            continue;
          let K = or(C, B);
          if (y.push(L ? [K, R] : K), (x == null ? void 0 : x.supportsNegativeValues) && De(Q)) {
            let $e = or(C, `-${B}`);
            O.push(L ? [$e, R] : $e);
          }
        }
        y.push(...O);
      } else
        y.push(v);
    return y;
  }, e.getVariants = function() {
    var y;
    let h = [];
    for (let [m, g] of e.variantOptions.entries())
      g.variantInfo !== qs.Base && h.push({ name: m, isArbitrary: g.type === Symbol.for("MATCH_VARIANT"), values: Object.keys((y = g.values) != null ? y : {}), hasDash: m !== "@", selectors({ modifier: w, value: b } = {}) {
        var Sa, ka, Ca, Ea;
        let v = "__TAILWIND_PLACEHOLDER__", C = I2.rule({ selector: `.${v}` }), x = I2.root({ nodes: [C.clone()] }), O = x.toString(), E = ((Sa = e.variantMap.get(m)) != null ? Sa : []).flatMap(([ie, se]) => se), R = [];
        for (let ie of E) {
          let se = [], hr = { args: { modifier: w, value: (Ca = (ka = g.values) == null ? void 0 : ka[b]) != null ? Ca : b }, separator: e.tailwindConfig.separator, modifySelectors(pe) {
            return x.each((Ln) => {
              Ln.type === "rule" && (Ln.selectors = Ln.selectors.map((Aa) => pe({ get className() {
                return Us(Aa);
              }, selector: Aa })));
            }), x;
          }, format(pe) {
            se.push(pe);
          }, wrap(pe) {
            se.push(`@${pe.name} ${pe.params} { & }`);
          }, container: x }, mr = ie(hr);
          if (se.length > 0 && R.push(se), Array.isArray(mr))
            for (let pe of mr)
              se = [], pe(hr), R.push(se);
        }
        let L = [], B = x.toString();
        O !== B && (x.walkRules((ie) => {
          let se = ie.selector, hr = (0, $s.default)((mr) => {
            mr.walkClasses((pe) => {
              pe.value = `${m}${e.tailwindConfig.separator}${pe.value}`;
            });
          }).processSync(se);
          L.push(se.replace(hr, "&").replace(v, "&"));
        }), x.walkAtRules((ie) => {
          L.push(`@${ie.name} (${ie.params}) { & }`);
        }));
        let Q = !(b in ((Ea = g.values) != null ? Ea : {}));
        R = R.map((ie) => ie.map((se) => ({ format: se, isArbitraryVariant: Q }))), L = L.map((ie) => ({ format: ie, isArbitraryVariant: Q }));
        let K = { candidate: v, context: e }, $e = R.map((ie) => an(`.${v}`, ot(ie, K), K).replace(`.${v}`, "&").replace("{ & }", "").trim());
        return L.length > 0 && $e.push(ot(L, K).toString().replace(`.${v}`, "&")), $e;
      } });
    return h;
  };
}
function Ef(t, e) {
  !t.classCache.has(e) || (t.notClassCache.add(e), t.classCache.delete(e), t.applyClassCache.delete(e), t.candidateRuleMap.delete(e), t.candidateRuleCache.delete(e), t.stylesheetCache = null);
}
function hv(t, e) {
  let r = e.raws.tailwind.candidate;
  if (!!r) {
    for (let n of t.ruleCache)
      n[1].raws.tailwind.candidate === r && t.ruleCache.delete(n);
    Ef(t, r);
  }
}
function Af(t, e = [], r = I2.root()) {
  var s;
  let n = { disposables: [], ruleCache: /* @__PURE__ */ new Set(), candidateRuleCache: /* @__PURE__ */ new Map(), classCache: /* @__PURE__ */ new Map(), applyClassCache: /* @__PURE__ */ new Map(), notClassCache: new Set((s = t.blocklist) != null ? s : []), postCssNodeCache: /* @__PURE__ */ new Map(), candidateRuleMap: /* @__PURE__ */ new Map(), tailwindConfig: t, changedContent: e, variantMap: /* @__PURE__ */ new Map(), stylesheetCache: null, variantOptions: /* @__PURE__ */ new Map(), markInvalidUtilityCandidate: (a) => Ef(n, a), markInvalidUtilityNode: (a) => hv(n, a) }, i = pv(n, r);
  return dv(i, n), n;
}
var mv = (0, yn.default)((t) => t.first.filter(({ type: e }) => e === "class").pop().value);
function Us(t) {
  return mv.transformSync(t);
}
function* gv(t) {
  let e = 1 / 0;
  for (; e >= 0; ) {
    let r, n = false;
    if (e === 1 / 0 && t.endsWith("]")) {
      let a = t.indexOf("[");
      t[a - 1] === "-" ? r = a - 1 : t[a - 1] === "/" ? (r = a - 1, n = true) : r = -1;
    } else
      e === 1 / 0 && t.includes("/") ? (r = t.lastIndexOf("/"), n = true) : r = t.lastIndexOf("-", e);
    if (r < 0)
      break;
    let i = t.slice(0, r), s = t.slice(n ? r : r + 1);
    e = r - 1, !(i === "" || s === "/") && (yield [i, s]);
  }
}
function yv(t, e) {
  if (t.length === 0 || e.tailwindConfig.prefix === "")
    return t;
  for (let r of t) {
    let [n] = r;
    if (n.options.respectPrefix) {
      let i = I2.root({ nodes: [r[1].clone()] }), s = r[1].raws.tailwind.classCandidate;
      i.walkRules((a) => {
        let o2 = s.startsWith("-");
        a.selector = st(e.tailwindConfig.prefix, a.selector, o2);
      }), r[1] = i.nodes[0];
    }
  }
  return t;
}
function wv(t, e) {
  if (t.length === 0)
    return t;
  let r = [];
  for (let [n, i] of t) {
    let s = I2.root({ nodes: [i.clone()] });
    s.walkRules((a) => {
      let o2 = (0, yn.default)().astSync(a.selector);
      o2.each((l) => Ps(l, e)), nf(o2, (l) => l === e ? `!${l}` : l), a.selector = o2.toString(), a.walkDecls((l) => l.important = true);
    }), r.push([{ ...n, important: true }, s.nodes[0]]);
  }
  return r;
}
function vv(t, e, r) {
  var i;
  if (e.length === 0)
    return e;
  let n = { modifier: null, value: mt };
  {
    let [s, ...a] = te(t, "/");
    if (a.length > 1 && (s = s + "/" + a.slice(0, -1).join("/"), a = a.slice(-1)), a.length && !r.variantMap.has(t) && (t = s, n.modifier = a[0], !G(r.tailwindConfig, "generalizedModifiers")))
      return [];
  }
  if (t.endsWith("]") && !t.startsWith("[")) {
    let s = /(.)(-?)\[(.*)\]/g.exec(t);
    if (s) {
      let [, a, o2, l] = s;
      if (a === "@" && o2 === "-")
        return [];
      if (a !== "@" && o2 === "")
        return [];
      t = t.replace(`${o2}[${l}]`, ""), n.value = l;
    }
  }
  if (zs(t) && !r.variantMap.has(t)) {
    let s = z(t.slice(1, -1));
    if (!hn(s))
      return [];
    let a = lr(s), o2 = r.offsets.recordVariant(t);
    r.variantMap.set(t, [[o2, a]]);
  }
  if (r.variantMap.has(t)) {
    let s = zs(t), a = r.variantMap.get(t).slice(), o2 = [];
    for (let [l, u] of e) {
      if (l.layer === "user")
        continue;
      let f = I2.root({ nodes: [u.clone()] });
      for (let [p, c, d] of a) {
        let m = function() {
          h.raws.neededBackup || (h.raws.neededBackup = true, h.walkRules((v) => v.raws.originalSelector = v.selector));
        }, g = function(v) {
          return m(), h.each((C) => {
            C.type === "rule" && (C.selectors = C.selectors.map((x) => v({ get className() {
              return Us(x);
            }, selector: x })));
          }), h;
        }, h = (d != null ? d : f).clone(), y = [], w = c({ get container() {
          return m(), h;
        }, separator: r.tailwindConfig.separator, modifySelectors: g, wrap(v) {
          let C = h.nodes;
          h.removeAll(), v.append(C), h.append(v);
        }, format(v) {
          y.push({ format: v, isArbitraryVariant: s });
        }, args: n });
        if (Array.isArray(w)) {
          for (let [v, C] of w.entries())
            a.push([r.offsets.applyParallelOffset(p, v), C, h.clone()]);
          continue;
        }
        if (typeof w == "string" && y.push({ format: w, isArbitraryVariant: s }), w === null)
          continue;
        h.raws.neededBackup && (delete h.raws.neededBackup, h.walkRules((v) => {
          let C = v.raws.originalSelector;
          if (!C || (delete v.raws.originalSelector, C === v.selector))
            return;
          let x = v.selector, O = (0, yn.default)((E) => {
            E.walkClasses((R) => {
              R.value = `${t}${r.tailwindConfig.separator}${R.value}`;
            });
          }).processSync(C);
          y.push({ format: x.replace(O, "&"), isArbitraryVariant: s }), v.selector = C;
        })), h.nodes[0].raws.tailwind = { ...h.nodes[0].raws.tailwind, parentLayer: l.layer };
        let b = [{ ...l, sort: r.offsets.applyVariantOffset(l.sort, p, Object.assign(n, r.variantOptions.get(t))), collectedFormats: ((i = l.collectedFormats) != null ? i : []).concat(y) }, h.nodes[0]];
        o2.push(b);
      }
    }
    return o2;
  }
  return [];
}
function js(t, e, r = {}) {
  return !X(t) && !Array.isArray(t) ? [[t], r] : Array.isArray(t) ? js(t[0], e, t[1]) : (e.has(t) || e.set(t, it(t)), [e.get(t), r]);
}
var bv = /^[a-z_-]/;
function xv(t) {
  return bv.test(t);
}
function Sv(t) {
  if (!t.includes("://"))
    return false;
  try {
    let e = new URL(t);
    return e.scheme !== "" && e.host !== "";
  } catch {
    return false;
  }
}
function Of(t) {
  let e = true;
  return t.walkDecls((r) => {
    if (!_f(r.prop, r.value))
      return e = false, false;
  }), e;
}
function _f(t, e) {
  if (Sv(`${t}:${e}`))
    return false;
  try {
    return I2.parse(`a{${t}:${e}}`).toResult(), true;
  } catch {
    return false;
  }
}
function kv(t, e) {
  var a;
  let [, r, n] = (a = t.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) != null ? a : [];
  if (n === void 0 || !xv(r) || !lt(n))
    return null;
  let i = z(n);
  return _f(r, i) ? [[{ sort: e.offsets.arbitraryProperty(), layer: "utilities" }, () => ({ [Rs(t)]: { [r]: i } })]] : null;
}
function* Cv(t, e) {
  e.candidateRuleMap.has(t) && (yield [e.candidateRuleMap.get(t), "DEFAULT"]), yield* function* (o2) {
    o2 !== null && (yield [o2, "DEFAULT"]);
  }(kv(t, e));
  let r = t, n = false, i = e.tailwindConfig.prefix, s = i.length, a = r.startsWith(i) || r.startsWith(`-${i}`);
  r[s] === "-" && a && (n = true, r = i + r.slice(s + 1)), n && e.candidateRuleMap.has(r) && (yield [e.candidateRuleMap.get(r), "-DEFAULT"]);
  for (let [o2, l] of gv(r))
    e.candidateRuleMap.has(o2) && (yield [e.candidateRuleMap.get(o2), n ? `-${l}` : l]);
}
function Ev(t, e) {
  return t === ke ? [ke] : te(t, e);
}
function* Av(t, e) {
  var r, n;
  for (let i of t)
    i[1].raws.tailwind = { ...i[1].raws.tailwind, classCandidate: e, preserveSource: (n = (r = i[0].options) == null ? void 0 : r.preserveSource) != null ? n : false }, yield i;
}
function* wn(t, e, r = t) {
  var o2, l, u, f;
  let n = e.tailwindConfig.separator, [i, ...s] = Ev(t, n).reverse(), a = false;
  if (i.startsWith("!") && (a = true, i = i.slice(1)), G(e.tailwindConfig, "variantGrouping") && i.startsWith("(") && i.endsWith(")")) {
    let p = s.slice().reverse().join(n);
    for (let c of te(i.slice(1, -1), ","))
      yield* wn(p + n + c, e, r);
  }
  for (let p of Cv(i, e)) {
    let c = [], d = /* @__PURE__ */ new Map(), [h, y] = p, m = h.length === 1;
    for (let [g, w] of h) {
      let b = [];
      if (typeof w == "function")
        for (let v of [].concat(w(y, { isOnlyPlugin: m }))) {
          let [C, x] = js(v, e.postCssNodeCache);
          for (let O of C)
            b.push([{ ...g, options: { ...g.options, ...x } }, O]);
        }
      else if (y === "DEFAULT" || y === "-DEFAULT") {
        let v = w, [C, x] = js(v, e.postCssNodeCache);
        for (let O of C)
          b.push([{ ...g, options: { ...g.options, ...x } }, O]);
      }
      if (b.length > 0) {
        let v = Array.from(Os((l = (o2 = g.options) == null ? void 0 : o2.types) != null ? l : [], y, (u = g.options) != null ? u : {}, e.tailwindConfig)).map(([C, x]) => x);
        v.length > 0 && d.set(b, v), c.push(b);
      }
    }
    if (zs(y)) {
      if (c.length > 1) {
        let b = function(C) {
          return C.length === 1 ? C[0] : C.find((x) => {
            let O = d.get(x);
            return x.some(([{ options: E }, R]) => Of(R) ? E.types.some(({ type: L, preferOnConflict: B }) => O.includes(L) && B) : false);
          });
        }, [g, w] = c.reduce((C, x) => (x.some(([{ options: E }]) => E.types.some(({ type: R }) => R === "any")) ? C[0].push(x) : C[1].push(x), C), [[], []]), v = (f = b(w)) != null ? f : b(g);
        if (v)
          c = [v];
        else {
          let C = c.map((O) => {
            var E;
            return /* @__PURE__ */ new Set([...(E = d.get(O)) != null ? E : []]);
          });
          for (let O of C)
            for (let E of O) {
              let R = false;
              for (let L of C)
                O !== L && L.has(E) && (L.delete(E), R = true);
              R && O.delete(E);
            }
          let x = [];
          for (let [O, E] of C.entries())
            for (let R of E) {
              let L = c[O].map(([, B]) => B).flat().map((B) => B.toString().split(`
`).slice(1, -1).map((Q) => Q.trim()).map((Q) => `      ${Q}`).join(`
`)).join(`

`);
              x.push(`  Use \`${t.replace("[", `[${R}:`)}\` for \`${L.trim()}\``);
              break;
            }
          D.warn([`The class \`${t}\` is ambiguous and matches multiple utilities.`, ...x, `If this is content and not a class, replace it with \`${t.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`]);
          continue;
        }
      }
      c = c.map((g) => g.filter((w) => Of(w[1])));
    }
    c = c.flat(), c = Array.from(Av(c, i)), c = yv(c, e), a && (c = wv(c, i));
    for (let g of s)
      c = vv(g, c, e);
    for (let g of c)
      g[1].raws.tailwind = { ...g[1].raws.tailwind, candidate: t }, g = Ov(g, { context: e, candidate: t, original: r }), g !== null && (yield g);
  }
}
function Ov(t, { context: e, candidate: r, original: n }) {
  if (!t[0].collectedFormats)
    return t;
  let i = true, s;
  try {
    s = ot(t[0].collectedFormats, { context: e, candidate: r });
  } catch {
    return null;
  }
  let a = I2.root({ nodes: [t[1].clone()] });
  return a.walkRules((o2) => {
    if (!gn(o2))
      try {
        o2.selector = an(o2.selector, s, { candidate: n, context: e });
      } catch {
        return i = false, false;
      }
  }), i ? (t[1] = a.nodes[0], t) : null;
}
function gn(t) {
  return t.parent && t.parent.type === "atrule" && t.parent.name === "keyframes";
}
function _v(t) {
  if (t === true)
    return (e) => {
      gn(e) || e.walkDecls((r) => {
        r.parent.type === "rule" && !gn(r.parent) && (r.important = true);
      });
    };
  if (typeof t == "string")
    return (e) => {
      gn(e) || (e.selectors = e.selectors.map((r) => `${t} ${r}`));
    };
}
function mn(t, e) {
  var i;
  let r = [], n = _v(e.tailwindConfig.important);
  for (let s of t) {
    if (e.notClassCache.has(s))
      continue;
    if (e.candidateRuleCache.has(s)) {
      r = r.concat(Array.from(e.candidateRuleCache.get(s)));
      continue;
    }
    let a = Array.from(wn(s, e));
    if (a.length === 0) {
      e.notClassCache.add(s);
      continue;
    }
    e.classCache.set(s, a);
    let o2 = (i = e.candidateRuleCache.get(s)) != null ? i : /* @__PURE__ */ new Set();
    e.candidateRuleCache.set(s, o2);
    for (let l of a) {
      let [{ sort: u, options: f }, p] = l;
      if (f.respectImportant && n) {
        let d = I2.root({ nodes: [p.clone()] });
        d.walkRules(n), p = d.nodes[0];
      }
      let c = [u, p];
      o2.add(c), e.ruleCache.add(c), r.push(c);
    }
  }
  return r;
}
function zs(t) {
  return t.startsWith("[") && t.endsWith("]");
}
function Ge(t, e = void 0, r = void 0) {
  return t.map((n) => {
    var a;
    let i = n.clone(), s = ((a = n.raws.tailwind) == null ? void 0 : a.preserveSource) !== true || !i.source;
    return e !== void 0 && s && (i.source = e, "walk" in i && i.walk((o2) => {
      o2.source = e;
    })), r !== void 0 && (i.raws.tailwind = { ...i.raws.tailwind, ...r }), i;
  });
}
var Tf = /[\\^$.*+?()[\]{}|]/g;
var Tv = RegExp(Tf.source);
function vn(t) {
  return t = Array.isArray(t) ? t : [t], t = t.map((e) => e instanceof RegExp ? e.source : e), t.join("");
}
function ce(t) {
  return new RegExp(vn(t), "g");
}
function ut(t) {
  return `(?:${t.map(vn).join("|")})`;
}
function Vs(t) {
  return `(?:${vn(t)})?`;
}
function Pf(t) {
  return `(?:${vn(t)})*`;
}
function Rf(t) {
  return t && Tv.test(t) ? t.replace(Tf, "\\$&") : t || "";
}
function If(t) {
  let e = Array.from(Rv(t));
  return (r) => {
    var i;
    let n = [];
    for (let s of e)
      n = [...n, ...(i = r.match(s)) != null ? i : []];
    return n.filter((s) => s !== void 0).map(Mv);
  };
}
function* Rv(t) {
  let e = t.tailwindConfig.separator, r = G(t.tailwindConfig, "variantGrouping"), n = t.tailwindConfig.prefix !== "" ? Vs(ce([/-?/, Rf(t.tailwindConfig.prefix)])) : "", i = ut([/\[[^\s:'"`]+:[^\s\[\]]+\]/, /\[[^\s:'"`]+:[^\s]+?\[[^\s]+?\][^\s]+?\]/, ce([/-?(?:\w+)/, Vs(ut([ce([/-(?:\w+-)*\[[^\s:]+\]/, /(?![{([]])/, /(?:\/[^\s'"`\\><$]*)?/]), ce([/-(?:\w+-)*\[[^\s]+\]/, /(?![{([]])/, /(?:\/[^\s'"`\\$]*)?/]), /[-\/][^\s'"`\\$={><]*/]))])]), s = [ut([ce([/@\[[^\s"'`]+\](\/[^\s"'`]+)?/, e]), ce([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, e]), ce([/[^\s"'`\[\\]+/, e])]), ut([ce([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, e]), ce([/[^\s`\[\\]+/, e])])];
  for (let a of s)
    yield ce(["((?=((", a, ")+))\\2)?", /!?/, n, r ? ut([ce([/\(/, i, Pf([/,/, i]), /\)/]), i]) : i]);
  yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
}
var Iv = /([\[\]'"`])([^\[\]'"`])?/g;
var Dv = /[^"'`\s<>\]]+/;
function Mv(t) {
  if (!t.includes("-["))
    return t;
  let e = 0, r = [], n = t.matchAll(Iv);
  n = Array.from(n).flatMap((i) => {
    let [, ...s] = i;
    return s.map((a, o2) => Object.assign([], i, { index: i.index + o2, 0: a }));
  });
  for (let i of n) {
    let s = i[0], a = r[r.length - 1];
    if (s === a ? r.pop() : (s === "'" || s === '"' || s === "`") && r.push(s), !a) {
      if (s === "[") {
        e++;
        continue;
      } else if (s === "]") {
        e--;
        continue;
      }
      if (e < 0)
        return t.substring(0, i.index - 1);
      if (e === 0 && !Dv.test(s))
        return t.substring(0, i.index);
    }
  }
  return t;
}
var me = Un;
var Lf = { DEFAULT: If };
var Ff = { DEFAULT: (t) => t, svelte: (t) => t.replace(/(?:^|\s)class:/g, " ") };
function Fv(t, e) {
  let r = t.tailwindConfig.content.extract;
  return r[e] || r.DEFAULT || Lf[e] || Lf.DEFAULT(t);
}
function Nv(t, e) {
  let r = t.content.transform;
  return r[e] || r.DEFAULT || Ff[e] || Ff.DEFAULT;
}
var ur = /* @__PURE__ */ new WeakMap();
function qv(t, e, r, n) {
  ur.has(e) || ur.set(e, new Nf.default({ maxSize: 25e3 }));
  for (let i of t.split(`
`))
    if (i = i.trim(), !n.has(i))
      if (n.add(i), ur.get(e).has(i))
        for (let s of ur.get(e).get(i))
          r.add(s);
      else {
        let s = e(i).filter((o2) => o2 !== "!*"), a = new Set(s);
        for (let o2 of a)
          r.add(o2);
        ur.get(e).set(i, a);
      }
}
function $v(t, e) {
  let r = e.offsets.sort(t), n = { base: /* @__PURE__ */ new Set(), defaults: /* @__PURE__ */ new Set(), components: /* @__PURE__ */ new Set(), utilities: /* @__PURE__ */ new Set(), variants: /* @__PURE__ */ new Set() };
  for (let [i, s] of r)
    n[i.layer].add(s);
  return n;
}
function Ws(t) {
  return (e) => {
    var h;
    let r = { base: null, components: null, utilities: null, variants: null };
    if (e.walkAtRules((y) => {
      y.name === "tailwind" && Object.keys(r).includes(y.params) && (r[y.params] = y);
    }), Object.values(r).every((y) => y === null))
      return e;
    let n = /* @__PURE__ */ new Set([...(h = t.candidates) != null ? h : [], ke]), i = /* @__PURE__ */ new Set();
    if (me.DEBUG && console.time("Reading changed files"), me.OXIDE)
      for (let y of (Mf(), _e(Df)).parseCandidateStringsFromFiles(t.changedContent))
        n.add(y);
    else
      for (let { file: y, content: m, extension: g } of t.changedContent) {
        let w = Nv(t.tailwindConfig, g), b = Fv(t, g);
        m = y ? ht.readFileSync(y, "utf8") : m, qv(w(m), b, n, i);
      }
    me.DEBUG && console.timeEnd("Reading changed files");
    let s = t.classCache.size;
    me.DEBUG && console.time("Generate rules"), me.DEBUG && console.time("Sorting candidates");
    let a = me.OXIDE ? n : new Set([...n].sort((y, m) => y === m ? 0 : y < m ? -1 : 1));
    me.DEBUG && console.timeEnd("Sorting candidates"), mn(a, t), me.DEBUG && console.timeEnd("Generate rules"), me.DEBUG && console.time("Build stylesheet"), (t.stylesheetCache === null || t.classCache.size !== s) && (t.stylesheetCache = $v([...t.ruleCache], t)), me.DEBUG && console.timeEnd("Build stylesheet");
    let { defaults: o2, base: l, components: u, utilities: f, variants: p } = t.stylesheetCache;
    r.base && (r.base.before(Ge([...l, ...o2], r.base.source, { layer: "base" })), r.base.remove()), r.components && (r.components.before(Ge([...u], r.components.source, { layer: "components" })), r.components.remove()), r.utilities && (r.utilities.before(Ge([...f], r.utilities.source, { layer: "utilities" })), r.utilities.remove());
    let c = Array.from(p).filter((y) => {
      var g;
      let m = (g = y.raws.tailwind) == null ? void 0 : g.parentLayer;
      return m === "components" ? r.components !== null : m === "utilities" ? r.utilities !== null : true;
    });
    r.variants ? (r.variants.before(Ge(c, r.variants.source, { layer: "variants" })), r.variants.remove()) : c.length > 0 && e.append(Ge(c, e.source, { layer: "variants" }));
    let d = c.some((y) => {
      var m;
      return ((m = y.raws.tailwind) == null ? void 0 : m.parentLayer) === "utilities";
    });
    r.utilities && f.size === 0 && !d && D.warn("content-problems", ["No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.", "https://tailwindcss.com/docs/content-configuration"]), me.DEBUG && (console.log("Potential classes: ", n.size), console.log("Active contexts: ", jn.size)), t.changedContent = [], e.walkAtRules("layer", (y) => {
      Object.keys(r).includes(y.params) && y.remove();
    });
  };
}
var Gs = Y(Ae());
function bn(t) {
  let e = /* @__PURE__ */ new Map();
  I2.root({ nodes: [t.clone()] }).walkRules((s) => {
    (0, Gs.default)((a) => {
      a.walkClasses((o2) => {
        let l = o2.parent.toString(), u = e.get(l);
        u || e.set(l, u = /* @__PURE__ */ new Set()), u.add(o2.value);
      });
    }).processSync(s.selector);
  });
  let n = Array.from(e.values(), (s) => Array.from(s)), i = n.flat();
  return Object.assign(i, { groups: n });
}
var Uv = (0, Gs.default)();
function Bs(t) {
  return Uv.astSync(t);
}
function qf(t, e) {
  let r = /* @__PURE__ */ new Set();
  for (let n of t)
    r.add(n.split(e).pop());
  return Array.from(r);
}
function $f(t, e) {
  let r = t.tailwindConfig.prefix;
  return typeof r == "function" ? r(e) : r + e;
}
function* jf(t) {
  for (yield t; t.parent; )
    yield t.parent, t = t.parent;
}
function jv(t, e = {}) {
  let r = t.nodes;
  t.nodes = [];
  let n = t.clone(e);
  return t.nodes = r, n;
}
function zv(t) {
  for (let e of jf(t))
    if (t !== e) {
      if (e.type === "root")
        break;
      t = jv(e, { nodes: [t] });
    }
  return t;
}
function Vv(t, e) {
  let r = /* @__PURE__ */ new Map();
  return t.walkRules((n) => {
    var a;
    for (let o2 of jf(n))
      if (((a = o2.raws.tailwind) == null ? void 0 : a.layer) !== void 0)
        return;
    let i = zv(n), s = e.offsets.create("user");
    for (let o2 of bn(n)) {
      let l = r.get(o2) || [];
      r.set(o2, l), l.push([{ layer: "user", sort: s, important: false }, i]);
    }
  }), r;
}
function Wv(t, e) {
  for (let r of t) {
    if (e.notClassCache.has(r) || e.applyClassCache.has(r))
      continue;
    if (e.classCache.has(r)) {
      e.applyClassCache.set(r, e.classCache.get(r).map(([i, s]) => [i, s.clone()]));
      continue;
    }
    let n = Array.from(wn(r, e));
    if (n.length === 0) {
      e.notClassCache.add(r);
      continue;
    }
    e.applyClassCache.set(r, n);
  }
  return e.applyClassCache;
}
function Bv(t) {
  let e = null;
  return { get: (r) => (e = e || t(), e.get(r)), has: (r) => (e = e || t(), e.has(r)) };
}
function Gv(t) {
  return { get: (e) => t.flatMap((r) => r.get(e) || []), has: (e) => t.some((r) => r.has(e)) };
}
function Uf(t) {
  let e = t.split(/[\s\t\n]+/g);
  return e[e.length - 1] === "!important" ? [e.slice(0, -1), true] : [e, false];
}
function zf(t, e, r) {
  let n = /* @__PURE__ */ new Set(), i = [];
  if (t.walkAtRules("apply", (l) => {
    let [u] = Uf(l.params);
    for (let f of u)
      n.add(f);
    i.push(l);
  }), i.length === 0)
    return;
  let s = Gv([r, Wv(n, e)]);
  function a(l, u, f) {
    let p = Bs(l), c = Bs(u), h = Bs(`.${re(f)}`).nodes[0].nodes[0];
    return p.each((y) => {
      let m = /* @__PURE__ */ new Set();
      c.each((g) => {
        let w = false;
        g = g.clone(), g.walkClasses((b) => {
          b.value === h.value && (w || (b.replaceWith(...y.nodes.map((v) => v.clone())), m.add(g), w = true));
        });
      });
      for (let g of m) {
        let w = [[]];
        for (let b of g.nodes)
          b.type === "combinator" ? (w.push(b), w.push([])) : w[w.length - 1].push(b);
        g.nodes = [];
        for (let b of w)
          Array.isArray(b) && b.sort((v, C) => v.type === "tag" && C.type === "class" ? -1 : v.type === "class" && C.type === "tag" ? 1 : v.type === "class" && C.type === "pseudo" && C.value.startsWith("::") ? -1 : v.type === "pseudo" && v.value.startsWith("::") && C.type === "class" ? 1 : 0), g.nodes = g.nodes.concat(b);
      }
      y.replaceWith(...m);
    }), p.toString();
  }
  let o2 = /* @__PURE__ */ new Map();
  for (let l of i) {
    let [u] = o2.get(l.parent) || [[], l.source];
    o2.set(l.parent, [u, l.source]);
    let [f, p] = Uf(l.params);
    if (l.parent.type === "atrule") {
      if (l.parent.name === "screen") {
        let c = l.parent.params;
        throw l.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${f.map((d) => `${c}:${d}`).join(" ")} instead.`);
      }
      throw l.error(`@apply is not supported within nested at-rules like @${l.parent.name}. You can fix this by un-nesting @${l.parent.name}.`);
    }
    for (let c of f) {
      if ([$f(e, "group"), $f(e, "peer")].includes(c))
        throw l.error(`@apply should not be used with the '${c}' utility`);
      if (!s.has(c))
        throw l.error(`The \`${c}\` class does not exist. If \`${c}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
      let d = s.get(c);
      u.push([c, p, d]);
    }
  }
  for (let [l, [u, f]] of o2) {
    let p = [];
    for (let [d, h, y] of u) {
      let m = [d, ...qf([d], e.tailwindConfig.separator)];
      for (let [g, w] of y) {
        let b = bn(l), v = bn(w);
        if (v = v.groups.filter((E) => E.some((R) => m.includes(R))).flat(), v = v.concat(qf(v, e.tailwindConfig.separator)), b.some((E) => v.includes(E)))
          throw w.error(`You cannot \`@apply\` the \`${d}\` utility here because it creates a circular dependency.`);
        let x = I2.root({ nodes: [w.clone()] });
        x.walk((E) => {
          E.source = f;
        }), (w.type !== "atrule" || w.type === "atrule" && w.name !== "keyframes") && x.walkRules((E) => {
          if (!bn(E).some((Q) => Q === d)) {
            E.remove();
            return;
          }
          let R = typeof e.tailwindConfig.important == "string" ? e.tailwindConfig.important : null, B = l.raws.tailwind !== void 0 && R && l.selector.indexOf(R) === 0 ? l.selector.slice(R.length) : l.selector;
          E.selector = a(B, E.selector, d), R && B !== l.selector && (E.selector = `${R} ${E.selector}`), E.walkDecls((Q) => {
            Q.important = g.important || h;
          });
        }), x.nodes[0] && p.push([g.sort, x.nodes[0]]);
      }
    }
    let c = e.offsets.sort(p).map((d) => d[1]);
    l.after(c);
  }
  for (let l of i)
    l.parent.nodes.length > 1 ? l.remove() : l.parent.remove();
  zf(t, e, r);
}
function Ys(t) {
  return (e) => {
    let r = Bv(() => Vv(e, t));
    zf(e, t, r);
  };
}
var fr = Y(Ms());
var sc = Y(Vf());
var na = Y(nc());
function ta(t) {
  return typeof t == "object" && t !== null;
}
function t0(t, e) {
  let r = Ne(e);
  do
    if (r.pop(), (0, fr.default)(t, r) !== void 0)
      break;
  while (r.length);
  return r.length ? r : void 0;
}
function ct(t) {
  return typeof t == "string" ? t : t.reduce((e, r, n) => r.includes(".") ? `${e}[${r}]` : n === 0 ? r : `${e}.${r}`, "");
}
function ac(t) {
  return t.map((e) => `'${e}'`).join(", ");
}
function ic(t) {
  return ac(Object.keys(t));
}
function ra(t, e, r, n = {}) {
  let i = Array.isArray(e) ? ct(e) : e.replace(/^['"]+|['"]+$/g, ""), s = Array.isArray(e) ? e : Ne(i), a = (0, fr.default)(t.theme, s, r);
  if (a === void 0) {
    let l = `'${i}' does not exist in your theme config.`, u = s.slice(0, -1), f = (0, fr.default)(t.theme, u);
    if (ta(f)) {
      let p = Object.keys(f).filter((d) => ra(t, [...u, d]).isValid), c = (0, sc.default)(s[s.length - 1], p);
      c ? l += ` Did you mean '${ct([...u, c])}'?` : p.length > 0 && (l += ` '${ct(u)}' has the following valid keys: ${ac(p)}`);
    } else {
      let p = t0(t.theme, i);
      if (p) {
        let c = (0, fr.default)(t.theme, p);
        ta(c) ? l += ` '${ct(p)}' has the following keys: ${ic(c)}` : l += ` '${ct(p)}' is not an object.`;
      } else
        l += ` Your theme has the following top-level keys: ${ic(t.theme)}`;
    }
    return { isValid: false, error: l };
  }
  if (!(typeof a == "string" || typeof a == "number" || typeof a == "function" || a instanceof String || a instanceof Number || Array.isArray(a))) {
    let l = `'${i}' was found but does not resolve to a string.`;
    if (ta(a)) {
      let u = Object.keys(a).filter((f) => ra(t, [...s, f]).isValid);
      u.length && (l += ` Did you mean something like '${ct([...s, u[0]])}'?`);
    }
    return { isValid: false, error: l };
  }
  let [o2] = s;
  return { isValid: true, value: Oe(o2)(a, n) };
}
function r0(t, e, r) {
  e = e.map((i) => oc(t, i, r));
  let n = [""];
  for (let i of e)
    i.type === "div" && i.value === "," ? n.push("") : n[n.length - 1] += na.default.stringify(i);
  return n;
}
function oc(t, e, r) {
  if (e.type === "function" && r[e.value] !== void 0) {
    let n = r0(t, e.nodes, r);
    e.type = "word", e.value = r[e.value](t, ...n);
  }
  return e;
}
function n0(t, e, r) {
  return (0, na.default)(e).walk((n) => {
    oc(t, n, r);
  }).toString();
}
var i0 = { atrule: "params", decl: "value" };
function* s0(t) {
  t = t.replace(/^['"]+|['"]+$/g, "");
  let e = t.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/), r;
  yield [t, void 0], e && (t = e[1], r = e[2], yield [t, r]);
}
function a0(t, e, r) {
  var i;
  let n = Array.from(s0(e)).map(([s, a]) => Object.assign(ra(t, s, r, { opacityValue: a }), { resolvedPath: s, alpha: a }));
  return (i = n.find((s) => s.isValid)) != null ? i : n[0];
}
function lc(t) {
  let e = t.tailwindConfig, r = { theme: (n, i, ...s) => {
    var c;
    let { isValid: a, value: o2, error: l, alpha: u } = a0(e, i, s.length ? s : void 0);
    if (!a) {
      let d = n.parent, h = (c = d == null ? void 0 : d.raws.tailwind) == null ? void 0 : c.candidate;
      if (d && h !== void 0) {
        t.markInvalidUtilityNode(d), d.remove(), D.warn("invalid-theme-key-in-class", [`The utility \`${h}\` contains an invalid theme value and was not generated.`]);
        return;
      }
      throw n.error(l);
    }
    let f = at(o2);
    return (u !== void 0 || f !== void 0 && typeof f == "function") && (u === void 0 && (u = 1), o2 = ve(f, u, f)), o2;
  }, screen: (n, i) => {
    i = i.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
    let a = Fe(e.theme.screens).find(({ name: o2 }) => o2 === i);
    if (!a)
      throw n.error(`The '${i}' screen does not exist in your theme.`);
    return Le(a);
  } };
  return (n) => {
    n.walk((i) => {
      let s = i0[i.type];
      s !== void 0 && (i[s] = n0(i, i[s], r));
    });
  };
}
function uc({ tailwindConfig: { theme: t } }) {
  return function(e) {
    e.walkAtRules("screen", (r) => {
      let n = r.params, s = Fe(t.screens).find(({ name: a }) => a === n);
      if (!s)
        throw r.error(`No \`${n}\` screen found.`);
      r.name = "media", r.params = Le(s);
    });
  };
}
var An = Y(Ae());
var fc = { id(t) {
  return An.default.attribute({ attribute: "id", operator: "=", value: t.value, quoteMark: '"' });
} };
function o0(t) {
  let e = t.filter((o2) => o2.type !== "pseudo" || o2.nodes.length > 0 ? true : o2.value.startsWith("::") || [":before", ":after", ":first-line", ":first-letter"].includes(o2.value)).reverse(), r = /* @__PURE__ */ new Set(["tag", "class", "id", "attribute"]), n = e.findIndex((o2) => r.has(o2.type));
  if (n === -1)
    return e.reverse().join("").trim();
  let i = e[n], s = fc[i.type] ? fc[i.type](i) : i;
  e = e.slice(0, n);
  let a = e.findIndex((o2) => o2.type === "combinator" && o2.value === ">");
  return a !== -1 && (e.splice(0, a), e.unshift(An.default.universal())), [s, ...e.reverse()].join("").trim();
}
var l0 = (0, An.default)((t) => t.map((e) => {
  let r = e.split((n) => n.type === "combinator" && n.value === " ").pop();
  return o0(r);
}));
var ia = /* @__PURE__ */ new Map();
function u0(t) {
  return ia.has(t) || ia.set(t, l0.transformSync(t)), ia.get(t);
}
function sa({ tailwindConfig: t }) {
  return (e) => {
    var i, s;
    let r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set();
    if (e.walkAtRules("defaults", (a) => {
      if (a.nodes && a.nodes.length > 0) {
        n.add(a);
        return;
      }
      let o2 = a.params;
      r.has(o2) || r.set(o2, /* @__PURE__ */ new Set()), r.get(o2).add(a.parent), a.remove();
    }), G(t, "optimizeUniversalDefaults"))
      for (let a of n) {
        let o2 = /* @__PURE__ */ new Map(), l = (i = r.get(a.params)) != null ? i : [];
        for (let u of l)
          for (let f of u0(u.selector)) {
            let p = f.includes(":-") || f.includes("::-") ? f : "__DEFAULT__", c = (s = o2.get(p)) != null ? s : /* @__PURE__ */ new Set();
            o2.set(p, c), c.add(f);
          }
        if (G(t, "optimizeUniversalDefaults")) {
          if (o2.size === 0) {
            a.remove();
            continue;
          }
          for (let [, u] of o2) {
            let f = I2.rule({ source: a.source });
            f.selectors = [...u], f.append(a.nodes.map((p) => p.clone())), a.before(f);
          }
        }
        a.remove();
      }
    else if (n.size) {
      let a = I2.rule({ selectors: ["*", "::before", "::after"] });
      for (let l of n)
        a.append(l.nodes), a.parent || l.before(a), a.source || (a.source = l.source), l.remove();
      let o2 = a.clone({ selectors: ["::backdrop"] });
      a.after(o2);
    }
  };
}
var cc = { atrule: ["name", "params"], rule: ["selector"] };
var f0 = new Set(Object.keys(cc));
function aa() {
  function t(e) {
    let r = null;
    e.each((n) => {
      if (!f0.has(n.type)) {
        r = null;
        return;
      }
      if (r === null) {
        r = n;
        return;
      }
      let i = cc[n.type];
      n.type === "atrule" && n.name === "font-face" ? r = n : i.every((s) => {
        var a, o2;
        return ((a = n[s]) != null ? a : "").replace(/\s+/g, " ") === ((o2 = r[s]) != null ? o2 : "").replace(/\s+/g, " ");
      }) ? (n.nodes && r.append(n.nodes), n.remove()) : r = n;
    }), e.each((n) => {
      n.type === "atrule" && t(n);
    });
  }
  return (e) => {
    t(e);
  };
}
function oa() {
  return (t) => {
    t.walkRules((e) => {
      let r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set([]), i = /* @__PURE__ */ new Map();
      e.walkDecls((s) => {
        if (s.parent === e) {
          if (r.has(s.prop)) {
            if (r.get(s.prop).value === s.value) {
              n.add(r.get(s.prop)), r.set(s.prop, s);
              return;
            }
            i.has(s.prop) || i.set(s.prop, /* @__PURE__ */ new Set()), i.get(s.prop).add(r.get(s.prop)), i.get(s.prop).add(s);
          }
          r.set(s.prop, s);
        }
      });
      for (let s of n)
        s.remove();
      for (let s of i.values()) {
        let a = /* @__PURE__ */ new Map();
        for (let o2 of s) {
          let l = p0(o2.value);
          l !== null && (a.has(l) || a.set(l, /* @__PURE__ */ new Set()), a.get(l).add(o2));
        }
        for (let o2 of a.values()) {
          let l = Array.from(o2).slice(0, -1);
          for (let u of l)
            u.remove();
        }
      }
    });
  };
}
var c0 = Symbol("unitless-number");
function p0(t) {
  var r;
  let e = /^-?\d*.?\d+([\w%]+)?$/g.exec(t);
  return e ? (r = e[1]) != null ? r : c0 : null;
}
function d0(t) {
  if (!t.walkAtRules)
    return;
  let e = /* @__PURE__ */ new Set();
  if (t.walkAtRules("apply", (r) => {
    e.add(r.parent);
  }), e.size !== 0)
    for (let r of e) {
      let n = [], i = [];
      for (let s of r.nodes)
        s.type === "atrule" && s.name === "apply" ? (i.length > 0 && (n.push(i), i = []), n.push([s])) : i.push(s);
      if (i.length > 0 && n.push(i), n.length !== 1) {
        for (let s of [...n].reverse()) {
          let a = r.clone({ nodes: [] });
          a.append(s), r.after(a);
        }
        r.remove();
      }
    }
}
function On() {
  return (t) => {
    d0(t);
  };
}
function h0(t) {
  return t.type === "root";
}
function m0(t) {
  return t.type === "atrule" && t.name === "layer";
}
function pc(t) {
  return (e, r) => {
    let n = false;
    e.walkAtRules("tailwind", (i) => {
      if (n)
        return false;
      if (i.parent && !(h0(i.parent) || m0(i.parent)))
        return n = true, i.warn(r, ["Nested @tailwind rules were detected, but are not supported.", "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix", "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"].join(`
`)), false;
    }), e.walkRules((i) => {
      if (n)
        return false;
      i.walkRules((s) => (n = true, s.warn(r, ["Nested CSS was detected, but CSS nesting has not been configured correctly.", "Please enable a CSS nesting plugin *before* Tailwind in your configuration.", "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"].join(`
`)), false));
    });
  };
}
function la(t) {
  return function(e, r) {
    let { tailwindDirectives: n, applyDirectives: i } = Nn(e);
    pc()(e, r), On()(e, r);
    let s = t({ tailwindDirectives: n, applyDirectives: i, registerDependency(a) {
      r.messages.push({ plugin: "tailwindcss", parent: r.opts.from, ...a });
    }, createContext(a, o2) {
      return Af(a, o2, e);
    } })(e, r);
    if (s.tailwindConfig.separator === "-")
      throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
    tf(s.tailwindConfig), Ws(s)(e, r), On()(e, r), Ys(s)(e, r), lc(s)(e, r), uc(s)(e, r), sa(s)(e, r), aa(s)(e, r), oa(s)(e, r);
  };
}
var dc = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "display", "aspectRatio", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "whitespace", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "content"];
function hc(t, e) {
  return t === void 0 ? e : Array.isArray(t) ? t : [...new Set(e.filter((n) => t !== false && t[n] !== false).concat(Object.keys(t).filter((n) => t[n] !== false)))];
}
function cr({ version: t, from: e, to: r }) {
  D.warn(`${e}-color-renamed`, [`As of Tailwind CSS ${t}, \`${e}\` has been renamed to \`${r}\`.`, "Update your configuration file to silence this warning."]);
}
var mc = { inherit: "inherit", current: "currentColor", transparent: "transparent", black: "#000", white: "#fff", slate: { 50: "#f8fafc", 100: "#f1f5f9", 200: "#e2e8f0", 300: "#cbd5e1", 400: "#94a3b8", 500: "#64748b", 600: "#475569", 700: "#334155", 800: "#1e293b", 900: "#0f172a" }, gray: { 50: "#f9fafb", 100: "#f3f4f6", 200: "#e5e7eb", 300: "#d1d5db", 400: "#9ca3af", 500: "#6b7280", 600: "#4b5563", 700: "#374151", 800: "#1f2937", 900: "#111827" }, zinc: { 50: "#fafafa", 100: "#f4f4f5", 200: "#e4e4e7", 300: "#d4d4d8", 400: "#a1a1aa", 500: "#71717a", 600: "#52525b", 700: "#3f3f46", 800: "#27272a", 900: "#18181b" }, neutral: { 50: "#fafafa", 100: "#f5f5f5", 200: "#e5e5e5", 300: "#d4d4d4", 400: "#a3a3a3", 500: "#737373", 600: "#525252", 700: "#404040", 800: "#262626", 900: "#171717" }, stone: { 50: "#fafaf9", 100: "#f5f5f4", 200: "#e7e5e4", 300: "#d6d3d1", 400: "#a8a29e", 500: "#78716c", 600: "#57534e", 700: "#44403c", 800: "#292524", 900: "#1c1917" }, red: { 50: "#fef2f2", 100: "#fee2e2", 200: "#fecaca", 300: "#fca5a5", 400: "#f87171", 500: "#ef4444", 600: "#dc2626", 700: "#b91c1c", 800: "#991b1b", 900: "#7f1d1d" }, orange: { 50: "#fff7ed", 100: "#ffedd5", 200: "#fed7aa", 300: "#fdba74", 400: "#fb923c", 500: "#f97316", 600: "#ea580c", 700: "#c2410c", 800: "#9a3412", 900: "#7c2d12" }, amber: { 50: "#fffbeb", 100: "#fef3c7", 200: "#fde68a", 300: "#fcd34d", 400: "#fbbf24", 500: "#f59e0b", 600: "#d97706", 700: "#b45309", 800: "#92400e", 900: "#78350f" }, yellow: { 50: "#fefce8", 100: "#fef9c3", 200: "#fef08a", 300: "#fde047", 400: "#facc15", 500: "#eab308", 600: "#ca8a04", 700: "#a16207", 800: "#854d0e", 900: "#713f12" }, lime: { 50: "#f7fee7", 100: "#ecfccb", 200: "#d9f99d", 300: "#bef264", 400: "#a3e635", 500: "#84cc16", 600: "#65a30d", 700: "#4d7c0f", 800: "#3f6212", 900: "#365314" }, green: { 50: "#f0fdf4", 100: "#dcfce7", 200: "#bbf7d0", 300: "#86efac", 400: "#4ade80", 500: "#22c55e", 600: "#16a34a", 700: "#15803d", 800: "#166534", 900: "#14532d" }, emerald: { 50: "#ecfdf5", 100: "#d1fae5", 200: "#a7f3d0", 300: "#6ee7b7", 400: "#34d399", 500: "#10b981", 600: "#059669", 700: "#047857", 800: "#065f46", 900: "#064e3b" }, teal: { 50: "#f0fdfa", 100: "#ccfbf1", 200: "#99f6e4", 300: "#5eead4", 400: "#2dd4bf", 500: "#14b8a6", 600: "#0d9488", 700: "#0f766e", 800: "#115e59", 900: "#134e4a" }, cyan: { 50: "#ecfeff", 100: "#cffafe", 200: "#a5f3fc", 300: "#67e8f9", 400: "#22d3ee", 500: "#06b6d4", 600: "#0891b2", 700: "#0e7490", 800: "#155e75", 900: "#164e63" }, sky: { 50: "#f0f9ff", 100: "#e0f2fe", 200: "#bae6fd", 300: "#7dd3fc", 400: "#38bdf8", 500: "#0ea5e9", 600: "#0284c7", 700: "#0369a1", 800: "#075985", 900: "#0c4a6e" }, blue: { 50: "#eff6ff", 100: "#dbeafe", 200: "#bfdbfe", 300: "#93c5fd", 400: "#60a5fa", 500: "#3b82f6", 600: "#2563eb", 700: "#1d4ed8", 800: "#1e40af", 900: "#1e3a8a" }, indigo: { 50: "#eef2ff", 100: "#e0e7ff", 200: "#c7d2fe", 300: "#a5b4fc", 400: "#818cf8", 500: "#6366f1", 600: "#4f46e5", 700: "#4338ca", 800: "#3730a3", 900: "#312e81" }, violet: { 50: "#f5f3ff", 100: "#ede9fe", 200: "#ddd6fe", 300: "#c4b5fd", 400: "#a78bfa", 500: "#8b5cf6", 600: "#7c3aed", 700: "#6d28d9", 800: "#5b21b6", 900: "#4c1d95" }, purple: { 50: "#faf5ff", 100: "#f3e8ff", 200: "#e9d5ff", 300: "#d8b4fe", 400: "#c084fc", 500: "#a855f7", 600: "#9333ea", 700: "#7e22ce", 800: "#6b21a8", 900: "#581c87" }, fuchsia: { 50: "#fdf4ff", 100: "#fae8ff", 200: "#f5d0fe", 300: "#f0abfc", 400: "#e879f9", 500: "#d946ef", 600: "#c026d3", 700: "#a21caf", 800: "#86198f", 900: "#701a75" }, pink: { 50: "#fdf2f8", 100: "#fce7f3", 200: "#fbcfe8", 300: "#f9a8d4", 400: "#f472b6", 500: "#ec4899", 600: "#db2777", 700: "#be185d", 800: "#9d174d", 900: "#831843" }, rose: { 50: "#fff1f2", 100: "#ffe4e6", 200: "#fecdd3", 300: "#fda4af", 400: "#fb7185", 500: "#f43f5e", 600: "#e11d48", 700: "#be123c", 800: "#9f1239", 900: "#881337" }, get lightBlue() {
  return cr({ version: "v2.2", from: "lightBlue", to: "sky" }), this.sky;
}, get warmGray() {
  return cr({ version: "v3.0", from: "warmGray", to: "stone" }), this.stone;
}, get trueGray() {
  return cr({ version: "v3.0", from: "trueGray", to: "neutral" }), this.neutral;
}, get coolGray() {
  return cr({ version: "v3.0", from: "coolGray", to: "gray" }), this.gray;
}, get blueGray() {
  return cr({ version: "v3.0", from: "blueGray", to: "slate" }), this.slate;
} };
function ua(t, ...e) {
  var r, n;
  for (let i of e) {
    for (let s in i)
      (r = t == null ? void 0 : t.hasOwnProperty) != null && r.call(t, s) || (t[s] = i[s]);
    for (let s of Object.getOwnPropertySymbols(i))
      (n = t == null ? void 0 : t.hasOwnProperty) != null && n.call(t, s) || (t[s] = i[s]);
  }
  return t;
}
function gc(t) {
  var r;
  (() => {
    if (t.purge || !t.content || !Array.isArray(t.content) && !(typeof t.content == "object" && t.content !== null))
      return false;
    if (Array.isArray(t.content))
      return t.content.every((n) => typeof n == "string" ? true : !(typeof (n == null ? void 0 : n.raw) != "string" || (n == null ? void 0 : n.extension) && typeof (n == null ? void 0 : n.extension) != "string"));
    if (typeof t.content == "object" && t.content !== null) {
      if (Object.keys(t.content).some((n) => !["files", "relative", "extract", "transform"].includes(n)))
        return false;
      if (Array.isArray(t.content.files)) {
        if (!t.content.files.every((n) => typeof n == "string" ? true : !(typeof (n == null ? void 0 : n.raw) != "string" || (n == null ? void 0 : n.extension) && typeof (n == null ? void 0 : n.extension) != "string")))
          return false;
        if (typeof t.content.extract == "object") {
          for (let n of Object.values(t.content.extract))
            if (typeof n != "function")
              return false;
        } else if (!(t.content.extract === void 0 || typeof t.content.extract == "function"))
          return false;
        if (typeof t.content.transform == "object") {
          for (let n of Object.values(t.content.transform))
            if (typeof n != "function")
              return false;
        } else if (!(t.content.transform === void 0 || typeof t.content.transform == "function"))
          return false;
        if (typeof t.content.relative != "boolean" && typeof t.content.relative < "u")
          return false;
      }
      return true;
    }
    return false;
  })() || D.warn("purge-deprecation", ["The `purge`/`content` options have changed in Tailwind CSS v3.0.", "Update your configuration file to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"]), t.safelist = (() => {
    var a;
    let { content: n, purge: i, safelist: s } = t;
    return Array.isArray(s) ? s : Array.isArray(n == null ? void 0 : n.safelist) ? n.safelist : Array.isArray(i == null ? void 0 : i.safelist) ? i.safelist : Array.isArray((a = i == null ? void 0 : i.options) == null ? void 0 : a.safelist) ? i.options.safelist : [];
  })(), t.blocklist = (() => {
    let { blocklist: n } = t;
    if (Array.isArray(n)) {
      if (n.every((i) => typeof i == "string"))
        return n;
      D.warn("blocklist-invalid", ["The `blocklist` option must be an array of strings.", "https://tailwindcss.com/docs/content-configuration#discarding-classes"]);
    }
    return [];
  })(), typeof t.prefix == "function" ? (D.warn("prefix-function", ["As of Tailwind CSS v3.0, `prefix` cannot be a function.", "Update `prefix` in your configuration to be a string to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"]), t.prefix = "") : t.prefix = (r = t.prefix) != null ? r : "", t.content = { relative: (() => {
    var i, s;
    let { content: n } = t;
    return n != null && n.relative ? n.relative : (s = (i = t.future) == null ? void 0 : i.relativeContentPathsByDefault) != null ? s : false;
  })(), files: (() => {
    let { content: n, purge: i } = t;
    return Array.isArray(i) ? i : Array.isArray(i == null ? void 0 : i.content) ? i.content : Array.isArray(n) ? n : Array.isArray(n == null ? void 0 : n.content) ? n.content : Array.isArray(n == null ? void 0 : n.files) ? n.files : [];
  })(), extract: (() => {
    let n = (() => {
      var a, o2, l, u, f, p, c, d, h, y;
      return (a = t.purge) != null && a.extract ? t.purge.extract : (o2 = t.content) != null && o2.extract ? t.content.extract : (u = (l = t.purge) == null ? void 0 : l.extract) != null && u.DEFAULT ? t.purge.extract.DEFAULT : (p = (f = t.content) == null ? void 0 : f.extract) != null && p.DEFAULT ? t.content.extract.DEFAULT : (d = (c = t.purge) == null ? void 0 : c.options) != null && d.extractors ? t.purge.options.extractors : (y = (h = t.content) == null ? void 0 : h.options) != null && y.extractors ? t.content.options.extractors : {};
    })(), i = {}, s = (() => {
      var a, o2, l, u;
      if ((o2 = (a = t.purge) == null ? void 0 : a.options) != null && o2.defaultExtractor)
        return t.purge.options.defaultExtractor;
      if ((u = (l = t.content) == null ? void 0 : l.options) != null && u.defaultExtractor)
        return t.content.options.defaultExtractor;
    })();
    if (s !== void 0 && (i.DEFAULT = s), typeof n == "function")
      i.DEFAULT = n;
    else if (Array.isArray(n))
      for (let { extensions: a, extractor: o2 } of n != null ? n : [])
        for (let l of a)
          i[l] = o2;
    else
      typeof n == "object" && n !== null && Object.assign(i, n);
    return i;
  })(), transform: (() => {
    let n = (() => {
      var s, a, o2, l, u, f;
      return (s = t.purge) != null && s.transform ? t.purge.transform : (a = t.content) != null && a.transform ? t.content.transform : (l = (o2 = t.purge) == null ? void 0 : o2.transform) != null && l.DEFAULT ? t.purge.transform.DEFAULT : (f = (u = t.content) == null ? void 0 : u.transform) != null && f.DEFAULT ? t.content.transform.DEFAULT : {};
    })(), i = {};
    return typeof n == "function" && (i.DEFAULT = n), typeof n == "object" && n !== null && Object.assign(i, n), i;
  })() };
  for (let n of t.content.files)
    if (typeof n == "string" && /{([^,]*?)}/g.test(n)) {
      D.warn("invalid-glob-braces", [`The glob pattern ${n} in your Tailwind CSS configuration is invalid.`, `Update it to ${n.replace(/{([^,]*?)}/g, "$1")} to silence this warning.`]);
      break;
    }
  return t;
}
function _n(t) {
  return Array.isArray(t) ? t.map((e) => _n(e)) : typeof t == "object" && t !== null ? Object.fromEntries(Object.entries(t).map(([e, r]) => [e, _n(r)])) : t;
}
function pt(t) {
  return typeof t == "function";
}
function pr(t, ...e) {
  let r = e.pop();
  for (let n of e)
    for (let i in n) {
      let s = r(t[i], n[i]);
      s === void 0 ? X(t[i]) && X(n[i]) ? t[i] = pr({}, t[i], n[i], r) : t[i] = n[i] : t[i] = s;
    }
  return t;
}
var fa = { colors: mc, negative(t) {
  return Object.keys(t).filter((e) => t[e] !== "0").reduce((e, r) => {
    let n = De(t[r]);
    return n !== void 0 && (e[`-${r}`] = n), e;
  }, {});
}, breakpoints(t) {
  return Object.keys(t).filter((e) => typeof t[e] == "string").reduce((e, r) => ({ ...e, [`screen-${r}`]: t[r] }), {});
} };
function g0(t, ...e) {
  return pt(t) ? t(...e) : t;
}
function y0(t) {
  return t.reduce((e, { extend: r }) => pr(e, r, (n, i) => n === void 0 ? [i] : Array.isArray(n) ? [i, ...n] : [i, n]), {});
}
function w0(t) {
  return { ...t.reduce((e, r) => ua(e, r), {}), extend: y0(t) };
}
function yc(t, e) {
  if (Array.isArray(t) && X(t[0]))
    return t.concat(e);
  if (Array.isArray(e) && X(e[0]) && X(t))
    return [t, ...e];
  if (Array.isArray(e))
    return e;
}
function v0({ extend: t, ...e }) {
  return pr(e, t, (r, n) => !pt(r) && !n.some(pt) ? pr({}, r, ...n, yc) : (i, s) => pr({}, ...[r, ...n].map((a) => g0(a, i, s)), yc));
}
function* b0(t) {
  let e = Ne(t);
  if (e.length === 0 || (yield e, Array.isArray(t)))
    return;
  let r = /^(.*?)\s*\/\s*([^/]+)$/, n = t.match(r);
  if (n !== null) {
    let [, i, s] = n, a = Ne(i);
    a.alpha = s, yield a;
  }
}
function x0(t) {
  let e = (r, n) => {
    for (let i of b0(r)) {
      let s = 0, a = t;
      for (; a != null && s < i.length; )
        a = a[i[s++]], a = pt(a) && (i.alpha === void 0 || s <= i.length - 1) ? a(e, fa) : a;
      if (a !== void 0) {
        if (i.alpha !== void 0) {
          let o2 = at(a);
          return ve(o2, i.alpha, N(o2));
        }
        return X(a) ? _n(a) : a;
      }
    }
    return n;
  };
  return Object.assign(e, { theme: e, ...fa }), Object.keys(t).reduce((r, n) => (r[n] = pt(t[n]) ? t[n](e, fa) : t[n], r), {});
}
function wc(t) {
  let e = [];
  return t.forEach((r) => {
    var i;
    e = [...e, r];
    let n = (i = r == null ? void 0 : r.plugins) != null ? i : [];
    n.length !== 0 && n.forEach((s) => {
      var a;
      s.__isOptionsFunction && (s = s()), e = [...e, ...wc([(a = s == null ? void 0 : s.config) != null ? a : {}])];
    });
  }), e;
}
function S0(t) {
  return [...t].reduceRight((r, n) => pt(n) ? n({ corePlugins: r }) : hc(n, r), dc);
}
function k0(t) {
  return [...t].reduceRight((r, n) => [...r, ...n], []);
}
function ca(t) {
  let e = [...wc(t), { prefix: "", important: false, separator: ":" }];
  return gc(ua({ theme: x0(v0(w0(e.map((r) => {
    var n;
    return (n = r == null ? void 0 : r.theme) != null ? n : {};
  })))), corePlugins: S0(e.map((r) => r.corePlugins)), plugins: k0(t.map((r) => {
    var n;
    return (n = r == null ? void 0 : r.plugins) != null ? n : [];
  })) }, ...e));
}
var vc = { content: [], presets: [], darkMode: "media", theme: { accentColor: ({ theme: t }) => ({ ...t("colors"), auto: "auto" }), animation: { none: "none", spin: "spin 1s linear infinite", ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite", pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite", bounce: "bounce 1s infinite" }, aria: { checked: 'checked="true"', disabled: 'disabled="true"', expanded: 'expanded="true"', hidden: 'hidden="true"', pressed: 'pressed="true"', readonly: 'readonly="true"', required: 'required="true"', selected: 'selected="true"' }, aspectRatio: { auto: "auto", square: "1 / 1", video: "16 / 9" }, backdropBlur: ({ theme: t }) => t("blur"), backdropBrightness: ({ theme: t }) => t("brightness"), backdropContrast: ({ theme: t }) => t("contrast"), backdropGrayscale: ({ theme: t }) => t("grayscale"), backdropHueRotate: ({ theme: t }) => t("hueRotate"), backdropInvert: ({ theme: t }) => t("invert"), backdropOpacity: ({ theme: t }) => t("opacity"), backdropSaturate: ({ theme: t }) => t("saturate"), backdropSepia: ({ theme: t }) => t("sepia"), backgroundColor: ({ theme: t }) => t("colors"), backgroundImage: { none: "none", "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))", "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))", "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))", "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))", "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))", "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))", "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))", "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))" }, backgroundOpacity: ({ theme: t }) => t("opacity"), backgroundPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, backgroundSize: { auto: "auto", cover: "cover", contain: "contain" }, blur: { 0: "0", none: "0", sm: "4px", DEFAULT: "8px", md: "12px", lg: "16px", xl: "24px", "2xl": "40px", "3xl": "64px" }, borderColor: ({ theme: t }) => ({ ...t("colors"), DEFAULT: t("colors.gray.200", "currentColor") }), borderOpacity: ({ theme: t }) => t("opacity"), borderRadius: { none: "0px", sm: "0.125rem", DEFAULT: "0.25rem", md: "0.375rem", lg: "0.5rem", xl: "0.75rem", "2xl": "1rem", "3xl": "1.5rem", full: "9999px" }, borderSpacing: ({ theme: t }) => ({ ...t("spacing") }), borderWidth: { DEFAULT: "1px", 0: "0px", 2: "2px", 4: "4px", 8: "8px" }, boxShadow: { sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)", DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)", md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)", lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)", xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)", "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)", inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)", none: "none" }, boxShadowColor: ({ theme: t }) => t("colors"), brightness: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5", 200: "2" }, caretColor: ({ theme: t }) => t("colors"), colors: ({ colors: t }) => ({ inherit: t.inherit, current: t.current, transparent: t.transparent, black: t.black, white: t.white, slate: t.slate, gray: t.gray, zinc: t.zinc, neutral: t.neutral, stone: t.stone, red: t.red, orange: t.orange, amber: t.amber, yellow: t.yellow, lime: t.lime, green: t.green, emerald: t.emerald, teal: t.teal, cyan: t.cyan, sky: t.sky, blue: t.blue, indigo: t.indigo, violet: t.violet, purple: t.purple, fuchsia: t.fuchsia, pink: t.pink, rose: t.rose }), columns: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", "3xs": "16rem", "2xs": "18rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem" }, container: {}, content: { none: "none" }, contrast: { 0: "0", 50: ".5", 75: ".75", 100: "1", 125: "1.25", 150: "1.5", 200: "2" }, cursor: { auto: "auto", default: "default", pointer: "pointer", wait: "wait", text: "text", move: "move", help: "help", "not-allowed": "not-allowed", none: "none", "context-menu": "context-menu", progress: "progress", cell: "cell", crosshair: "crosshair", "vertical-text": "vertical-text", alias: "alias", copy: "copy", "no-drop": "no-drop", grab: "grab", grabbing: "grabbing", "all-scroll": "all-scroll", "col-resize": "col-resize", "row-resize": "row-resize", "n-resize": "n-resize", "e-resize": "e-resize", "s-resize": "s-resize", "w-resize": "w-resize", "ne-resize": "ne-resize", "nw-resize": "nw-resize", "se-resize": "se-resize", "sw-resize": "sw-resize", "ew-resize": "ew-resize", "ns-resize": "ns-resize", "nesw-resize": "nesw-resize", "nwse-resize": "nwse-resize", "zoom-in": "zoom-in", "zoom-out": "zoom-out" }, divideColor: ({ theme: t }) => t("borderColor"), divideOpacity: ({ theme: t }) => t("borderOpacity"), divideWidth: ({ theme: t }) => t("borderWidth"), dropShadow: { sm: "0 1px 1px rgb(0 0 0 / 0.05)", DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"], md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"], lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"], xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"], "2xl": "0 25px 25px rgb(0 0 0 / 0.15)", none: "0 0 #0000" }, fill: ({ theme: t }) => ({ none: "none", ...t("colors") }), flex: { 1: "1 1 0%", auto: "1 1 auto", initial: "0 1 auto", none: "none" }, flexBasis: ({ theme: t }) => ({ auto: "auto", ...t("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%" }), flexGrow: { 0: "0", DEFAULT: "1" }, flexShrink: { 0: "0", DEFAULT: "1" }, fontFamily: { sans: ["ui-sans-serif", "system-ui", "-apple-system", "BlinkMacSystemFont", '"Segoe UI"', "Roboto", '"Helvetica Neue"', "Arial", '"Noto Sans"', "sans-serif", '"Apple Color Emoji"', '"Segoe UI Emoji"', '"Segoe UI Symbol"', '"Noto Color Emoji"'], serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"], mono: ["ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", '"Liberation Mono"', '"Courier New"', "monospace"] }, fontSize: { xs: ["0.75rem", { lineHeight: "1rem" }], sm: ["0.875rem", { lineHeight: "1.25rem" }], base: ["1rem", { lineHeight: "1.5rem" }], lg: ["1.125rem", { lineHeight: "1.75rem" }], xl: ["1.25rem", { lineHeight: "1.75rem" }], "2xl": ["1.5rem", { lineHeight: "2rem" }], "3xl": ["1.875rem", { lineHeight: "2.25rem" }], "4xl": ["2.25rem", { lineHeight: "2.5rem" }], "5xl": ["3rem", { lineHeight: "1" }], "6xl": ["3.75rem", { lineHeight: "1" }], "7xl": ["4.5rem", { lineHeight: "1" }], "8xl": ["6rem", { lineHeight: "1" }], "9xl": ["8rem", { lineHeight: "1" }] }, fontWeight: { thin: "100", extralight: "200", light: "300", normal: "400", medium: "500", semibold: "600", bold: "700", extrabold: "800", black: "900" }, gap: ({ theme: t }) => t("spacing"), gradientColorStops: ({ theme: t }) => t("colors"), grayscale: { 0: "0", DEFAULT: "100%" }, gridAutoColumns: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridAutoRows: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridColumn: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-7": "span 7 / span 7", "span-8": "span 8 / span 8", "span-9": "span 9 / span 9", "span-10": "span 10 / span 10", "span-11": "span 11 / span 11", "span-12": "span 12 / span 12", "span-full": "1 / -1" }, gridColumnEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridColumnStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridRow: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-full": "1 / -1" }, gridRowEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridRowStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridTemplateColumns: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))", 7: "repeat(7, minmax(0, 1fr))", 8: "repeat(8, minmax(0, 1fr))", 9: "repeat(9, minmax(0, 1fr))", 10: "repeat(10, minmax(0, 1fr))", 11: "repeat(11, minmax(0, 1fr))", 12: "repeat(12, minmax(0, 1fr))" }, gridTemplateRows: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))" }, height: ({ theme: t }) => ({ auto: "auto", ...t("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), hueRotate: { 0: "0deg", 15: "15deg", 30: "30deg", 60: "60deg", 90: "90deg", 180: "180deg" }, inset: ({ theme: t }) => ({ auto: "auto", ...t("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), invert: { 0: "0", DEFAULT: "100%" }, keyframes: { spin: { to: { transform: "rotate(360deg)" } }, ping: { "75%, 100%": { transform: "scale(2)", opacity: "0" } }, pulse: { "50%": { opacity: ".5" } }, bounce: { "0%, 100%": { transform: "translateY(-25%)", animationTimingFunction: "cubic-bezier(0.8,0,1,1)" }, "50%": { transform: "none", animationTimingFunction: "cubic-bezier(0,0,0.2,1)" } } }, letterSpacing: { tighter: "-0.05em", tight: "-0.025em", normal: "0em", wide: "0.025em", wider: "0.05em", widest: "0.1em" }, lineHeight: { none: "1", tight: "1.25", snug: "1.375", normal: "1.5", relaxed: "1.625", loose: "2", 3: ".75rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem" }, listStyleType: { none: "none", disc: "disc", decimal: "decimal" }, margin: ({ theme: t }) => ({ auto: "auto", ...t("spacing") }), maxHeight: ({ theme: t }) => ({ ...t("spacing"), none: "none", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), maxWidth: ({ theme: t, breakpoints: e }) => ({ none: "none", 0: "0rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem", full: "100%", min: "min-content", max: "max-content", fit: "fit-content", prose: "65ch", ...e(t("screens")) }), minHeight: { 0: "0px", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }, minWidth: { 0: "0px", full: "100%", min: "min-content", max: "max-content", fit: "fit-content" }, objectPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, opacity: { 0: "0", 5: "0.05", 10: "0.1", 20: "0.2", 25: "0.25", 30: "0.3", 40: "0.4", 50: "0.5", 60: "0.6", 70: "0.7", 75: "0.75", 80: "0.8", 90: "0.9", 95: "0.95", 100: "1" }, order: { first: "-9999", last: "9999", none: "0", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12" }, outlineColor: ({ theme: t }) => t("colors"), outlineOffset: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, outlineWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, padding: ({ theme: t }) => t("spacing"), placeholderColor: ({ theme: t }) => t("colors"), placeholderOpacity: ({ theme: t }) => t("opacity"), ringColor: ({ theme: t }) => ({ DEFAULT: t("colors.blue.500", "#3b82f6"), ...t("colors") }), ringOffsetColor: ({ theme: t }) => t("colors"), ringOffsetWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, ringOpacity: ({ theme: t }) => ({ DEFAULT: "0.5", ...t("opacity") }), ringWidth: { DEFAULT: "3px", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, rotate: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg", 45: "45deg", 90: "90deg", 180: "180deg" }, saturate: { 0: "0", 50: ".5", 100: "1", 150: "1.5", 200: "2" }, scale: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5" }, screens: { sm: "640px", md: "768px", lg: "1024px", xl: "1280px", "2xl": "1536px" }, scrollMargin: ({ theme: t }) => ({ ...t("spacing") }), scrollPadding: ({ theme: t }) => t("spacing"), sepia: { 0: "0", DEFAULT: "100%" }, skew: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg" }, space: ({ theme: t }) => ({ ...t("spacing") }), spacing: { px: "1px", 0: "0px", 0.5: "0.125rem", 1: "0.25rem", 1.5: "0.375rem", 2: "0.5rem", 2.5: "0.625rem", 3: "0.75rem", 3.5: "0.875rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem", 11: "2.75rem", 12: "3rem", 14: "3.5rem", 16: "4rem", 20: "5rem", 24: "6rem", 28: "7rem", 32: "8rem", 36: "9rem", 40: "10rem", 44: "11rem", 48: "12rem", 52: "13rem", 56: "14rem", 60: "15rem", 64: "16rem", 72: "18rem", 80: "20rem", 96: "24rem" }, stroke: ({ theme: t }) => ({ none: "none", ...t("colors") }), strokeWidth: { 0: "0", 1: "1", 2: "2" }, supports: {}, data: {}, textColor: ({ theme: t }) => t("colors"), textDecorationColor: ({ theme: t }) => t("colors"), textDecorationThickness: { auto: "auto", "from-font": "from-font", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, textIndent: ({ theme: t }) => ({ ...t("spacing") }), textOpacity: ({ theme: t }) => t("opacity"), textUnderlineOffset: { auto: "auto", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, transformOrigin: { center: "center", top: "top", "top-right": "top right", right: "right", "bottom-right": "bottom right", bottom: "bottom", "bottom-left": "bottom left", left: "left", "top-left": "top left" }, transitionDelay: { 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1e3: "1000ms" }, transitionDuration: { DEFAULT: "150ms", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1e3: "1000ms" }, transitionProperty: { none: "none", all: "all", DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter", colors: "color, background-color, border-color, text-decoration-color, fill, stroke", opacity: "opacity", shadow: "box-shadow", transform: "transform" }, transitionTimingFunction: { DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)", linear: "linear", in: "cubic-bezier(0.4, 0, 1, 1)", out: "cubic-bezier(0, 0, 0.2, 1)", "in-out": "cubic-bezier(0.4, 0, 0.2, 1)" }, translate: ({ theme: t }) => ({ ...t("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), width: ({ theme: t }) => ({ auto: "auto", ...t("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%", screen: "100vw", min: "min-content", max: "max-content", fit: "fit-content" }), willChange: { auto: "auto", scroll: "scroll-position", contents: "contents", transform: "transform" }, zIndex: { auto: "auto", 0: "0", 10: "10", 20: "20", 30: "30", 40: "40", 50: "50" } }, plugins: [] };
function Tn(t) {
  var i;
  let e = ((i = t == null ? void 0 : t.presets) != null ? i : [vc]).slice().reverse().flatMap((s) => Tn(s instanceof Function ? s() : s)), r = { respectDefaultRingColorOpacity: { theme: { ringColor: ({ theme: s }) => ({ DEFAULT: "#3b82f67f", ...s("colors") }) } }, disableColorOpacityUtilitiesByDefault: { corePlugins: { backgroundOpacity: false, borderOpacity: false, divideOpacity: false, placeholderOpacity: false, ringOpacity: false, textOpacity: false } } }, n = Object.keys(r).filter((s) => G(t, s)).map((s) => r[s]);
  return [t, ...n, ...e];
}
function pa(...t) {
  let [, ...e] = Tn(t[0]);
  return ca([...t, ...e]);
}
var bc = (t) => {
  var n;
  let e = pa((n = t.config) != null ? n : {});
  return la((i) => () => i.createContext(e, [{ content: t.content }]));
};
var mp = Y(hp());
var gp = (t) => {
  let e = bc({ config: t.config, content: t.content });
  return I2([e, (0, mp.default)()]).process(yp, { from: void 0 }).css;
};
var yp = String.raw`
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
`;
function vp(t) {
  let e = I2.parse(t);
  return en.objectify(e);
}
var sb = (t, e) => {
  var i, s;
  let r = (s = (i = e == null ? void 0 : e.corePlugins) == null ? void 0 : i.preflight) != null ? s : false, n = (e == null ? void 0 : e.corePlugins) || {};
  return gp({ config: { ...e, corePlugins: { ...n, preflight: r } }, content: t });
};
var bp = ({ config: t, options: e }) => ({ twi: xa(t, e), twj: Sp(t, e) });
var xp = (...t) => {
  let e = "";
  return typeof t[0] == "string" ? e = t[0] : Array.isArray(t[0]) ? e = t.flat(1 / 0).map((r) => xp(r)).join(" ") : typeof t[0] == "object" && (e = Object.entries(t[0]).filter((r) => !!r[1]).map((r) => r[0]).join(" ")), e = e.replace(/\s+/g, " "), e;
};
var xa = (t, e) => (...r) => {
  let n = xp(r), { 1: i } = r || {}, a = { ...{ merge: true, minify: true, ignoreMediaQueries: true }, ...e, ...i }, o2 = _a2(sb(n, t));
  return a != null && a.ignoreMediaQueries ? o2.removeMediaQueries() : (o2.removeUndefined(), o2.combineMediaQueries()), o2.fixRGB(), a != null && a.merge && o2.merge(), a != null && a.minify && o2.minify(), o2.get();
};
var Sp = (t, e) => (...r) => vp(xa(t, e)(r));
var wp = xa();
var ab2 = Sp();

// node_modules/@react-email/tailwind/dist/index.mjs
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var Tailwind = ({ children, config }) => {
  const { twi } = bp({
    config
  });
  const newChildren = React13.Children.toArray(children);
  const fullHTML = (0, import_server2.renderToStaticMarkup)((0, import_jsx_runtime15.jsx)(import_jsx_runtime15.Fragment, { children: newChildren }));
  const tailwindCss = twi(fullHTML, {
    merge: false,
    ignoreMediaQueries: false
  });
  const css = cleanCss(tailwindCss);
  const cssMap = makeCssMap(css);
  const headStyle = getMediaQueryCss(css);
  const hasResponsiveStyles = /@media[^{]+\{(?<content>[\s\S]+?)\}\s*\}/gm.test(
    headStyle
  );
  const hasHTML = /<html[^>]*>/gm.test(fullHTML);
  const hasHead = /<head[^>]*>/gm.test(fullHTML);
  if (hasResponsiveStyles && (!hasHTML || !hasHead)) {
    throw new Error(
      "Tailwind: To use responsive styles you must have a <html> and <head> element in your template."
    );
  }
  const reactHTML = React13.Children.map(newChildren, (child) => {
    if (!React13.isValidElement(child))
      return child;
    const html = (0, import_server2.renderToStaticMarkup)(child);
    const parsedHTML = html_react_parser_default(html, {
      replace: (domNode) => {
        var _a3;
        if (domNode instanceof Element2) {
          if (hasResponsiveStyles && hasHead && domNode.name === "head") {
            let newDomNode = null;
            if (domNode.children) {
              const props = attributesToProps(domNode.attribs);
              newDomNode = (0, import_jsx_runtime15.jsxs)("head", { ...props, children: [
                domToReact(domNode.children),
                (0, import_jsx_runtime15.jsx)("style", { children: headStyle })
              ] });
            }
            return newDomNode;
          }
          if ((_a3 = domNode.attribs) == null ? void 0 : _a3.class) {
            const cleanRegex = /[:#\!\-[\]\/\.%]+/g;
            const cleanTailwindClasses = domNode.attribs.class.replace(cleanRegex, "_");
            const currentStyles = domNode.attribs.style ? `${domNode.attribs.style};` : "";
            const tailwindStyles = cleanTailwindClasses.split(" ").map((className) => {
              return cssMap[`.${className}`];
            }).join(";");
            domNode.attribs.style = `${currentStyles} ${tailwindStyles}`;
            domNode.attribs.class = domNode.attribs.class.split(" ").filter((className) => className.search(/^.{2}:/) !== -1).join(" ").replace(cleanRegex, "_");
            if (domNode.attribs.class === "")
              delete domNode.attribs.class;
          }
        }
      }
    });
    return parsedHTML;
  });
  return (0, import_jsx_runtime15.jsx)(import_jsx_runtime15.Fragment, { children: reactHTML });
};
Tailwind.displayName = "Tailwind";
function cleanCss(css) {
  let newCss = css.replace(/\\/g, "").replace(/[.\!\#\w\d\\:\-\[\]\/\.%\(\))]+(?=\s*?{[^{]*?\})\s*?{/g, (m) => {
    return m.replace(new RegExp("(?<=.)[:#\\!\\-[\\\\\\]\\/\\.%]+", "g"), "_");
  }).replace(/font-family(?<value>[^;\r\n]+)/g, (m, value) => {
    return `font-family${value.replace(/['"]+/g, "")}`;
  });
  return newCss;
}
function getMediaQueryCss(css) {
  var _a3;
  const mediaQueryRegex = /@media[^{]+\{(?<content>[\s\S]+?)\}\s*\}/gm;
  return ((_a3 = css.replace(mediaQueryRegex, (m) => {
    return m.replace(
      /([^{]+\{)([\s\S]+?)(\}\s*\})/gm,
      (_, start, content, end) => {
        const newContent = content.replace(
          /(?:[\s\r\n]*)?(?<prop>[\w-]+)\s*:\s*(?<value>[^};\r\n]+)/gm,
          (_2, prop, value) => {
            return `${prop}: ${value} !important;`;
          }
        );
        return `${start}${newContent}${end}`;
      }
    );
  }).match(/@media\s*([^{]+)\{([^{}]*\{[^{}]*\})*[^{}]*\}/g)) == null ? void 0 : _a3.join("")) ?? "";
}
function makeCssMap(css) {
  const cssNoMedia = css.replace(
    /@media[^{]+\{(?<content>[\s\S]+?)\}\s*\}/gm,
    ""
  );
  const cssMap = cssNoMedia.split("}").reduce((acc, cur) => {
    const [key, value] = cur.split("{");
    if (key && value) {
      acc[key] = value;
    }
    return acc;
  }, {});
  return cssMap;
}

// node_modules/@react-email/text/dist/index.mjs
var React14 = __toESM(require_react(), 1);
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var Text4 = React14.forwardRef(
  ({ style, ...props }, forwardedRef) => (0, import_jsx_runtime16.jsx)(
    "p",
    {
      ...props,
      ref: forwardedRef,
      "data-id": "react-email-text",
      style: {
        fontSize: "14px",
        lineHeight: "24px",
        margin: "16px 0",
        ...style
      }
    }
  )
);
Text4.displayName = "Text";
export {
  Body,
  Button,
  Column,
  Container,
  Font,
  Head,
  Heading,
  Hr,
  Html,
  Img,
  Link,
  Preview,
  Row,
  Section,
  Tailwind,
  Text4 as Text,
  render2 as render,
  renderAsync
};
/*! Bundled license information:

tw-to-css/dist/index.mjs.js:
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)
*/
//# sourceMappingURL=@react-email_components.js.map
